make[1]: Entering directory '/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/PARSEC3/benchmarks/fluidanimate'
./runEnablers.sh fluidanimate fluidanimate.bc simlarge "-lm -lstdc++ -lpthread -L../../parsec-3.0/pkgs/apps/x264/inst/amd64-linux.gclang/lib -lx264 -L/usr/lib64 -L/usr/lib" -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier
/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/PARSEC3/benchmarks/fluidanimate /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/PARSEC3/benchmarks/fluidanimate
Cloning https://github.com/scampanoni/virgil.git
Cloning into 'threadpool'...
/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/PARSEC3/benchmarks/fluidanimate
The IR has already been transformed for enabling parallelization
noelle-parallelizer baseline_with_metadata.bc -o baseline_parallelized.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
noelle-meta-loop-embed baseline_with_metadata.bc -o afterLoopMetadata.bc
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopMetadata.so -LoopMetadata baseline_with_metadata.bc -o afterLoopMetadata.bc
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopMetadata.so -LoopMetadata baseline_with_metadata.bc -o afterLoopMetadata.bc
noelle-parallelization-planner afterLoopMetadata.bc -o baseline_with_parallel_plan.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Planner.so -planner afterLoopMetadata.bc -o baseline_with_parallel_plan.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Planner.so -planner afterLoopMetadata.bc -o baseline_with_parallel_plan.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Planner.so -planner afterLoopMetadata.bc -o baseline_with_parallel_plan.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
Planner: Start
Planner:  Fetching the program loops
Noelle: Filter out cold code
Noelle:  Function "main"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, %23, !noelle.pdg.inst.id !182" (9.893907e+01%)
Noelle:  Function "_Z12AdvanceFramev"
Noelle:  Function "_Z13ComputeForcesv"
Noelle:     Loop "  %26 = icmp slt i64 %indvars.iv58, %24, !noelle.pdg.inst.id !3403" (1.875137e-01%)
Noelle:     Loop "  %32 = icmp slt i32 %.05, %30, !noelle.pdg.inst.id !3412" (1.546733e-01%)
Noelle:     Loop "  %66 = icmp slt i64 %indvars.iv90, %63, !noelle.pdg.inst.id !3457" (3.203275e+01%)
Noelle:     Loop "  %69 = icmp slt i64 %indvars.iv88, %59, !noelle.pdg.inst.id !3466" (3.203273e+01%)
Noelle:     Loop "  %75 = icmp slt i64 %indvars.iv86, %61, !noelle.pdg.inst.id !3477" (3.203170e+01%)
Noelle:     Loop "  %85 = icmp eq i64 %indvars.iv83, 2, !noelle.pdg.inst.id !3492" (1.368649e+00%)
Noelle:     Loop "  %89 = icmp eq i64 %indvars.iv80, 2, !noelle.pdg.inst.id !3504" (1.299458e+00%)
Noelle:     Loop "  %96 = icmp eq i64 %indvars.iv77, 2, !noelle.pdg.inst.id !3525" (1.036190e+00%)
Noelle:     Loop "  %119 = icmp slt i32 %.016, %78, !noelle.pdg.inst.id !3568" (3.060445e+01%)
Noelle:     Loop "  %129 = icmp slt i64 %indvars.iv54, %117, !noelle.pdg.inst.id !3581" (3.044969e+01%)
Noelle:     Loop "  %138 = icmp slt i32 %.023, %136, !noelle.pdg.inst.id !3592" (2.911907e+01%)
Noelle:     Loop "  %199 = icmp slt i64 %indvars.iv52, %24, !noelle.pdg.inst.id !3669" (1.875137e-01%)
Noelle:     Loop "  %205 = icmp slt i32 %.027, %203, !noelle.pdg.inst.id !3677" (1.546733e-01%)
Noelle:     Loop "  %240 = sext i32 %239 to i64, !noelle.pdg.inst.id !3716" (6.212268e+01%)
Noelle:     Loop "  %244 = icmp slt i64 %indvars.iv73, %59, !noelle.pdg.inst.id !3725" (6.212266e+01%)
Noelle:     Loop "  %250 = icmp slt i64 %indvars.iv71, %61, !noelle.pdg.inst.id !3735" (6.212162e+01%)
Noelle:     Loop "  %260 = icmp eq i64 %indvars.iv68, 2, !noelle.pdg.inst.id !3748" (1.368649e+00%)
Noelle:     Loop "  %264 = icmp eq i64 %indvars.iv65, 2, !noelle.pdg.inst.id !3758" (1.299458e+00%)
Noelle:     Loop "  %271 = icmp eq i64 %indvars.iv63, 2, !noelle.pdg.inst.id !3777" (1.036190e+00%)
Noelle:     Loop "  %294 = icmp slt i32 %.018, %253, !noelle.pdg.inst.id !3816" (6.069438e+01%)
Noelle:     Loop "  %303 = icmp slt i64 %indvars.iv, %292, !noelle.pdg.inst.id !3827" (6.054786e+01%)
Noelle:     Loop "  %312 = icmp slt i32 %.04, %310, !noelle.pdg.inst.id !3837" (5.921724e+01%)
Noelle:  Function "_ZNK4Vec3miERKS_"
Noelle:  Function "_ZNK4Vec3mlEf"
Noelle:  Function "_ZN4Vec3C2Efff"
Noelle:  Function "_ZNK4Vec311GetLengthSqEv"
Noelle:  Function "_ZN4Vec3pLERKS_"
Noelle:  Function "_ZN4Vec3mIERKS_"
Noelle:  Function "_Z11RebuildGridv"
Noelle:     Loop "  %9 = icmp slt i64 %indvars.iv29, %7, !noelle.pdg.inst.id !1250" (4.743599e-02%)
Noelle:  Disable loop "23" as cold code
Noelle:     Loop "  %20 = sext i32 %19 to i64, !noelle.pdg.inst.id !1266" (1.247899e+00%)
Noelle:     Loop "  %29 = icmp slt i32 %.04, %27, !noelle.pdg.inst.id !1275" (1.167658e+00%)
Noelle:     Loop "  %exitcond.i = icmp eq i32 %.0.i, %100, !noelle.pdg.inst.id !1379" (0.000000e+00%)
Noelle:  Disable loop "26" as cold code
Noelle:  Function "_Z16AdvanceParticlesv"
Noelle:     Loop "  %59 = icmp slt i64 %indvars.iv, %55, !noelle.pdg.inst.id !1665" (1.102129e+00%)
Noelle:     Loop "  %65 = icmp slt i32 %.02, %63, !noelle.pdg.inst.id !1674" (1.069289e+00%)
Noelle:  Function "_ZN4Vec3dVEf"
Noelle:  Function "_Z7InitSimPKc"
Noelle:     Loop "  %157 = icmp slt i64 %indvars.iv, %151, !noelle.pdg.inst.id !8040" (6.699223e-01%)
Noelle:     Loop "  %185 = load i32, i32* @numParticles, align 4, !tbaa !7941, !noelle.pdg.inst.id !82" (2.191821e-01%)
Noelle:     Loop "  %249 = icmp sgt i32 %.0, 16, !noelle.pdg.inst.id !8139" (6.591941e-03%)
Noelle:  Disable loop "31" as cold code
Noelle:     Loop "  %exitcond.i = icmp eq i32 %.0.i, %264, !noelle.pdg.inst.id !8188" (0.000000e+00%)
Noelle:  Disable loop "32" as cold code
Noelle:  Function "_ZN4CellC2Ev"
Noelle:     Loop "  tail call void @_ZN4Vec3C2Ev(%class.Vec3* %4), !noelle.pdg.inst.id !35" (1.375603e-01%)
Noelle:     Loop "  tail call void @_ZN4Vec3C2Ev(%class.Vec3* %10), !noelle.pdg.inst.id !46" (1.375603e-01%)
Noelle:     Loop "  tail call void @_ZN4Vec3C2Ev(%class.Vec3* %16), !noelle.pdg.inst.id !56" (1.375603e-01%)
Noelle:     Loop "  tail call void @_ZN4Vec3C2Ev(%class.Vec3* %22), !noelle.pdg.inst.id !66" (1.375603e-01%)
Noelle:  Function "_ZSt3maxIfERKT_S2_S2_"
Noelle:  Function "_Z8SaveFilePKc"
Noelle:     Loop "  %54 = load i32, i32* @numCells, align 4, !tbaa !1446, !noelle.pdg.inst.id !67" (1.526473e-01%)
Noelle:     Loop "  %63 = icmp slt i32 %.0, %61, !noelle.pdg.inst.id !1460" (4.411807e-02%)
Noelle:  Disable loop "38" as cold code
Noelle:     Loop "  %84 = icmp slt i32 %83, %61, !noelle.pdg.inst.id !1505" (9.685274e-02%)
Noelle:  Disable loop "39" as cold code
Noelle:  Function "_ZN4Vec3mLEf"
Noelle:  Function "_ZN4Vec3C2Ev"
Noelle:  Disable "_ZN4Vec3C2Ev" as cold function
Noelle:  Function "_Z17ProcessCollisionsv"
Noelle:  Disable "_Z17ProcessCollisionsv" as cold function
Noelle:  Function "_Z18ProcessCollisions2v"
Noelle:  Disable "_Z18ProcessCollisions2v" as cold function
Noelle:  Function "_Z10CleanUpSimv"
Noelle:  Disable "_Z10CleanUpSimv" as cold function
Noelle:  Function "_Z13cellpool_initP8cellpooli"
Noelle:  Disable "_Z13cellpool_initP8cellpooli" as cold function
Noelle:  Function "_ZL19cellpool_allocblocki"
Noelle:  Disable "_ZL19cellpool_allocblocki" as cold function
Noelle:  Function "_ZSt4swapIPiENSt9enable_ifIXsr6__and_ISt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS4_ESt18is_move_assignableIS4_EEE5valueEvE4typeERS4_SD_"
Noelle:  Disable "_ZSt4swapIPiENSt9enable_ifIXsr6__and_ISt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS4_ESt18is_move_assignableIS4_EEE5valueEvE4typeERS4_SD_" as cold function
Noelle:  Function "_ZSt4swapIP4CellENSt9enable_ifIXsr6__and_ISt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS5_ESt18is_move_assignableIS5_EEE5valueEvE4typeERS5_SE_"
Noelle:  Disable "_ZSt4swapIP4CellENSt9enable_ifIXsr6__and_ISt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS5_ESt18is_move_assignableIS5_EEE5valueEvE4typeERS5_SE_" as cold function
Noelle:  Function "_GLOBAL__sub_I_serial.cpp"
Noelle:  Disable "_GLOBAL__sub_I_serial.cpp" as cold function
Noelle:  Function "_GLOBAL__sub_I_cellpool.cpp"
Noelle:  Disable "_GLOBAL__sub_I_cellpool.cpp" as cold function
Noelle:  Function "_Z16cellpool_destroyP8cellpool"
Noelle:  Disable "_Z16cellpool_destroyP8cellpool" as cold function
Noelle:  Function "_ZSt4moveIRPiEONSt16remove_referenceIT_E4typeEOS3_"
Noelle:  Disable "_ZSt4moveIRPiEONSt16remove_referenceIT_E4typeEOS3_" as cold function
Noelle:  Function "_ZSt4moveIRP4CellEONSt16remove_referenceIT_E4typeEOS4_"
Noelle:  Disable "_ZSt4moveIRP4CellEONSt16remove_referenceIT_E4typeEOS4_" as cold function
Noelle:  Function "__cxx_global_var_init.3.8"
Noelle:  Disable "__cxx_global_var_init.3.8" as cold function
Noelle:  Function "__cxx_global_var_init.2.7"
Noelle:  Disable "__cxx_global_var_init.2.7" as cold function
Noelle:  Function "__cxx_global_var_init.1.6"
Noelle:  Disable "__cxx_global_var_init.1.6" as cold function
Noelle:  Function "__cxx_global_var_init.1"
Noelle:  Disable "__cxx_global_var_init.1" as cold function
Noelle:  Function "__cxx_global_var_init.2"
Noelle:  Disable "__cxx_global_var_init.2" as cold function
Noelle:  Function "__cxx_global_var_init.3"
Noelle:  Disable "__cxx_global_var_init.3" as cold function
Noelle:  Function "__cxx_global_var_init"
Noelle:  Disable "__cxx_global_var_init" as cold function
Noelle:  Function "__cxx_global_var_init.5"
Noelle:  Disable "__cxx_global_var_init.5" as cold function
Noelle:  Function "__cxx_global_var_init.4"
Noelle:  Disable "__cxx_global_var_init.4" as cold function
Noelle:  Function "_ZNSt14basic_ofstreamIcSt11char_traitsIcEED2Ev"
Noelle:  Disable "_ZNSt14basic_ofstreamIcSt11char_traitsIcEED2Ev" as cold function
Noelle:  Function "_ZNSt14basic_ofstreamIcSt11char_traitsIcEE4openEPKcSt13_Ios_Openmode"
Noelle:  Disable "_ZNSt14basic_ofstreamIcSt11char_traitsIcEE4openEPKcSt13_Ios_Openmode" as cold function
Noelle:  Function "_Z16cellpool_getcellP8cellpool"
Noelle:  Disable "_Z16cellpool_getcellP8cellpool" as cold function
Noelle:  Function "_Z19cellpool_returncellP8cellpoolP4Cell"
Noelle:  Disable "_Z19cellpool_returncellP8cellpoolP4Cell" as cold function
Noelle:  Function "_ZNSoC2Ev"
Noelle:  Disable "_ZNSoC2Ev" as cold function
Noelle:  Function "_ZNSoD2Ev"
Noelle:  Disable "_ZNSoD2Ev" as cold function
Noelle:  Function "_ZNSt14basic_ofstreamIcSt11char_traitsIcEED1Ev"
Noelle:  Disable "_ZNSt14basic_ofstreamIcSt11char_traitsIcEED1Ev" as cold function
Noelle:  Function "_ZNKSt9basic_iosIcSt11char_traitsIcEEcvbEv"
Noelle:  Disable "_ZNKSt9basic_iosIcSt11char_traitsIcEEcvbEv" as cold function
Noelle:  Function "_ZNSt14basic_ofstreamIcSt11char_traitsIcEEC1EPKcSt13_Ios_Openmode"
Noelle:  Disable "_ZNSt14basic_ofstreamIcSt11char_traitsIcEEC1EPKcSt13_Ios_Openmode" as cold function
Noelle:  Function "_ZNKSt5ctypeIcE5widenEc"
Noelle:  Disable "_ZNKSt5ctypeIcE5widenEc" as cold function
Noelle:  Function "_ZSt13__check_facetISt5ctypeIcEERKT_PS3_"
Noelle:  Disable "_ZSt13__check_facetISt5ctypeIcEERKT_PS3_" as cold function
Noelle:  Function "_ZNSt14basic_ifstreamIcSt11char_traitsIcEED1Ev"
Noelle:  Disable "_ZNSt14basic_ifstreamIcSt11char_traitsIcEED1Ev" as cold function
Noelle:  Function "_ZNSt9basic_iosIcSt11char_traitsIcEED2Ev"
Noelle:  Disable "_ZNSt9basic_iosIcSt11char_traitsIcEED2Ev" as cold function
Noelle:  Function "_Z16GetNeighborCellsiiiPi"
Noelle:  Disable "_Z16GetNeighborCellsiiiPi" as cold function
Noelle:  Function "_ZNSt11char_traitsIcE6lengthEPKc"
Noelle:  Disable "_ZNSt11char_traitsIcE6lengthEPKc" as cold function
Noelle:  Function "_ZNSt15basic_streambufIcSt11char_traitsIcEED2Ev"
Noelle:  Disable "_ZNSt15basic_streambufIcSt11char_traitsIcEED2Ev" as cold function
Noelle:  Function "_ZNSiD2Ev"
Noelle:  Disable "_ZNSiD2Ev" as cold function
Noelle:  Function "_ZNSt13basic_filebufIcSt11char_traitsIcEED2Ev"
Noelle:  Disable "_ZNSt13basic_filebufIcSt11char_traitsIcEED2Ev" as cold function
Noelle:  Function "_ZNKSt9basic_iosIcSt11char_traitsIcEE7rdstateEv"
Noelle:  Disable "_ZNKSt9basic_iosIcSt11char_traitsIcEE7rdstateEv" as cold function
Noelle:  Function "_ZNKSt9basic_iosIcSt11char_traitsIcEE4failEv"
Noelle:  Disable "_ZNKSt9basic_iosIcSt11char_traitsIcEE4failEv" as cold function
Noelle:  Function "_ZStorSt12_Ios_IostateS_"
Noelle:  Disable "_ZStorSt12_Ios_IostateS_" as cold function
Noelle:  Function "_ZNKSt9basic_iosIcSt11char_traitsIcEEntEv"
Noelle:  Disable "_ZNKSt9basic_iosIcSt11char_traitsIcEEntEv" as cold function
Noelle:  Function "_ZNSt14basic_ifstreamIcSt11char_traitsIcEEC1EPKcSt13_Ios_Openmode"
Noelle:  Disable "_ZNSt14basic_ifstreamIcSt11char_traitsIcEEC1EPKcSt13_Ios_Openmode" as cold function
Noelle:  Function "_ZNSolsEPFRSoS_E"
Noelle:  Disable "_ZNSolsEPFRSoS_E" as cold function
Noelle:  Function "_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_"
Noelle:  Disable "_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_" as cold function
Noelle:  Function "_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc"
Noelle:  Disable "_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc" as cold function
Noelle:  Function "_ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_"
Noelle:  Disable "_ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_" as cold function
Noelle:  Function "_ZNSt14basic_ifstreamIcSt11char_traitsIcEED2Ev"
Noelle:  Disable "_ZNSt14basic_ifstreamIcSt11char_traitsIcEED2Ev" as cold function
Noelle:  Function "_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc"
Noelle:  Disable "_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc" as cold function
Noelle:  Function "_ZNSt9basic_iosIcSt11char_traitsIcEE8setstateESt12_Ios_Iostate"
Noelle:  Disable "_ZNSt9basic_iosIcSt11char_traitsIcEE8setstateESt12_Ios_Iostate" as cold function
Noelle:  Function "_ZStorSt13_Ios_OpenmodeS_"
Noelle:  Disable "_ZStorSt13_Ios_OpenmodeS_" as cold function
Noelle:  Function "_ZNSt14basic_ifstreamIcSt11char_traitsIcEE4openEPKcSt13_Ios_Openmode"
Noelle:  Disable "_ZNSt14basic_ifstreamIcSt11char_traitsIcEE4openEPKcSt13_Ios_Openmode" as cold function
Noelle:  Function "atoi"
Noelle:  Disable "atoi" as cold function
Noelle:  Function "_ZNSiC2Ev"
Noelle:  Disable "_ZNSiC2Ev" as cold function
Noelle:  Function "_ZNSt9basic_iosIcSt11char_traitsIcEEC2Ev"
Noelle:  Disable "_ZNSt9basic_iosIcSt11char_traitsIcEEC2Ev" as cold function
Noelle:  Function "_ZStanSt12_Ios_IostateS_"
Noelle:  Disable "_ZStanSt12_Ios_IostateS_" as cold function
Planner:    There are 34 loops in the program we are going to consider
Planner:  Filter out loops not worth considering
Planner:    Loop 6 has 9.425000e+01 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 5 has 9.425000e+01 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 4 has 9.425000e+01 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 7 has 9.425000e+01 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 79 has 2.930438e+02 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 80 has 5.000000e+00 number of iterations on average per loop invocation
Planner:      It is too low. The threshold is 12
Planner:    Loop 32 has 4.238870e+01 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 36 has 8.497111e+02 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 37 has 2.709065e+02 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 38 has 7.340981e+01 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 39 has 6.115508e+00 number of iterations on average per loop invocation
Planner:      It is too low. The threshold is 12
Planner:    Loop 41 has 5.441522e+02 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 21 has 4.238870e+01 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 28 has 6.115508e+00 number of iterations on average per loop invocation
Planner:      It is too low. The threshold is 12
Planner:    Loop 30 has 2.675776e+02 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 25 has 8.497111e+02 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 26 has 2.709065e+02 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 27 has 7.340981e+01 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 15 has 3.201421e+02 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:  There are 9 loop nesting trees in the program
Planner:    ID: 8 (1)
Planner:      Function: "_Z8SaveFilePKc"
Planner:      Loop: "  %54 = load i32, i32* @numCells, align 4, !tbaa !1446, !noelle.pdg.inst.id !67"
Planner:      Loop nesting level: 1
Planner:      Hotness = 1.526473e-01 %
Planner:      Average instructions per invocation = 2.832717e+07 %
Planner:      Average iterations per invocation = 1.354270e+05 %
Planner:    
Planner:    ID: 1 (1)
Planner:      Function: "_Z7InitSimPKc"
Planner:      Loop: "  %185 = load i32, i32* @numParticles, align 4, !tbaa !7941, !noelle.pdg.inst.id !82"
Planner:      Loop nesting level: 1
Planner:      Hotness = 2.191821e-01 %
Planner:      Average instructions per invocation = 4.067420e+07 %
Planner:      Average iterations per invocation = 3.058210e+05 %
Planner:    
Planner:    ID: 0 (1)
Planner:      Function: "_Z7InitSimPKc"
Planner:      Loop: "  %157 = icmp slt i64 %indvars.iv, %151, !noelle.pdg.inst.id !8040"
Planner:      Loop nesting level: 1
Planner:      Hotness = 6.699223e-01 %
Planner:      Average instructions per invocation = 1.243193e+08 %
Planner:      Average iterations per invocation = 1.354270e+05 %
Planner:    
Planner:    ID: 78 (1)
Planner:      Function: "_Z16AdvanceParticlesv"
Planner:      Loop: "  %59 = icmp slt i64 %indvars.iv, %55, !noelle.pdg.inst.id !1665"
Planner:      Loop nesting level: 1
Planner:      Hotness = 1.102129e+00 %
Planner:      Average instructions per invocation = 4.090501e+07 %
Planner:      Average iterations per invocation = 1.354282e+05 %
Planner:    
Planner:    ID: 31 (1)
Planner:      Function: "_Z13ComputeForcesv"
Planner:      Loop: "  %199 = icmp slt i64 %indvars.iv52, %24, !noelle.pdg.inst.id !3669"
Planner:      Loop nesting level: 1
Planner:      Hotness = 1.875137e-01 %
Planner:      Average instructions per invocation = 6.959482e+06 %
Planner:      Average iterations per invocation = 1.354290e+05 %
Planner:    
Planner:    ID: 33 (1)
Planner:      Function: "_Z13ComputeForcesv"
Planner:      Loop: "  %240 = sext i32 %239 to i64, !noelle.pdg.inst.id !3716"
Planner:      Loop nesting level: 1
Planner:      Hotness = 6.212268e+01 %
Planner:      Average instructions per invocation = 2.305654e+09 %
Planner:      Average iterations per invocation = 4.680000e+01 %
Planner:    
Planner:      ID: 34 (2)
Planner:        Function: "_Z13ComputeForcesv"
Planner:        Loop: "  %244 = icmp slt i64 %indvars.iv73, %59, !noelle.pdg.inst.id !3725"
Planner:        Loop nesting level: 2
Planner:        Hotness = 6.212266e+01 %
Planner:        Average instructions per invocation = 5.012290e+07 %
Planner:        Average iterations per invocation = 6.499565e+01 %
Planner:      
Planner:        ID: 35 (3)
Planner:          Function: "_Z13ComputeForcesv"
Planner:          Loop: "  %250 = icmp slt i64 %indvars.iv71, %61, !noelle.pdg.inst.id !3735"
Planner:          Loop nesting level: 3
Planner:          Hotness = 6.212162e+01 %
Planner:          Average instructions per invocation = 7.831573e+05 %
Planner:          Average iterations per invocation = 4.700027e+01 %
Planner:        
Planner:          ID: 40 (4)
Planner:            Function: "_Z13ComputeForcesv"
Planner:            Loop: "  %303 = icmp slt i64 %indvars.iv, %292, !noelle.pdg.inst.id !3827"
Planner:            Loop nesting level: 5
Planner:            Hotness = 6.054786e+01 %
Planner:            Average instructions per invocation = 7.348338e+03 %
Planner:            Average iterations per invocation = 1.420742e+01 %
Planner:          
Planner:    ID: 20 (1)
Planner:      Function: "_Z13ComputeForcesv"
Planner:      Loop: "  %26 = icmp slt i64 %indvars.iv58, %24, !noelle.pdg.inst.id !3403"
Planner:      Loop nesting level: 1
Planner:      Hotness = 1.875137e-01 %
Planner:      Average instructions per invocation = 6.959482e+06 %
Planner:      Average iterations per invocation = 1.354290e+05 %
Planner:    
Planner:    ID: 22 (1)
Planner:      Function: "_Z13ComputeForcesv"
Planner:      Loop: "  %66 = icmp slt i64 %indvars.iv90, %63, !noelle.pdg.inst.id !3457"
Planner:      Loop nesting level: 1
Planner:      Hotness = 3.203275e+01 %
Planner:      Average instructions per invocation = 1.188880e+09 %
Planner:      Average iterations per invocation = 4.680000e+01 %
Planner:    
Planner:      ID: 23 (2)
Planner:        Function: "_Z13ComputeForcesv"
Planner:        Loop: "  %69 = icmp slt i64 %indvars.iv88, %59, !noelle.pdg.inst.id !3466"
Planner:        Loop nesting level: 2
Planner:        Hotness = 3.203273e+01 %
Planner:        Average instructions per invocation = 2.584521e+07 %
Planner:        Average iterations per invocation = 6.499565e+01 %
Planner:      
Planner:        ID: 24 (3)
Planner:          Function: "_Z13ComputeForcesv"
Planner:          Loop: "  %75 = icmp slt i64 %indvars.iv86, %61, !noelle.pdg.inst.id !3477"
Planner:          Loop nesting level: 3
Planner:          Hotness = 3.203170e+01 %
Planner:          Average instructions per invocation = 4.038184e+05 %
Planner:          Average iterations per invocation = 4.700027e+01 %
Planner:        
Planner:          ID: 29 (4)
Planner:            Function: "_Z13ComputeForcesv"
Planner:            Loop: "  %129 = icmp slt i64 %indvars.iv54, %117, !noelle.pdg.inst.id !3581"
Planner:            Loop nesting level: 5
Planner:            Hotness = 3.044969e+01 %
Planner:            Average instructions per invocation = 3.695500e+03 %
Planner:            Average iterations per invocation = 1.420742e+01 %
Planner:          
Planner:    ID: 14 (1)
Planner:      Function: "_Z11RebuildGridv"
Planner:      Loop: "  %20 = sext i32 %19 to i64, !noelle.pdg.inst.id !1266"
Planner:      Loop nesting level: 1
Planner:      Hotness = 1.247899e+00 %
Planner:      Average instructions per invocation = 4.631517e+07 %
Planner:      Average iterations per invocation = 1.353690e+05 %
Planner:    
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca float, align 4, !noelle.pdg.inst.id !1405
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %11 = alloca float, align 4, !noelle.pdg.inst.id !1405 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca float, align 4, !noelle.pdg.inst.id !1404
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca float, align 4, !noelle.pdg.inst.id !1404 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !1403
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca float, align 4, !noelle.pdg.inst.id !1403 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !1402
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca float, align 4, !noelle.pdg.inst.id !1402 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca float, align 4, !noelle.pdg.inst.id !1397
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca float, align 4, !noelle.pdg.inst.id !1397 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca %"class.std::basic_ofstream", align 8, !noelle.pdg.inst.id !1396
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca float, align 4, !noelle.pdg.inst.id !1398
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca float, align 4, !noelle.pdg.inst.id !1398 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca float, align 4, !noelle.pdg.inst.id !1399
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %5 = alloca float, align 4, !noelle.pdg.inst.id !1399 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca float, align 4, !noelle.pdg.inst.id !1400
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca float, align 4, !noelle.pdg.inst.id !1400 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca float, align 4, !noelle.pdg.inst.id !1401
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %7 = alloca float, align 4, !noelle.pdg.inst.id !1401 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca float, align 4, !noelle.pdg.inst.id !1405
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %11 = alloca float, align 4, !noelle.pdg.inst.id !1405 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca float, align 4, !noelle.pdg.inst.id !1404
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca float, align 4, !noelle.pdg.inst.id !1404 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !1403
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca float, align 4, !noelle.pdg.inst.id !1403 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !1402
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca float, align 4, !noelle.pdg.inst.id !1402 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca float, align 4, !noelle.pdg.inst.id !1397
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca float, align 4, !noelle.pdg.inst.id !1397 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca %"class.std::basic_ofstream", align 8, !noelle.pdg.inst.id !1396
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca float, align 4, !noelle.pdg.inst.id !1398
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca float, align 4, !noelle.pdg.inst.id !1398 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca float, align 4, !noelle.pdg.inst.id !1399
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %5 = alloca float, align 4, !noelle.pdg.inst.id !1399 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca float, align 4, !noelle.pdg.inst.id !1400
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca float, align 4, !noelle.pdg.inst.id !1400 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca float, align 4, !noelle.pdg.inst.id !1401
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %7 = alloca float, align 4, !noelle.pdg.inst.id !1401 can be cloned
MemoryCloningAnalysis: Exit
Planner: LoopSelector:  Loop 8 saves only 5.106289e-02 when parallelized. Skip it
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca float, align 4, !noelle.pdg.inst.id !7914
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca float, align 4, !noelle.pdg.inst.id !7913
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca float, align 4, !noelle.pdg.inst.id !7912
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca float, align 4, !noelle.pdg.inst.id !7911
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca float, align 4, !noelle.pdg.inst.id !7910
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca float, align 4, !noelle.pdg.inst.id !7909
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca float, align 4, !noelle.pdg.inst.id !7908
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !7907
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !7906
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %"class.std::basic_ifstream", align 8, !noelle.pdg.inst.id !7901
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca %struct.datablockhdr*, align 8, !noelle.pdg.inst.id !7900
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %2 = alloca %struct.datablockhdr*, align 8, !noelle.pdg.inst.id !7900 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca float, align 4, !noelle.pdg.inst.id !7902
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca i32, align 4, !noelle.pdg.inst.id !7903
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !7904
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !7905
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca float, align 4, !noelle.pdg.inst.id !7914
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca float, align 4, !noelle.pdg.inst.id !7913
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca float, align 4, !noelle.pdg.inst.id !7912
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca float, align 4, !noelle.pdg.inst.id !7911
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca float, align 4, !noelle.pdg.inst.id !7910
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca float, align 4, !noelle.pdg.inst.id !7909
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca float, align 4, !noelle.pdg.inst.id !7908
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !7907
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !7906
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %"class.std::basic_ifstream", align 8, !noelle.pdg.inst.id !7901
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca %struct.datablockhdr*, align 8, !noelle.pdg.inst.id !7900
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %2 = alloca %struct.datablockhdr*, align 8, !noelle.pdg.inst.id !7900 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca float, align 4, !noelle.pdg.inst.id !7902
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca i32, align 4, !noelle.pdg.inst.id !7903
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !7904
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !7905
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
Planner: LoopSelector:  Loop 1 saves only 9.887911e-03 when parallelized. Skip it
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca float, align 4, !noelle.pdg.inst.id !7914
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca float, align 4, !noelle.pdg.inst.id !7913
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca float, align 4, !noelle.pdg.inst.id !7912
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca float, align 4, !noelle.pdg.inst.id !7911
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca float, align 4, !noelle.pdg.inst.id !7910
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca float, align 4, !noelle.pdg.inst.id !7909
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca float, align 4, !noelle.pdg.inst.id !7908
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !7907
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !7906
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %"class.std::basic_ifstream", align 8, !noelle.pdg.inst.id !7901
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca %struct.datablockhdr*, align 8, !noelle.pdg.inst.id !7900
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca float, align 4, !noelle.pdg.inst.id !7902
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca i32, align 4, !noelle.pdg.inst.id !7903
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !7904
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !7905
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca float, align 4, !noelle.pdg.inst.id !7914
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca float, align 4, !noelle.pdg.inst.id !7913
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca float, align 4, !noelle.pdg.inst.id !7912
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca float, align 4, !noelle.pdg.inst.id !7911
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca float, align 4, !noelle.pdg.inst.id !7910
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca float, align 4, !noelle.pdg.inst.id !7909
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca float, align 4, !noelle.pdg.inst.id !7908
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !7907
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !7906
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %"class.std::basic_ifstream", align 8, !noelle.pdg.inst.id !7901
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca %struct.datablockhdr*, align 8, !noelle.pdg.inst.id !7900
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca float, align 4, !noelle.pdg.inst.id !7902
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca i32, align 4, !noelle.pdg.inst.id !7903
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !7904
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !7905
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
Planner: LoopSelector:  Loop 0 saves only 6.699223e-01 when parallelized. Skip it
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !1618
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !1617
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !1616
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !1615
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %13 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !1615 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !1614
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !1613
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !1612
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !1612 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !1611
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !1610
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !1610 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !1609
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !1604
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !1604 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !1603
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !1605
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !1606
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !1606 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !1607
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !1608
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !1608 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !1618
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !1617
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !1616
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !1615
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %13 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !1615 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !1614
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !1613
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !1612
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !1612 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !1611
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !1610
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !1610 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !1609
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !1604
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !1604 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !1603
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !1605
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !1606
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !1606 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !1607
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !1608
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !1608 can be cloned
MemoryCloningAnalysis: Exit
Planner: LoopSelector:  Loop 78 saves only 3.505413e-01 when parallelized. Skip it
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3375
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3376
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3375
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3376
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
Planner: LoopSelector:  Loop 31 saves only 1.875137e-01 when parallelized. Skip it
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3391 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3375
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3376
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca float, align 4, !noelle.pdg.inst.id !3382 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca float, align 4, !noelle.pdg.inst.id !3383 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3384 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3385 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3390 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3391 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3375
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3376
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca float, align 4, !noelle.pdg.inst.id !3382 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca float, align 4, !noelle.pdg.inst.id !3383 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3384 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3385 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3390 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3391 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3375
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3376
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca float, align 4, !noelle.pdg.inst.id !3382 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca float, align 4, !noelle.pdg.inst.id !3383 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3384 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3385 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3390 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3391 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3375
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3376
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca float, align 4, !noelle.pdg.inst.id !3382 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca float, align 4, !noelle.pdg.inst.id !3383 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3384 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3385 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3390 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3391 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3375
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3376
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca float, align 4, !noelle.pdg.inst.id !3382 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca float, align 4, !noelle.pdg.inst.id !3383 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3384 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3385 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3390 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3391 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3375
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3376
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca float, align 4, !noelle.pdg.inst.id !3382 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca float, align 4, !noelle.pdg.inst.id !3383 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3384 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3385 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3390 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3391 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3375
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3376
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca float, align 4, !noelle.pdg.inst.id !3382 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca float, align 4, !noelle.pdg.inst.id !3383 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3384 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3385 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3390 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3391 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3375
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3376
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca float, align 4, !noelle.pdg.inst.id !3382 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca float, align 4, !noelle.pdg.inst.id !3383 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3384 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3385 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3390 can be cloned
MemoryCloningAnalysis: Exit
Planner: LoopSelector: Start
Planner: LoopSelector:   Order of loops and their maximum savings
Planner: LoopSelector:    Loop 40
Planner: LoopSelector:      Function: "_Z13ComputeForcesv"
Planner: LoopSelector:      Loop nesting level: 5
Planner: LoopSelector:      "  %303 = icmp slt i64 %indvars.iv, %292, !noelle.pdg.inst.id !3827"
Planner: LoopSelector:      Coverage: 6.054786e+01%
Planner: LoopSelector:      Whole-program savings = 6.708336e+00%
Planner: LoopSelector:      Loop savings = 1.107939e+01%
Planner: LoopSelector:    Loop 34
Planner: LoopSelector:      Function: "_Z13ComputeForcesv"
Planner: LoopSelector:      Loop nesting level: 2
Planner: LoopSelector:      "  %244 = icmp slt i64 %indvars.iv73, %59, !noelle.pdg.inst.id !3725"
Planner: LoopSelector:      Coverage: 6.212266e+01%
Planner: LoopSelector:      Whole-program savings = 5.908374e+00%
Planner: LoopSelector:      Loop savings = 9.510820e+00%
Planner: LoopSelector:    Loop 35
Planner: LoopSelector:      Function: "_Z13ComputeForcesv"
Planner: LoopSelector:      Loop nesting level: 3
Planner: LoopSelector:      "  %250 = icmp slt i64 %indvars.iv71, %61, !noelle.pdg.inst.id !3735"
Planner: LoopSelector:      Coverage: 6.212162e+01%
Planner: LoopSelector:      Whole-program savings = 5.907338e+00%
Planner: LoopSelector:      Loop savings = 9.509311e+00%
Planner: LoopSelector:    Loop 33
Planner: LoopSelector:      Function: "_Z13ComputeForcesv"
Planner: LoopSelector:      Loop nesting level: 1
Planner: LoopSelector:      "  %240 = sext i32 %239 to i64, !noelle.pdg.inst.id !3716"
Planner: LoopSelector:      Coverage: 6.212268e+01%
Planner: LoopSelector:      Whole-program savings = 5.881640e+00%
Planner: LoopSelector:      Loop savings = 9.467783e+00%
Planner: LoopSelector: End
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3375
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3376
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3375
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3376
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
Planner: LoopSelector:  Loop 20 saves only 4.567121e-02 when parallelized. Skip it
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3378 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3375
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3376
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3376 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3378 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3375
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3376
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3376 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3378 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3375
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3376
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3376 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3378 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3375
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3376
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3376 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3378 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3375
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3376
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3376 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3378 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3375
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3376
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3376 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3378 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3375
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3376
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3376 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3378 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3375
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3376
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3376 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
Planner: LoopSelector: Start
Planner: LoopSelector:   Order of loops and their maximum savings
Planner: LoopSelector:    Loop 22
Planner: LoopSelector:      Function: "_Z13ComputeForcesv"
Planner: LoopSelector:      Loop nesting level: 1
Planner: LoopSelector:      "  %66 = icmp slt i64 %indvars.iv90, %63, !noelle.pdg.inst.id !3457"
Planner: LoopSelector:      Coverage: 3.203275e+01%
Planner: LoopSelector:      Whole-program savings = 1.264995e+01%
Planner: LoopSelector:      Loop savings = 3.949068e+01%
Planner: LoopSelector:    Loop 23
Planner: LoopSelector:      Function: "_Z13ComputeForcesv"
Planner: LoopSelector:      Loop nesting level: 2
Planner: LoopSelector:      "  %69 = icmp slt i64 %indvars.iv88, %59, !noelle.pdg.inst.id !3466"
Planner: LoopSelector:      Coverage: 3.203273e+01%
Planner: LoopSelector:      Whole-program savings = 1.264994e+01%
Planner: LoopSelector:      Loop savings = 3.949066e+01%
Planner: LoopSelector:    Loop 24
Planner: LoopSelector:      Function: "_Z13ComputeForcesv"
Planner: LoopSelector:      Loop nesting level: 3
Planner: LoopSelector:      "  %75 = icmp slt i64 %indvars.iv86, %61, !noelle.pdg.inst.id !3477"
Planner: LoopSelector:      Coverage: 3.203170e+01%
Planner: LoopSelector:      Whole-program savings = 1.264890e+01%
Planner: LoopSelector:      Loop savings = 3.948870e+01%
Planner: LoopSelector:    Loop 29
Planner: LoopSelector:      Function: "_Z13ComputeForcesv"
Planner: LoopSelector:      Loop nesting level: 5
Planner: LoopSelector:      "  %129 = icmp slt i64 %indvars.iv54, %117, !noelle.pdg.inst.id !3581"
Planner: LoopSelector:      Coverage: 3.044969e+01%
Planner: LoopSelector:      Whole-program savings = 1.112618e+01%
Planner: LoopSelector:      Loop savings = 3.653956e+01%
Planner: LoopSelector: End
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %struct.datablockhdr*, align 8, !noelle.pdg.inst.id !1237
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %1 = alloca %struct.datablockhdr*, align 8, !noelle.pdg.inst.id !1237 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %struct.datablockhdr*, align 8, !noelle.pdg.inst.id !1237
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %1 = alloca %struct.datablockhdr*, align 8, !noelle.pdg.inst.id !1237 can be cloned
MemoryCloningAnalysis: Exit
Planner: LoopSelector:  Loop 14 saves only 6.035914e-02 when parallelized. Skip it
Planner:   Maximum time saved = 1.935828e+01% (3592368408)
Planner:   Maximum time saved with DOALL only = 0.000000e+00% (0)
Planner: Exit
noelle-rm-function -function-name=SIMONE_CAMPANONI_IS_GOING_TO_REMOVE_THIS_FUNCTION code_with_prototypes.bc -o code_to_parallelize.bc
NOELLE: DeadFunctions: Start
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/RemoveFunction.so -noelle-rm-function -function-name=SIMONE_CAMPANONI_IS_GOING_TO_REMOVE_THIS_FUNCTION code_with_prototypes.bc -o code_to_parallelize.bc
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/RemoveFunction.so -noelle-rm-function -function-name=SIMONE_CAMPANONI_IS_GOING_TO_REMOVE_THIS_FUNCTION code_with_prototypes.bc -o code_to_parallelize.bc
RemoveFunction: Start
RemoveFunction:   Check if function "SIMONE_CAMPANONI_IS_GOING_TO_REMOVE_THIS_FUNCTION" exists
RemoveFunction:     The function exists
RemoveFunction:   Remove the function
RemoveFunction: Exit
NOELLE: DeadFunctions: Exit
noelle-parallelizer-loop code_to_parallelize.bc -o parallelized_unoptimized.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Parallelizer.so -parallelizer code_to_parallelize.bc -o parallelized_unoptimized.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Parallelizer.so -parallelizer code_to_parallelize.bc -o parallelized_unoptimized.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Parallelizer.so -parallelizer code_to_parallelize.bc -o parallelized_unoptimized.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
Parallelizer: Start
Parallelizer:  Analyzing the module code_to_parallelize.bc
Parallelizer:  Fetching the program loops
Noelle: Filter out cold code
Noelle:  Function "main"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, %23, !noelle.pdg.inst.id !184" (9.893907e+01%)
Noelle:  Function "_Z12AdvanceFramev"
Noelle:  Function "_Z13ComputeForcesv"
Noelle:     Loop "  %26 = icmp slt i64 %indvars.iv58, %24, !noelle.pdg.inst.id !3405" (1.875137e-01%)
Noelle:     Loop "  %32 = icmp slt i32 %.05, %30, !noelle.pdg.inst.id !3414" (1.546733e-01%)
Noelle:     Loop "  %66 = icmp slt i64 %indvars.iv90, %63, !noelle.pdg.inst.id !3459" (3.203275e+01%)
Noelle:     Loop "  %69 = icmp slt i64 %indvars.iv88, %59, !noelle.pdg.inst.id !3469" (3.203273e+01%)
Noelle:     Loop "  %75 = icmp slt i64 %indvars.iv86, %61, !noelle.pdg.inst.id !3481" (3.203170e+01%)
Noelle:     Loop "  %85 = icmp eq i64 %indvars.iv83, 2, !noelle.pdg.inst.id !3497" (1.368649e+00%)
Noelle:     Loop "  %89 = icmp eq i64 %indvars.iv80, 2, !noelle.pdg.inst.id !3509" (1.299458e+00%)
Noelle:     Loop "  %96 = icmp eq i64 %indvars.iv77, 2, !noelle.pdg.inst.id !3530" (1.036190e+00%)
Noelle:     Loop "  %119 = icmp slt i32 %.016, %78, !noelle.pdg.inst.id !3573" (3.060445e+01%)
Noelle:     Loop "  %129 = icmp slt i64 %indvars.iv54, %117, !noelle.pdg.inst.id !3586" (3.044969e+01%)
Noelle:     Loop "  %138 = icmp slt i32 %.023, %136, !noelle.pdg.inst.id !3598" (2.911907e+01%)
Noelle:     Loop "  %199 = icmp slt i64 %indvars.iv52, %24, !noelle.pdg.inst.id !3675" (1.875137e-01%)
Noelle:     Loop "  %205 = icmp slt i32 %.027, %203, !noelle.pdg.inst.id !3683" (1.546733e-01%)
Noelle:     Loop "  %240 = sext i32 %239 to i64, !noelle.pdg.inst.id !3722" (6.212268e+01%)
Noelle:     Loop "  %244 = icmp slt i64 %indvars.iv73, %59, !noelle.pdg.inst.id !3732" (6.212266e+01%)
Noelle:     Loop "  %250 = icmp slt i64 %indvars.iv71, %61, !noelle.pdg.inst.id !3743" (6.212162e+01%)
Noelle:     Loop "  %260 = icmp eq i64 %indvars.iv68, 2, !noelle.pdg.inst.id !3757" (1.368649e+00%)
Noelle:     Loop "  %264 = icmp eq i64 %indvars.iv65, 2, !noelle.pdg.inst.id !3767" (1.299458e+00%)
Noelle:     Loop "  %271 = icmp eq i64 %indvars.iv63, 2, !noelle.pdg.inst.id !3786" (1.036190e+00%)
Noelle:     Loop "  %294 = icmp slt i32 %.018, %253, !noelle.pdg.inst.id !3825" (6.069438e+01%)
Noelle:     Loop "  %303 = icmp slt i64 %indvars.iv, %292, !noelle.pdg.inst.id !3836" (6.054786e+01%)
Noelle:     Loop "  %312 = icmp slt i32 %.04, %310, !noelle.pdg.inst.id !3847" (5.921724e+01%)
Noelle:  Function "_ZNK4Vec3miERKS_"
Noelle:  Function "_ZNK4Vec3mlEf"
Noelle:  Function "_ZN4Vec3C2Efff"
Noelle:  Function "_ZNK4Vec311GetLengthSqEv"
Noelle:  Function "_ZN4Vec3pLERKS_"
Noelle:  Function "_ZN4Vec3mIERKS_"
Noelle:  Function "_Z11RebuildGridv"
Noelle:     Loop "  %9 = icmp slt i64 %indvars.iv29, %7, !noelle.pdg.inst.id !1252" (4.743599e-02%)
Noelle:  Disable loop "23" as cold code
Noelle:     Loop "  %20 = sext i32 %19 to i64, !noelle.pdg.inst.id !1268" (1.247899e+00%)
Noelle:     Loop "  %29 = icmp slt i32 %.04, %27, !noelle.pdg.inst.id !1277" (1.167658e+00%)
Noelle:     Loop "  %exitcond.i = icmp eq i32 %.0.i, %100, !noelle.pdg.inst.id !1381" (0.000000e+00%)
Noelle:  Disable loop "26" as cold code
Noelle:  Function "_Z16AdvanceParticlesv"
Noelle:     Loop "  %59 = icmp slt i64 %indvars.iv, %55, !noelle.pdg.inst.id !1667" (1.102129e+00%)
Noelle:     Loop "  %65 = icmp slt i32 %.02, %63, !noelle.pdg.inst.id !1676" (1.069289e+00%)
Noelle:  Function "_ZN4Vec3dVEf"
Noelle:  Function "_Z7InitSimPKc"
Noelle:     Loop "  %157 = icmp slt i64 %indvars.iv, %151, !noelle.pdg.inst.id !8042" (6.699223e-01%)
Noelle:     Loop "  %185 = load i32, i32* @numParticles, align 4, !tbaa !7943, !noelle.pdg.inst.id !84" (2.191821e-01%)
Noelle:     Loop "  %249 = icmp sgt i32 %.0, 16, !noelle.pdg.inst.id !8141" (6.591941e-03%)
Noelle:  Disable loop "31" as cold code
Noelle:     Loop "  %exitcond.i = icmp eq i32 %.0.i, %264, !noelle.pdg.inst.id !8190" (0.000000e+00%)
Noelle:  Disable loop "32" as cold code
Noelle:  Function "_ZN4CellC2Ev"
Noelle:     Loop "  tail call void @_ZN4Vec3C2Ev(%class.Vec3* %4), !noelle.pdg.inst.id !37" (1.375603e-01%)
Noelle:     Loop "  tail call void @_ZN4Vec3C2Ev(%class.Vec3* %10), !noelle.pdg.inst.id !48" (1.375603e-01%)
Noelle:     Loop "  tail call void @_ZN4Vec3C2Ev(%class.Vec3* %16), !noelle.pdg.inst.id !58" (1.375603e-01%)
Noelle:     Loop "  tail call void @_ZN4Vec3C2Ev(%class.Vec3* %22), !noelle.pdg.inst.id !68" (1.375603e-01%)
Noelle:  Function "_ZSt3maxIfERKT_S2_S2_"
Noelle:  Function "_Z8SaveFilePKc"
Noelle:     Loop "  %54 = load i32, i32* @numCells, align 4, !tbaa !1448, !noelle.pdg.inst.id !69" (1.526473e-01%)
Noelle:     Loop "  %63 = icmp slt i32 %.0, %61, !noelle.pdg.inst.id !1462" (4.411807e-02%)
Noelle:  Disable loop "38" as cold code
Noelle:     Loop "  %84 = icmp slt i32 %83, %61, !noelle.pdg.inst.id !1507" (9.685274e-02%)
Noelle:  Disable loop "39" as cold code
Noelle:  Function "_ZN4Vec3mLEf"
Noelle:  Function "_ZN4Vec3C2Ev"
Noelle:  Disable "_ZN4Vec3C2Ev" as cold function
Noelle:  Function "_Z17ProcessCollisionsv"
Noelle:  Disable "_Z17ProcessCollisionsv" as cold function
Noelle:  Function "_Z18ProcessCollisions2v"
Noelle:  Disable "_Z18ProcessCollisions2v" as cold function
Noelle:  Function "_Z10CleanUpSimv"
Noelle:  Disable "_Z10CleanUpSimv" as cold function
Noelle:  Function "_Z13cellpool_initP8cellpooli"
Noelle:  Disable "_Z13cellpool_initP8cellpooli" as cold function
Noelle:  Function "_ZL19cellpool_allocblocki"
Noelle:  Disable "_ZL19cellpool_allocblocki" as cold function
Noelle:  Function "_ZSt4swapIPiENSt9enable_ifIXsr6__and_ISt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS4_ESt18is_move_assignableIS4_EEE5valueEvE4typeERS4_SD_"
Noelle:  Disable "_ZSt4swapIPiENSt9enable_ifIXsr6__and_ISt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS4_ESt18is_move_assignableIS4_EEE5valueEvE4typeERS4_SD_" as cold function
Noelle:  Function "_ZSt4swapIP4CellENSt9enable_ifIXsr6__and_ISt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS5_ESt18is_move_assignableIS5_EEE5valueEvE4typeERS5_SE_"
Noelle:  Disable "_ZSt4swapIP4CellENSt9enable_ifIXsr6__and_ISt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS5_ESt18is_move_assignableIS5_EEE5valueEvE4typeERS5_SE_" as cold function
Noelle:  Function "_GLOBAL__sub_I_serial.cpp"
Noelle:  Disable "_GLOBAL__sub_I_serial.cpp" as cold function
Noelle:  Function "_GLOBAL__sub_I_cellpool.cpp"
Noelle:  Disable "_GLOBAL__sub_I_cellpool.cpp" as cold function
Noelle:  Function "_Z16cellpool_destroyP8cellpool"
Noelle:  Disable "_Z16cellpool_destroyP8cellpool" as cold function
Noelle:  Function "_ZSt4moveIRPiEONSt16remove_referenceIT_E4typeEOS3_"
Noelle:  Disable "_ZSt4moveIRPiEONSt16remove_referenceIT_E4typeEOS3_" as cold function
Noelle:  Function "_ZSt4moveIRP4CellEONSt16remove_referenceIT_E4typeEOS4_"
Noelle:  Disable "_ZSt4moveIRP4CellEONSt16remove_referenceIT_E4typeEOS4_" as cold function
Noelle:  Function "__cxx_global_var_init.1.6"
Noelle:  Disable "__cxx_global_var_init.1.6" as cold function
Noelle:  Function "__cxx_global_var_init.2.7"
Noelle:  Disable "__cxx_global_var_init.2.7" as cold function
Noelle:  Function "__cxx_global_var_init.3.8"
Noelle:  Disable "__cxx_global_var_init.3.8" as cold function
Noelle:  Function "__cxx_global_var_init.1"
Noelle:  Disable "__cxx_global_var_init.1" as cold function
Noelle:  Function "__cxx_global_var_init.2"
Noelle:  Disable "__cxx_global_var_init.2" as cold function
Noelle:  Function "__cxx_global_var_init.3"
Noelle:  Disable "__cxx_global_var_init.3" as cold function
Noelle:  Function "__cxx_global_var_init.5"
Noelle:  Disable "__cxx_global_var_init.5" as cold function
Noelle:  Function "__cxx_global_var_init"
Noelle:  Disable "__cxx_global_var_init" as cold function
Noelle:  Function "__cxx_global_var_init.4"
Noelle:  Disable "__cxx_global_var_init.4" as cold function
Noelle:  Function "_ZStanSt12_Ios_IostateS_"
Noelle:  Disable "_ZStanSt12_Ios_IostateS_" as cold function
Noelle:  Function "_ZStorSt13_Ios_OpenmodeS_"
Noelle:  Disable "_ZStorSt13_Ios_OpenmodeS_" as cold function
Noelle:  Function "_ZNSt9basic_iosIcSt11char_traitsIcEEC2Ev"
Noelle:  Disable "_ZNSt9basic_iosIcSt11char_traitsIcEEC2Ev" as cold function
Noelle:  Function "_ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_"
Noelle:  Disable "_ZSt5flushIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_" as cold function
Noelle:  Function "_ZNSiC2Ev"
Noelle:  Disable "_ZNSiC2Ev" as cold function
Noelle:  Function "_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc"
Noelle:  Disable "_ZNKSt9basic_iosIcSt11char_traitsIcEE5widenEc" as cold function
Noelle:  Function "_ZNSt9basic_iosIcSt11char_traitsIcEE8setstateESt12_Ios_Iostate"
Noelle:  Disable "_ZNSt9basic_iosIcSt11char_traitsIcEE8setstateESt12_Ios_Iostate" as cold function
Noelle:  Function "_ZNSt14basic_ofstreamIcSt11char_traitsIcEED2Ev"
Noelle:  Disable "_ZNSt14basic_ofstreamIcSt11char_traitsIcEED2Ev" as cold function
Noelle:  Function "_ZNSt14basic_ifstreamIcSt11char_traitsIcEE4openEPKcSt13_Ios_Openmode"
Noelle:  Disable "_ZNSt14basic_ifstreamIcSt11char_traitsIcEE4openEPKcSt13_Ios_Openmode" as cold function
Noelle:  Function "_Z16cellpool_getcellP8cellpool"
Noelle:  Disable "_Z16cellpool_getcellP8cellpool" as cold function
Noelle:  Function "atoi"
Noelle:  Disable "atoi" as cold function
Noelle:  Function "_Z16GetNeighborCellsiiiPi"
Noelle:  Disable "_Z16GetNeighborCellsiiiPi" as cold function
Noelle:  Function "_ZNSoC2Ev"
Noelle:  Disable "_ZNSoC2Ev" as cold function
Noelle:  Function "_ZNSoD2Ev"
Noelle:  Disable "_ZNSoD2Ev" as cold function
Noelle:  Function "_ZNSt14basic_ofstreamIcSt11char_traitsIcEED1Ev"
Noelle:  Disable "_ZNSt14basic_ofstreamIcSt11char_traitsIcEED1Ev" as cold function
Noelle:  Function "_ZNKSt9basic_iosIcSt11char_traitsIcEEcvbEv"
Noelle:  Disable "_ZNKSt9basic_iosIcSt11char_traitsIcEEcvbEv" as cold function
Noelle:  Function "_ZNSt14basic_ofstreamIcSt11char_traitsIcEEC1EPKcSt13_Ios_Openmode"
Noelle:  Disable "_ZNSt14basic_ofstreamIcSt11char_traitsIcEEC1EPKcSt13_Ios_Openmode" as cold function
Noelle:  Function "_ZNSt11char_traitsIcE6lengthEPKc"
Noelle:  Disable "_ZNSt11char_traitsIcE6lengthEPKc" as cold function
Noelle:  Function "_ZNKSt5ctypeIcE5widenEc"
Noelle:  Disable "_ZNKSt5ctypeIcE5widenEc" as cold function
Noelle:  Function "_ZSt13__check_facetISt5ctypeIcEERKT_PS3_"
Noelle:  Disable "_ZSt13__check_facetISt5ctypeIcEERKT_PS3_" as cold function
Noelle:  Function "_ZNKSt9basic_iosIcSt11char_traitsIcEE7rdstateEv"
Noelle:  Disable "_ZNKSt9basic_iosIcSt11char_traitsIcEE7rdstateEv" as cold function
Noelle:  Function "_ZNKSt9basic_iosIcSt11char_traitsIcEE4failEv"
Noelle:  Disable "_ZNKSt9basic_iosIcSt11char_traitsIcEE4failEv" as cold function
Noelle:  Function "_ZNSolsEPFRSoS_E"
Noelle:  Disable "_ZNSolsEPFRSoS_E" as cold function
Noelle:  Function "_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_"
Noelle:  Disable "_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_" as cold function
Noelle:  Function "_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc"
Noelle:  Disable "_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc" as cold function
Noelle:  Function "_ZNSt15basic_streambufIcSt11char_traitsIcEED2Ev"
Noelle:  Disable "_ZNSt15basic_streambufIcSt11char_traitsIcEED2Ev" as cold function
Noelle:  Function "_ZNSiD2Ev"
Noelle:  Disable "_ZNSiD2Ev" as cold function
Noelle:  Function "_ZNSt13basic_filebufIcSt11char_traitsIcEED2Ev"
Noelle:  Disable "_ZNSt13basic_filebufIcSt11char_traitsIcEED2Ev" as cold function
Noelle:  Function "_ZNSt9basic_iosIcSt11char_traitsIcEED2Ev"
Noelle:  Disable "_ZNSt9basic_iosIcSt11char_traitsIcEED2Ev" as cold function
Noelle:  Function "_ZNSt14basic_ifstreamIcSt11char_traitsIcEED2Ev"
Noelle:  Disable "_ZNSt14basic_ifstreamIcSt11char_traitsIcEED2Ev" as cold function
Noelle:  Function "_ZNSt14basic_ifstreamIcSt11char_traitsIcEED1Ev"
Noelle:  Disable "_ZNSt14basic_ifstreamIcSt11char_traitsIcEED1Ev" as cold function
Noelle:  Function "_ZStorSt12_Ios_IostateS_"
Noelle:  Disable "_ZStorSt12_Ios_IostateS_" as cold function
Noelle:  Function "_Z19cellpool_returncellP8cellpoolP4Cell"
Noelle:  Disable "_Z19cellpool_returncellP8cellpoolP4Cell" as cold function
Noelle:  Function "_ZNSt14basic_ofstreamIcSt11char_traitsIcEE4openEPKcSt13_Ios_Openmode"
Noelle:  Disable "_ZNSt14basic_ofstreamIcSt11char_traitsIcEE4openEPKcSt13_Ios_Openmode" as cold function
Noelle:  Function "_ZNKSt9basic_iosIcSt11char_traitsIcEEntEv"
Noelle:  Disable "_ZNKSt9basic_iosIcSt11char_traitsIcEEntEv" as cold function
Noelle:  Function "_ZNSt14basic_ifstreamIcSt11char_traitsIcEEC1EPKcSt13_Ios_Openmode"
Noelle:  Disable "_ZNSt14basic_ifstreamIcSt11char_traitsIcEEC1EPKcSt13_Ios_Openmode" as cold function
Parallelizer:    There are 34 loops in the program we are going to consider
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3397
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3396
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3378 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3397
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3396
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3378 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3397
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3396
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3378 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3397
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3396
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3378 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3397
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3396
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3378 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3397
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3396
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3378 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3397
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3396
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3378 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3397
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3396
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3378 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3397
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3396
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3394 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3393 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3382 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca float, align 4, !noelle.pdg.inst.id !3384 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca float, align 4, !noelle.pdg.inst.id !3385 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3387 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3388 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3397
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3396
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3394 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3393 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3382 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca float, align 4, !noelle.pdg.inst.id !3384 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca float, align 4, !noelle.pdg.inst.id !3385 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3387 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3388 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3397
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3396
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3394 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3393 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3382 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca float, align 4, !noelle.pdg.inst.id !3384 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca float, align 4, !noelle.pdg.inst.id !3385 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3387 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3388 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3397
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3396
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3394 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3393 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3382 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca float, align 4, !noelle.pdg.inst.id !3384 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca float, align 4, !noelle.pdg.inst.id !3385 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3387 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3388 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3397
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3396
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3394 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3393 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3382 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca float, align 4, !noelle.pdg.inst.id !3384 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca float, align 4, !noelle.pdg.inst.id !3385 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3387 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3388 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3397
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3396
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3394 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3393 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3382 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca float, align 4, !noelle.pdg.inst.id !3384 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca float, align 4, !noelle.pdg.inst.id !3385 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3387 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3388 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3397
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3396
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3394 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3393 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3382 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca float, align 4, !noelle.pdg.inst.id !3384 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca float, align 4, !noelle.pdg.inst.id !3385 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3387 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3388 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3397
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3396
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3394
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %18 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3394 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3393
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %17 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3393 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3382
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3382 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3380
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3379
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3377
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3378
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3383
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca float, align 4, !noelle.pdg.inst.id !3384
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca float, align 4, !noelle.pdg.inst.id !3384 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca float, align 4, !noelle.pdg.inst.id !3385
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca float, align 4, !noelle.pdg.inst.id !3385 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3386 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3387
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %11 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3387 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3388
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %12 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3388 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3390
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3391
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %16 = alloca %class.Vec3, align 4, !noelle.pdg.inst.id !3392 can be cloned
MemoryCloningAnalysis: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "_Z13ComputeForcesv"
Parallelizer: parallelizerLoop:   Loop 40 = "  %303 = icmp slt i64 %indvars.iv, %292, !noelle.pdg.inst.id !3836"
Parallelizer: parallelizerLoop:   Nesting level = 5
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3379
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3383
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3390
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3391
Parallelizer: parallelizerLoop:   Environment:   Live-in 5 =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
Parallelizer: parallelizerLoop:   Environment:   Live-in 6 =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3396
Parallelizer: parallelizerLoop:   Environment:   Live-in 7 =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3397
Parallelizer: parallelizerLoop:   Environment:   Live-in 8 =   %195 = load %struct.Cell*, %struct.Cell** @cells, align 8, !noelle.pdg.inst.id !760
Parallelizer: parallelizerLoop:   Environment:   Live-in 9 =   %196 = load i32*, i32** @cnumPars, align 8, !noelle.pdg.inst.id !762
Parallelizer: parallelizerLoop:   Environment:   Live-in 10 =   %220 = bitcast %class.Vec3* %6 to i8*, !noelle.pdg.inst.id !3701
Parallelizer: parallelizerLoop:   Environment:   Live-in 11 =   %221 = bitcast { <2 x float>, float }* %7 to i8*, !noelle.pdg.inst.id !3702
Parallelizer: parallelizerLoop:   Environment:   Live-in 12 =   %222 = bitcast float* %8 to i8*, !noelle.pdg.inst.id !3703
Parallelizer: parallelizerLoop:   Environment:   Live-in 13 =   %223 = bitcast float* %9 to i8*, !noelle.pdg.inst.id !3704
Parallelizer: parallelizerLoop:   Environment:   Live-in 14 =   %224 = bitcast %class.Vec3* %10 to i8*, !noelle.pdg.inst.id !3705
Parallelizer: parallelizerLoop:   Environment:   Live-in 15 =   %225 = bitcast %class.Vec3* %11 to i8*, !noelle.pdg.inst.id !3706
Parallelizer: parallelizerLoop:   Environment:   Live-in 16 =   %226 = bitcast %class.Vec3* %12 to i8*, !noelle.pdg.inst.id !3707
Parallelizer: parallelizerLoop:   Environment:   Live-in 17 =   %227 = bitcast { <2 x float>, float }* %13 to i8*, !noelle.pdg.inst.id !3708
Parallelizer: parallelizerLoop:   Environment:   Live-in 18 =   %228 = bitcast { <2 x float>, float }* %14 to i8*, !noelle.pdg.inst.id !3709
Parallelizer: parallelizerLoop:   Environment:   Live-in 19 =   %229 = bitcast { <2 x float>, float }* %15 to i8*, !noelle.pdg.inst.id !3710
Parallelizer: parallelizerLoop:   Environment:   Live-in 20 =   %230 = bitcast %class.Vec3* %16 to i8*, !noelle.pdg.inst.id !3711
Parallelizer: parallelizerLoop:   Environment:   Live-in 21 =   %231 = bitcast %class.Vec3* %17 to i8*, !noelle.pdg.inst.id !3712
Parallelizer: parallelizerLoop:   Environment:   Live-in 22 =   %232 = bitcast %class.Vec3* %18 to i8*, !noelle.pdg.inst.id !3713
Parallelizer: parallelizerLoop:   Environment:   Live-in 23 =   %233 = bitcast { <2 x float>, float }* %19 to i8*, !noelle.pdg.inst.id !3714
Parallelizer: parallelizerLoop:   Environment:   Live-in 24 =   %234 = bitcast { <2 x float>, float }* %20 to i8*, !noelle.pdg.inst.id !3715
Parallelizer: parallelizerLoop:   Environment:   Live-in 25 =   %235 = bitcast { <2 x float>, float }* %21 to i8*, !noelle.pdg.inst.id !3716
Parallelizer: parallelizerLoop:   Environment:   Live-in 26 =   %292 = sext i32 %.03.i.lcssa to i64, !noelle.pdg.inst.id !3821
Parallelizer: parallelizerLoop:   Environment:   Live-in 27 =   %298 = getelementptr inbounds %struct.Cell, %struct.Cell* %.021, i64 0, i32 0, i64 %297, !noelle.pdg.inst.id !3830
Parallelizer: parallelizerLoop:   Environment:   Live-in 28 =   %299 = getelementptr inbounds %struct.Cell, %struct.Cell* %.021, i64 0, i32 4, i64 %297, !noelle.pdg.inst.id !3831
Parallelizer: parallelizerLoop:   Environment:   Live-in 29 =   %300 = getelementptr inbounds %struct.Cell, %struct.Cell* %.021, i64 0, i32 2, i64 %297, !noelle.pdg.inst.id !3832
Parallelizer: parallelizerLoop:   Environment:   Live-in 30 =   %301 = getelementptr inbounds %struct.Cell, %struct.Cell* %.021, i64 0, i32 3, i64 %297, !noelle.pdg.inst.id !3833
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "_Z13ComputeForcesv"
Parallelizer: parallelizerLoop:   Loop 34 = "  %244 = icmp slt i64 %indvars.iv73, %59, !noelle.pdg.inst.id !3732"
Parallelizer: parallelizerLoop:   Nesting level = 2
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3379
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3383
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3390
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3391
Parallelizer: parallelizerLoop:   Environment:   Live-in 5 =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
Parallelizer: parallelizerLoop:   Environment:   Live-in 6 =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3396
Parallelizer: parallelizerLoop:   Environment:   Live-in 7 =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3397
Parallelizer: parallelizerLoop:   Environment:   Live-in 8 =   %47 = getelementptr inbounds [27 x i32], [27 x i32]* %3, i64 0, i64 0, !noelle.pdg.inst.id !3442
Parallelizer: parallelizerLoop:   Environment:   Live-in 9 =   %59 = sext i32 %58 to i64, !noelle.pdg.inst.id !3453
Parallelizer: parallelizerLoop:   Environment:   Live-in 10 =   %60 = load i32, i32* @nx, align 4, !tbaa !3398, !noelle.pdg.inst.id !688
Parallelizer: parallelizerLoop:   Environment:   Live-in 11 =   %61 = sext i32 %60 to i64, !noelle.pdg.inst.id !3454
Parallelizer: parallelizerLoop:   Environment:   Live-in 12 =   %195 = load %struct.Cell*, %struct.Cell** @cells, align 8, !noelle.pdg.inst.id !760
Parallelizer: parallelizerLoop:   Environment:   Live-in 13 =   %196 = load i32*, i32** @cnumPars, align 8, !noelle.pdg.inst.id !762
Parallelizer: parallelizerLoop:   Environment:   Live-in 14 =   %220 = bitcast %class.Vec3* %6 to i8*, !noelle.pdg.inst.id !3701
Parallelizer: parallelizerLoop:   Environment:   Live-in 15 =   %221 = bitcast { <2 x float>, float }* %7 to i8*, !noelle.pdg.inst.id !3702
Parallelizer: parallelizerLoop:   Environment:   Live-in 16 =   %222 = bitcast float* %8 to i8*, !noelle.pdg.inst.id !3703
Parallelizer: parallelizerLoop:   Environment:   Live-in 17 =   %223 = bitcast float* %9 to i8*, !noelle.pdg.inst.id !3704
Parallelizer: parallelizerLoop:   Environment:   Live-in 18 =   %224 = bitcast %class.Vec3* %10 to i8*, !noelle.pdg.inst.id !3705
Parallelizer: parallelizerLoop:   Environment:   Live-in 19 =   %225 = bitcast %class.Vec3* %11 to i8*, !noelle.pdg.inst.id !3706
Parallelizer: parallelizerLoop:   Environment:   Live-in 20 =   %226 = bitcast %class.Vec3* %12 to i8*, !noelle.pdg.inst.id !3707
Parallelizer: parallelizerLoop:   Environment:   Live-in 21 =   %227 = bitcast { <2 x float>, float }* %13 to i8*, !noelle.pdg.inst.id !3708
Parallelizer: parallelizerLoop:   Environment:   Live-in 22 =   %228 = bitcast { <2 x float>, float }* %14 to i8*, !noelle.pdg.inst.id !3709
Parallelizer: parallelizerLoop:   Environment:   Live-in 23 =   %229 = bitcast { <2 x float>, float }* %15 to i8*, !noelle.pdg.inst.id !3710
Parallelizer: parallelizerLoop:   Environment:   Live-in 24 =   %230 = bitcast %class.Vec3* %16 to i8*, !noelle.pdg.inst.id !3711
Parallelizer: parallelizerLoop:   Environment:   Live-in 25 =   %231 = bitcast %class.Vec3* %17 to i8*, !noelle.pdg.inst.id !3712
Parallelizer: parallelizerLoop:   Environment:   Live-in 26 =   %232 = bitcast %class.Vec3* %18 to i8*, !noelle.pdg.inst.id !3713
Parallelizer: parallelizerLoop:   Environment:   Live-in 27 =   %233 = bitcast { <2 x float>, float }* %19 to i8*, !noelle.pdg.inst.id !3714
Parallelizer: parallelizerLoop:   Environment:   Live-in 28 =   %234 = bitcast { <2 x float>, float }* %20 to i8*, !noelle.pdg.inst.id !3715
Parallelizer: parallelizerLoop:   Environment:   Live-in 29 =   %235 = bitcast { <2 x float>, float }* %21 to i8*, !noelle.pdg.inst.id !3716
Parallelizer: parallelizerLoop:   Environment:   Live-in 30 =   %237 = sext i32 %236 to i64, !noelle.pdg.inst.id !3717
Parallelizer: parallelizerLoop:   Environment:   Live-in 31 =   %indvars.iv75 = phi i64 [ %indvars.iv.next76, %367 ], [ 0, %219 ], !noelle.pdg.inst.id !3719
Parallelizer: parallelizerLoop:   Environment:   Live-in 32 =   %.3 = phi i32 [ %.4.lcssa, %367 ], [ 0, %219 ], !noelle.pdg.inst.id !3721
Parallelizer: parallelizerLoop:   Environment:   Live-in 33 =   %243 = mul nsw i32 %58, %242, !noelle.pdg.inst.id !3728
Parallelizer: parallelizerLoop:   Environment:   Live-out 34 =   %.4 = phi i32 [ %.3, %.preheader37.preheader ], [ %366, %365 ], !noelle.pdg.inst.id !3731
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "_Z13ComputeForcesv"
Parallelizer: parallelizerLoop:   Loop 35 = "  %250 = icmp slt i64 %indvars.iv71, %61, !noelle.pdg.inst.id !3743"
Parallelizer: parallelizerLoop:   Nesting level = 3
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3379
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3383
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3390
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3391
Parallelizer: parallelizerLoop:   Environment:   Live-in 5 =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
Parallelizer: parallelizerLoop:   Environment:   Live-in 6 =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3396
Parallelizer: parallelizerLoop:   Environment:   Live-in 7 =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3397
Parallelizer: parallelizerLoop:   Environment:   Live-in 8 =   %47 = getelementptr inbounds [27 x i32], [27 x i32]* %3, i64 0, i64 0, !noelle.pdg.inst.id !3442
Parallelizer: parallelizerLoop:   Environment:   Live-in 9 =   %59 = sext i32 %58 to i64, !noelle.pdg.inst.id !3453
Parallelizer: parallelizerLoop:   Environment:   Live-in 10 =   %61 = sext i32 %60 to i64, !noelle.pdg.inst.id !3454
Parallelizer: parallelizerLoop:   Environment:   Live-in 11 =   %195 = load %struct.Cell*, %struct.Cell** @cells, align 8, !noelle.pdg.inst.id !760
Parallelizer: parallelizerLoop:   Environment:   Live-in 12 =   %196 = load i32*, i32** @cnumPars, align 8, !noelle.pdg.inst.id !762
Parallelizer: parallelizerLoop:   Environment:   Live-in 13 =   %220 = bitcast %class.Vec3* %6 to i8*, !noelle.pdg.inst.id !3701
Parallelizer: parallelizerLoop:   Environment:   Live-in 14 =   %221 = bitcast { <2 x float>, float }* %7 to i8*, !noelle.pdg.inst.id !3702
Parallelizer: parallelizerLoop:   Environment:   Live-in 15 =   %222 = bitcast float* %8 to i8*, !noelle.pdg.inst.id !3703
Parallelizer: parallelizerLoop:   Environment:   Live-in 16 =   %223 = bitcast float* %9 to i8*, !noelle.pdg.inst.id !3704
Parallelizer: parallelizerLoop:   Environment:   Live-in 17 =   %224 = bitcast %class.Vec3* %10 to i8*, !noelle.pdg.inst.id !3705
Parallelizer: parallelizerLoop:   Environment:   Live-in 18 =   %225 = bitcast %class.Vec3* %11 to i8*, !noelle.pdg.inst.id !3706
Parallelizer: parallelizerLoop:   Environment:   Live-in 19 =   %226 = bitcast %class.Vec3* %12 to i8*, !noelle.pdg.inst.id !3707
Parallelizer: parallelizerLoop:   Environment:   Live-in 20 =   %227 = bitcast { <2 x float>, float }* %13 to i8*, !noelle.pdg.inst.id !3708
Parallelizer: parallelizerLoop:   Environment:   Live-in 21 =   %228 = bitcast { <2 x float>, float }* %14 to i8*, !noelle.pdg.inst.id !3709
Parallelizer: parallelizerLoop:   Environment:   Live-in 22 =   %229 = bitcast { <2 x float>, float }* %15 to i8*, !noelle.pdg.inst.id !3710
Parallelizer: parallelizerLoop:   Environment:   Live-in 23 =   %230 = bitcast %class.Vec3* %16 to i8*, !noelle.pdg.inst.id !3711
Parallelizer: parallelizerLoop:   Environment:   Live-in 24 =   %231 = bitcast %class.Vec3* %17 to i8*, !noelle.pdg.inst.id !3712
Parallelizer: parallelizerLoop:   Environment:   Live-in 25 =   %232 = bitcast %class.Vec3* %18 to i8*, !noelle.pdg.inst.id !3713
Parallelizer: parallelizerLoop:   Environment:   Live-in 26 =   %233 = bitcast { <2 x float>, float }* %19 to i8*, !noelle.pdg.inst.id !3714
Parallelizer: parallelizerLoop:   Environment:   Live-in 27 =   %234 = bitcast { <2 x float>, float }* %20 to i8*, !noelle.pdg.inst.id !3715
Parallelizer: parallelizerLoop:   Environment:   Live-in 28 =   %235 = bitcast { <2 x float>, float }* %21 to i8*, !noelle.pdg.inst.id !3716
Parallelizer: parallelizerLoop:   Environment:   Live-in 29 =   %237 = sext i32 %236 to i64, !noelle.pdg.inst.id !3717
Parallelizer: parallelizerLoop:   Environment:   Live-in 30 =   %indvars.iv75 = phi i64 [ %indvars.iv.next76, %367 ], [ 0, %219 ], !noelle.pdg.inst.id !3719
Parallelizer: parallelizerLoop:   Environment:   Live-in 31 =   %indvars.iv73 = phi i64 [ 0, %.preheader37.preheader ], [ %indvars.iv.next74, %365 ], !noelle.pdg.inst.id !3730
Parallelizer: parallelizerLoop:   Environment:   Live-in 32 =   %245 = sext i32 %.4 to i64, !noelle.pdg.inst.id !3736
Parallelizer: parallelizerLoop:   Environment:   Live-in 33 =   %248 = mul nsw i32 %247, %60, !noelle.pdg.inst.id !3739
Parallelizer: parallelizerLoop:   Environment:   Live-out 34 =   %indvars.iv50 = phi i64 [ %245, %.preheader ], [ %indvars.iv.next51, %._crit_edge66 ], !noelle.pdg.inst.id !3742
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "_Z13ComputeForcesv"
Parallelizer: parallelizerLoop:   Loop 33 = "  %240 = sext i32 %239 to i64, !noelle.pdg.inst.id !3722"
Parallelizer: parallelizerLoop:   Nesting level = 1
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3379
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %7 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3383
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %13 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3389
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %14 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3390
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %15 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3391
Parallelizer: parallelizerLoop:   Environment:   Live-in 5 =   %19 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3395
Parallelizer: parallelizerLoop:   Environment:   Live-in 6 =   %20 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3396
Parallelizer: parallelizerLoop:   Environment:   Live-in 7 =   %21 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3397
Parallelizer: parallelizerLoop:   Environment:   Live-in 8 =   %47 = getelementptr inbounds [27 x i32], [27 x i32]* %3, i64 0, i64 0, !noelle.pdg.inst.id !3442
Parallelizer: parallelizerLoop:   Environment:   Live-in 9 =   %.pre60 = load i32, i32* @nz, align 4, !tbaa !3398, !noelle.pdg.inst.id !684
Parallelizer: parallelizerLoop:   Environment:   Live-in 10 =   %58 = load i32, i32* @ny, align 4, !tbaa !3398, !noelle.pdg.inst.id !686
Parallelizer: parallelizerLoop:   Environment:   Live-in 11 =   %59 = sext i32 %58 to i64, !noelle.pdg.inst.id !3453
Parallelizer: parallelizerLoop:   Environment:   Live-in 12 =   %60 = load i32, i32* @nx, align 4, !tbaa !3398, !noelle.pdg.inst.id !688
Parallelizer: parallelizerLoop:   Environment:   Live-in 13 =   %61 = sext i32 %60 to i64, !noelle.pdg.inst.id !3454
Parallelizer: parallelizerLoop:   Environment:   Live-in 14 =   %195 = load %struct.Cell*, %struct.Cell** @cells, align 8, !noelle.pdg.inst.id !760
Parallelizer: parallelizerLoop:   Environment:   Live-in 15 =   %196 = load i32*, i32** @cnumPars, align 8, !noelle.pdg.inst.id !762
Parallelizer: parallelizerLoop:   Environment:   Live-in 16 =   %220 = bitcast %class.Vec3* %6 to i8*, !noelle.pdg.inst.id !3701
Parallelizer: parallelizerLoop:   Environment:   Live-in 17 =   %221 = bitcast { <2 x float>, float }* %7 to i8*, !noelle.pdg.inst.id !3702
Parallelizer: parallelizerLoop:   Environment:   Live-in 18 =   %222 = bitcast float* %8 to i8*, !noelle.pdg.inst.id !3703
Parallelizer: parallelizerLoop:   Environment:   Live-in 19 =   %223 = bitcast float* %9 to i8*, !noelle.pdg.inst.id !3704
Parallelizer: parallelizerLoop:   Environment:   Live-in 20 =   %224 = bitcast %class.Vec3* %10 to i8*, !noelle.pdg.inst.id !3705
Parallelizer: parallelizerLoop:   Environment:   Live-in 21 =   %225 = bitcast %class.Vec3* %11 to i8*, !noelle.pdg.inst.id !3706
Parallelizer: parallelizerLoop:   Environment:   Live-in 22 =   %226 = bitcast %class.Vec3* %12 to i8*, !noelle.pdg.inst.id !3707
Parallelizer: parallelizerLoop:   Environment:   Live-in 23 =   %227 = bitcast { <2 x float>, float }* %13 to i8*, !noelle.pdg.inst.id !3708
Parallelizer: parallelizerLoop:   Environment:   Live-in 24 =   %228 = bitcast { <2 x float>, float }* %14 to i8*, !noelle.pdg.inst.id !3709
Parallelizer: parallelizerLoop:   Environment:   Live-in 25 =   %229 = bitcast { <2 x float>, float }* %15 to i8*, !noelle.pdg.inst.id !3710
Parallelizer: parallelizerLoop:   Environment:   Live-in 26 =   %230 = bitcast %class.Vec3* %16 to i8*, !noelle.pdg.inst.id !3711
Parallelizer: parallelizerLoop:   Environment:   Live-in 27 =   %231 = bitcast %class.Vec3* %17 to i8*, !noelle.pdg.inst.id !3712
Parallelizer: parallelizerLoop:   Environment:   Live-in 28 =   %232 = bitcast %class.Vec3* %18 to i8*, !noelle.pdg.inst.id !3713
Parallelizer: parallelizerLoop:   Environment:   Live-in 29 =   %233 = bitcast { <2 x float>, float }* %19 to i8*, !noelle.pdg.inst.id !3714
Parallelizer: parallelizerLoop:   Environment:   Live-in 30 =   %234 = bitcast { <2 x float>, float }* %20 to i8*, !noelle.pdg.inst.id !3715
Parallelizer: parallelizerLoop:   Environment:   Live-in 31 =   %235 = bitcast { <2 x float>, float }* %21 to i8*, !noelle.pdg.inst.id !3716
Parallelizer: parallelizerLoop:   Environment:   Live-in 32 =   %237 = sext i32 %236 to i64, !noelle.pdg.inst.id !3717
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "_Z13ComputeForcesv"
Parallelizer: parallelizerLoop:   Loop 22 = "  %66 = icmp slt i64 %indvars.iv90, %63, !noelle.pdg.inst.id !3459"
Parallelizer: parallelizerLoop:   Nesting level = 1
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3379
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %22 = load %struct.Cell*, %struct.Cell** @cells, align 8, !noelle.pdg.inst.id !547
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %23 = load i32*, i32** @cnumPars, align 8, !noelle.pdg.inst.id !568
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %47 = getelementptr inbounds [27 x i32], [27 x i32]* %3, i64 0, i64 0, !noelle.pdg.inst.id !3442
Parallelizer: parallelizerLoop:   Environment:   Live-in 5 =   %48 = bitcast %class.Vec3* %4 to i8*, !noelle.pdg.inst.id !3443
Parallelizer: parallelizerLoop:   Environment:   Live-in 6 =   %49 = bitcast { <2 x float>, float }* %5 to i8*, !noelle.pdg.inst.id !3444
Parallelizer: parallelizerLoop:   Environment:   Live-in 7 =   %50 = bitcast %class.Vec3* %1 to i8*, !noelle.pdg.inst.id !3445
Parallelizer: parallelizerLoop:   Environment:   Live-in 8 =   %51 = bitcast { <2 x float>, float }* %2 to i8*, !noelle.pdg.inst.id !3446
Parallelizer: parallelizerLoop:   Environment:   Live-in 9 =   %52 = getelementptr inbounds %class.Vec3, %class.Vec3* %1, i64 0, i32 0, !noelle.pdg.inst.id !3447
Parallelizer: parallelizerLoop:   Environment:   Live-in 10 =   %53 = getelementptr inbounds %class.Vec3, %class.Vec3* %1, i64 0, i32 1, !noelle.pdg.inst.id !3448
Parallelizer: parallelizerLoop:   Environment:   Live-in 11 =   %54 = getelementptr inbounds %class.Vec3, %class.Vec3* %1, i64 0, i32 2, !noelle.pdg.inst.id !3449
Parallelizer: parallelizerLoop:   Environment:   Live-in 12 =   %55 = getelementptr inbounds %class.Vec3, %class.Vec3* %4, i64 0, i32 0, !noelle.pdg.inst.id !3450
Parallelizer: parallelizerLoop:   Environment:   Live-in 13 =   %56 = getelementptr inbounds %class.Vec3, %class.Vec3* %4, i64 0, i32 1, !noelle.pdg.inst.id !3451
Parallelizer: parallelizerLoop:   Environment:   Live-in 14 =   %57 = getelementptr inbounds %class.Vec3, %class.Vec3* %4, i64 0, i32 2, !noelle.pdg.inst.id !3452
Parallelizer: parallelizerLoop:   Environment:   Live-in 15 =   %58 = load i32, i32* @ny, align 4, !tbaa !3398, !noelle.pdg.inst.id !686
Parallelizer: parallelizerLoop:   Environment:   Live-in 16 =   %59 = sext i32 %58 to i64, !noelle.pdg.inst.id !3453
Parallelizer: parallelizerLoop:   Environment:   Live-in 17 =   %60 = load i32, i32* @nx, align 4, !tbaa !3398, !noelle.pdg.inst.id !688
Parallelizer: parallelizerLoop:   Environment:   Live-in 18 =   %61 = sext i32 %60 to i64, !noelle.pdg.inst.id !3454
Parallelizer: parallelizerLoop:   Environment:   Live-in 19 =   %62 = load i32*, i32** @cnumPars, align 8, !noelle.pdg.inst.id !690
Parallelizer: parallelizerLoop:   Environment:   Live-in 20 =   %63 = sext i32 %.pre60 to i64, !noelle.pdg.inst.id !3455
Parallelizer: parallelizerLoop:   Environment:   Live-in 21 =   %64 = load float, float* @hSq, align 4, !tbaa !3421, !noelle.pdg.inst.id !692
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "_Z13ComputeForcesv"
Parallelizer: parallelizerLoop:   Loop 23 = "  %69 = icmp slt i64 %indvars.iv88, %59, !noelle.pdg.inst.id !3469"
Parallelizer: parallelizerLoop:   Nesting level = 2
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3379
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %22 = load %struct.Cell*, %struct.Cell** @cells, align 8, !noelle.pdg.inst.id !547
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %23 = load i32*, i32** @cnumPars, align 8, !noelle.pdg.inst.id !568
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %47 = getelementptr inbounds [27 x i32], [27 x i32]* %3, i64 0, i64 0, !noelle.pdg.inst.id !3442
Parallelizer: parallelizerLoop:   Environment:   Live-in 5 =   %48 = bitcast %class.Vec3* %4 to i8*, !noelle.pdg.inst.id !3443
Parallelizer: parallelizerLoop:   Environment:   Live-in 6 =   %49 = bitcast { <2 x float>, float }* %5 to i8*, !noelle.pdg.inst.id !3444
Parallelizer: parallelizerLoop:   Environment:   Live-in 7 =   %50 = bitcast %class.Vec3* %1 to i8*, !noelle.pdg.inst.id !3445
Parallelizer: parallelizerLoop:   Environment:   Live-in 8 =   %51 = bitcast { <2 x float>, float }* %2 to i8*, !noelle.pdg.inst.id !3446
Parallelizer: parallelizerLoop:   Environment:   Live-in 9 =   %52 = getelementptr inbounds %class.Vec3, %class.Vec3* %1, i64 0, i32 0, !noelle.pdg.inst.id !3447
Parallelizer: parallelizerLoop:   Environment:   Live-in 10 =   %53 = getelementptr inbounds %class.Vec3, %class.Vec3* %1, i64 0, i32 1, !noelle.pdg.inst.id !3448
Parallelizer: parallelizerLoop:   Environment:   Live-in 11 =   %54 = getelementptr inbounds %class.Vec3, %class.Vec3* %1, i64 0, i32 2, !noelle.pdg.inst.id !3449
Parallelizer: parallelizerLoop:   Environment:   Live-in 12 =   %55 = getelementptr inbounds %class.Vec3, %class.Vec3* %4, i64 0, i32 0, !noelle.pdg.inst.id !3450
Parallelizer: parallelizerLoop:   Environment:   Live-in 13 =   %56 = getelementptr inbounds %class.Vec3, %class.Vec3* %4, i64 0, i32 1, !noelle.pdg.inst.id !3451
Parallelizer: parallelizerLoop:   Environment:   Live-in 14 =   %57 = getelementptr inbounds %class.Vec3, %class.Vec3* %4, i64 0, i32 2, !noelle.pdg.inst.id !3452
Parallelizer: parallelizerLoop:   Environment:   Live-in 15 =   %59 = sext i32 %58 to i64, !noelle.pdg.inst.id !3453
Parallelizer: parallelizerLoop:   Environment:   Live-in 16 =   %60 = load i32, i32* @nx, align 4, !tbaa !3398, !noelle.pdg.inst.id !688
Parallelizer: parallelizerLoop:   Environment:   Live-in 17 =   %61 = sext i32 %60 to i64, !noelle.pdg.inst.id !3454
Parallelizer: parallelizerLoop:   Environment:   Live-in 18 =   %62 = load i32*, i32** @cnumPars, align 8, !noelle.pdg.inst.id !690
Parallelizer: parallelizerLoop:   Environment:   Live-in 19 =   %63 = sext i32 %.pre60 to i64, !noelle.pdg.inst.id !3455
Parallelizer: parallelizerLoop:   Environment:   Live-in 20 =   %64 = load float, float* @hSq, align 4, !tbaa !3421, !noelle.pdg.inst.id !692
Parallelizer: parallelizerLoop:   Environment:   Live-in 21 =   %indvars.iv90 = phi i64 [ %indvars.iv.next91, %190 ], [ 0, %45 ], !noelle.pdg.inst.id !3457
Parallelizer: parallelizerLoop:   Environment:   Live-in 22 =   %.06 = phi i32 [ %.17.lcssa, %190 ], [ 0, %45 ], !noelle.pdg.inst.id !3458
Parallelizer: parallelizerLoop:   Environment:   Live-in 23 =   %68 = mul nsw i32 %58, %67, !noelle.pdg.inst.id !3465
Parallelizer: parallelizerLoop:   Environment:   Live-out 24 =   %.17 = phi i32 [ %.06, %.preheader40.preheader ], [ %189, %188 ], !noelle.pdg.inst.id !3468
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "_Z13ComputeForcesv"
Parallelizer: parallelizerLoop:   Loop 24 = "  %75 = icmp slt i64 %indvars.iv86, %61, !noelle.pdg.inst.id !3481"
Parallelizer: parallelizerLoop:   Nesting level = 3
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3379
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %22 = load %struct.Cell*, %struct.Cell** @cells, align 8, !noelle.pdg.inst.id !547
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %23 = load i32*, i32** @cnumPars, align 8, !noelle.pdg.inst.id !568
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %47 = getelementptr inbounds [27 x i32], [27 x i32]* %3, i64 0, i64 0, !noelle.pdg.inst.id !3442
Parallelizer: parallelizerLoop:   Environment:   Live-in 5 =   %48 = bitcast %class.Vec3* %4 to i8*, !noelle.pdg.inst.id !3443
Parallelizer: parallelizerLoop:   Environment:   Live-in 6 =   %49 = bitcast { <2 x float>, float }* %5 to i8*, !noelle.pdg.inst.id !3444
Parallelizer: parallelizerLoop:   Environment:   Live-in 7 =   %50 = bitcast %class.Vec3* %1 to i8*, !noelle.pdg.inst.id !3445
Parallelizer: parallelizerLoop:   Environment:   Live-in 8 =   %51 = bitcast { <2 x float>, float }* %2 to i8*, !noelle.pdg.inst.id !3446
Parallelizer: parallelizerLoop:   Environment:   Live-in 9 =   %52 = getelementptr inbounds %class.Vec3, %class.Vec3* %1, i64 0, i32 0, !noelle.pdg.inst.id !3447
Parallelizer: parallelizerLoop:   Environment:   Live-in 10 =   %53 = getelementptr inbounds %class.Vec3, %class.Vec3* %1, i64 0, i32 1, !noelle.pdg.inst.id !3448
Parallelizer: parallelizerLoop:   Environment:   Live-in 11 =   %54 = getelementptr inbounds %class.Vec3, %class.Vec3* %1, i64 0, i32 2, !noelle.pdg.inst.id !3449
Parallelizer: parallelizerLoop:   Environment:   Live-in 12 =   %55 = getelementptr inbounds %class.Vec3, %class.Vec3* %4, i64 0, i32 0, !noelle.pdg.inst.id !3450
Parallelizer: parallelizerLoop:   Environment:   Live-in 13 =   %56 = getelementptr inbounds %class.Vec3, %class.Vec3* %4, i64 0, i32 1, !noelle.pdg.inst.id !3451
Parallelizer: parallelizerLoop:   Environment:   Live-in 14 =   %57 = getelementptr inbounds %class.Vec3, %class.Vec3* %4, i64 0, i32 2, !noelle.pdg.inst.id !3452
Parallelizer: parallelizerLoop:   Environment:   Live-in 15 =   %59 = sext i32 %58 to i64, !noelle.pdg.inst.id !3453
Parallelizer: parallelizerLoop:   Environment:   Live-in 16 =   %61 = sext i32 %60 to i64, !noelle.pdg.inst.id !3454
Parallelizer: parallelizerLoop:   Environment:   Live-in 17 =   %62 = load i32*, i32** @cnumPars, align 8, !noelle.pdg.inst.id !690
Parallelizer: parallelizerLoop:   Environment:   Live-in 18 =   %63 = sext i32 %.pre60 to i64, !noelle.pdg.inst.id !3455
Parallelizer: parallelizerLoop:   Environment:   Live-in 19 =   %64 = load float, float* @hSq, align 4, !tbaa !3421, !noelle.pdg.inst.id !692
Parallelizer: parallelizerLoop:   Environment:   Live-in 20 =   %indvars.iv90 = phi i64 [ %indvars.iv.next91, %190 ], [ 0, %45 ], !noelle.pdg.inst.id !3457
Parallelizer: parallelizerLoop:   Environment:   Live-in 21 =   %indvars.iv88 = phi i64 [ 0, %.preheader40.preheader ], [ %indvars.iv.next89, %188 ], !noelle.pdg.inst.id !3467
Parallelizer: parallelizerLoop:   Environment:   Live-in 22 =   %70 = sext i32 %.17 to i64, !noelle.pdg.inst.id !3474
Parallelizer: parallelizerLoop:   Environment:   Live-in 23 =   %73 = mul nsw i32 %72, %60, !noelle.pdg.inst.id !3477
Parallelizer: parallelizerLoop:   Environment:   Live-out 24 =   %indvars.iv56 = phi i64 [ %70, %.preheader39 ], [ %indvars.iv.next57, %._crit_edge60 ], !noelle.pdg.inst.id !3480
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "_Z13ComputeForcesv"
Parallelizer: parallelizerLoop:   Loop 29 = "  %129 = icmp slt i64 %indvars.iv54, %117, !noelle.pdg.inst.id !3586"
Parallelizer: parallelizerLoop:   Nesting level = 5
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %3 = alloca [27 x i32], align 16, !noelle.pdg.inst.id !3379
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %5 = alloca { <2 x float>, float }, align 8, !noelle.pdg.inst.id !3381
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %22 = load %struct.Cell*, %struct.Cell** @cells, align 8, !noelle.pdg.inst.id !547
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %48 = bitcast %class.Vec3* %4 to i8*, !noelle.pdg.inst.id !3443
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %49 = bitcast { <2 x float>, float }* %5 to i8*, !noelle.pdg.inst.id !3444
Parallelizer: parallelizerLoop:   Environment:   Live-in 5 =   %50 = bitcast %class.Vec3* %1 to i8*, !noelle.pdg.inst.id !3445
Parallelizer: parallelizerLoop:   Environment:   Live-in 6 =   %51 = bitcast { <2 x float>, float }* %2 to i8*, !noelle.pdg.inst.id !3446
Parallelizer: parallelizerLoop:   Environment:   Live-in 7 =   %52 = getelementptr inbounds %class.Vec3, %class.Vec3* %1, i64 0, i32 0, !noelle.pdg.inst.id !3447
Parallelizer: parallelizerLoop:   Environment:   Live-in 8 =   %53 = getelementptr inbounds %class.Vec3, %class.Vec3* %1, i64 0, i32 1, !noelle.pdg.inst.id !3448
Parallelizer: parallelizerLoop:   Environment:   Live-in 9 =   %54 = getelementptr inbounds %class.Vec3, %class.Vec3* %1, i64 0, i32 2, !noelle.pdg.inst.id !3449
Parallelizer: parallelizerLoop:   Environment:   Live-in 10 =   %55 = getelementptr inbounds %class.Vec3, %class.Vec3* %4, i64 0, i32 0, !noelle.pdg.inst.id !3450
Parallelizer: parallelizerLoop:   Environment:   Live-in 11 =   %56 = getelementptr inbounds %class.Vec3, %class.Vec3* %4, i64 0, i32 1, !noelle.pdg.inst.id !3451
Parallelizer: parallelizerLoop:   Environment:   Live-in 12 =   %57 = getelementptr inbounds %class.Vec3, %class.Vec3* %4, i64 0, i32 2, !noelle.pdg.inst.id !3452
Parallelizer: parallelizerLoop:   Environment:   Live-in 13 =   %62 = load i32*, i32** @cnumPars, align 8, !noelle.pdg.inst.id !690
Parallelizer: parallelizerLoop:   Environment:   Live-in 14 =   %64 = load float, float* @hSq, align 4, !tbaa !3421, !noelle.pdg.inst.id !692
Parallelizer: parallelizerLoop:   Environment:   Live-in 15 =   %117 = sext i32 %.03.i1.lcssa to i64, !noelle.pdg.inst.id !3569
Parallelizer: parallelizerLoop:   Environment:   Live-in 16 =   %123 = getelementptr inbounds %struct.Cell, %struct.Cell* %.014, i64 0, i32 0, i64 %122, !noelle.pdg.inst.id !3579
Parallelizer: parallelizerLoop:   Environment:   Live-in 17 =   %124 = getelementptr inbounds %struct.Cell, %struct.Cell* %.014, i64 0, i32 4, i64 %122, !noelle.pdg.inst.id !3580
Parallelizer: parallelizerLoop:   Environment:   Live-in 18 =   %125 = getelementptr inbounds %class.Vec3, %class.Vec3* %123, i64 0, i32 0, !noelle.pdg.inst.id !3581
Parallelizer: parallelizerLoop:   Environment:   Live-in 19 =   %126 = getelementptr inbounds %struct.Cell, %struct.Cell* %.014, i64 0, i32 0, i64 %122, i32 1, !noelle.pdg.inst.id !3582
Parallelizer: parallelizerLoop:   Environment:   Live-in 20 =   %127 = getelementptr inbounds %struct.Cell, %struct.Cell* %.014, i64 0, i32 0, i64 %122, i32 2, !noelle.pdg.inst.id !3583
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: Exit
noelle-meta-clean parallelized_unoptimized.bc parallelized_unoptimized.bc
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CleanMetadata.so -CleanMetadata -clean-loop-metadata=true -clean-prof-metadata=true -clean-pdg-metadata=true parallelized_unoptimized.bc -o parallelized_unoptimized.bc
noelle/core/Clean Loop Metadata
noelle/core/Clean PDG Metadata
noelle/core/Clean profiler metadata
opt --strip-named-metadata parallelized_unoptimized.bc -o parallelized_unoptimized.bc
clang -O3 -c -emit-llvm parallelized_unoptimized.bc -o baseline_parallelized.bc
clang -O3 -c -emit-llvm baseline_parallelized.bc -o baseline_parallelized.bc
cp baseline_parallelized.bc fluidanimate.bc
make[1]: Leaving directory '/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/PARSEC3/benchmarks/fluidanimate'
