make[1]: Entering directory '/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/NAS/benchmarks/ft.B'
./runEnablers.sh ft.B ft.B.bc simlarge "-lm -lstdc++ -lpthread " -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier
/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/NAS/benchmarks/ft.B /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/NAS/benchmarks/ft.B
Cloning https://github.com/scampanoni/virgil.git
Cloning into 'threadpool'...
/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/NAS/benchmarks/ft.B

opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -tbaa -early-cse-memssa -licm -simplifycfg -simplifycfg-sink-common=false -instcombine -tailcallelim -loop-simplify -lcssa -licm -loop-unswitch -globalopt -instcombine -ipsccp -dce -gvn -dse -adce -loop-simplify -lcssa -indvars -loop-deletion -instcombine -indvars -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa --functionattrs --rpo-functionattrs ft.B.bc -o baseline.bc
Running: ./baseline_prof in /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/NAS/benchmarks/ft.B


 NAS Parallel Benchmarks 3.0 structured OpenMP C version - FT Benchmark

 Size                : 512x256x256
 Iterations          :          20
T =     1     Checksum =     5.177643571579e+02     5.077803458597e+02
T =     2     Checksum =     5.154521291263e+02     5.088249431599e+02
T =     3     Checksum =     5.146409228650e+02     5.096208912659e+02
T =     4     Checksum =     5.142378756213e+02     5.101023387619e+02
T =     5     Checksum =     5.139626667737e+02     5.103976610618e+02
T =     6     Checksum =     5.137423460082e+02     5.105948019802e+02
T =     7     Checksum =     5.135547056878e+02     5.107404165783e+02
T =     8     Checksum =     5.133910925467e+02     5.108576573661e+02
T =     9     Checksum =     5.132470705390e+02     5.109577278523e+02
T =    10     Checksum =     5.131197729984e+02     5.110460304483e+02
T =    11     Checksum =     5.130070319283e+02     5.111252433800e+02
T =    12     Checksum =     5.129070537032e+02     5.111968077719e+02
T =    13     Checksum =     5.128182883503e+02     5.112616233064e+02
T =    14     Checksum =     5.127393733383e+02     5.113203605551e+02
T =    15     Checksum =     5.126691062021e+02     5.113735928093e+02
T =    16     Checksum =     5.126064276005e+02     5.114218460548e+02
T =    17     Checksum =     5.125504076570e+02     5.114656139760e+02
T =    18     Checksum =     5.125002331721e+02     5.115053595966e+02
T =    19     Checksum =     5.124551951846e+02     5.115415130407e+02
T =    20     Checksum =     5.124146770029e+02     5.115744692211e+02
Result verification successful
class = B


 FT Benchmark Completed
 Class           =                        B
 Size            =              512x256x256
 Iterations      =                       20
 Threads         =                        1
 Time in seconds =                   130.73
 Mop/s total     =                   704.17
 Operation type  =           floating point
 Verification    =               SUCCESSFUL
 Version         =           3.0 structured
 Compile date    =              20 Jan 2023

 Compile options:
    CC           = gclang
    CLINK        = gclang
    C_LIB        = (none)
    C_INC        = -I../common
    CFLAGS       = -g -O1 -Xclang -disable-llvm-passes
    CLINKFLAGS   = -lm -mcmodel=large
    RAND         = randdp
--------------------------------------------------------------------------------------
DONE
opt -pgo-test-profile-file=/tmp/tmp.5QIwCVA4NR -block-freq -pgo-instr-use baseline.bc -o baseline_pre.bc
opt --strip-debug --strip-debug-declare baseline_pre.bc -o baseline_pre.bc
noelle-deadcode baseline_pre.bc baseline_pre.bc
NOELLE: DeadFunctions: Start
noelle-fixedpoint baseline_pre.bc baseline_pre.bc "noelle-load" -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DeadFunction.so -noelle-dfe
NOELLE: FixedPoint: Start
NOELLE: FixedPoint:   Loader: noelle-load
NOELLE: FixedPoint:   Options: -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DeadFunction.so -noelle-dfe
NOELLE: FixedPoint:   Input: baseline_pre.bc
NOELLE: FixedPoint:   Output: baseline_pre.bc
NOELLE: FixedPoint:   Temporary input: /tmp/tmp.VLUvZoPjKf (.ll version is /tmp/tmp.zaS3aIVjMR)
NOELLE: FixedPoint:   Temporary output: /tmp/tmp.JzoVJGQcL8 (.ll version is /tmp/tmp.gp7sHP9be5)
NOELLE: FixedPoint:   Normalize the code
noelle-norm /tmp/tmp.VLUvZoPjKf -o /tmp/tmp.JzoVJGQcL8
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.VLUvZoPjKf -o /tmp/tmp.JzoVJGQcL8
NOELLE: FixedPoint:   Run until a fixed point is reached
NOELLE: FixedPoint:     Invocation 0
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DeadFunction.so -noelle-dfe /tmp/tmp.VLUvZoPjKf -o /tmp/tmp.JzoVJGQcL8
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DeadFunction.so -noelle-dfe /tmp/tmp.VLUvZoPjKf -o /tmp/tmp.JzoVJGQcL8
DeadFunctionEliminator: Start
DeadFunctionEliminator:   Inline functions that are invoked only by one call instruction and that do not escape into memory
DeadFunctionEliminator:   Get the islands
DeadFunctionEliminator:   Identify the islands reachable from the entry points
DeadFunctionEliminator:     Island
DeadFunctionEliminator:       llvm.lifetime.start.p0i8
DeadFunctionEliminator:       main
DeadFunctionEliminator:       setup
DeadFunctionEliminator:       compute_indexmap
DeadFunctionEliminator:       compute_initial_conditions
DeadFunctionEliminator:       wtime_
DeadFunctionEliminator:       gettimeofday
DeadFunctionEliminator:       puts
DeadFunctionEliminator:       fft_init
DeadFunctionEliminator:       fft
DeadFunctionEliminator:       evolve
DeadFunctionEliminator:       checksum
DeadFunctionEliminator:       verify
DeadFunctionEliminator:       vranlc
DeadFunctionEliminator:       llvm.lifetime.end.p0i8
DeadFunctionEliminator:       llvm.fabs.f64
DeadFunctionEliminator:       printf
DeadFunctionEliminator:       cffts1
DeadFunctionEliminator:       cffts2
DeadFunctionEliminator:       cffts3
DeadFunctionEliminator:       ilog2
DeadFunctionEliminator:       cfftz
DeadFunctionEliminator:       exit
DeadFunctionEliminator:       fftz2
DeadFunctionEliminator:       cos
DeadFunctionEliminator:       sin
DeadFunctionEliminator:       ipow46
DeadFunctionEliminator:       randlc
DeadFunctionEliminator:       c_print_results
DeadFunctionEliminator:       elapsed_time
DeadFunctionEliminator:       timer_clear
DeadFunctionEliminator:       timer_start
DeadFunctionEliminator:       timer_stop
DeadFunctionEliminator:       timer_read
DeadFunctionEliminator:   Identify the functions that can be deleted
DeadFunctionEliminator: Exit
Noelle:  Function "main"
Noelle:     Loop "  %exitcond8 = icmp eq i32 %.02, 7" (1.623138e-08%)
Noelle:     Loop "  %exitcond = icmp eq i32 %.1, 7" (1.623138e-08%)
Noelle:     Loop "  %.b4 = load i1, i1* @niter, align 4" (8.978672e+01%)
Noelle:  Function "fft"
Noelle:  Function "cfftz"
Noelle:     Loop "  %16 = icmp sgt i32 %.0, %1" (7.177684e+01%)
Noelle:     Loop "  %35 = icmp slt i64 %indvars.iv5, %33" (3.140859e+00%)
Noelle:     Loop "  %38 = icmp slt i64 %indvars.iv, %32" (3.073731e+00%)
Noelle:  Function "fftz2"
Noelle:     Loop "  %83 = icmp slt i64 %indvars.iv16, %22" (6.522931e+01%)
Noelle:     Loop "  %96 = icmp slt i64 %indvars.iv14, %21" (6.474078e+01%)
Noelle:     Loop "  %103 = icmp slt i64 %indvars.iv12, %20" (6.337955e+01%)
Noelle:     Loop "  %37 = icmp slt i64 %indvars.iv10, %30" (6.519601e+00%)
Noelle:     Loop "  %49 = icmp slt i64 %indvars.iv8, %29" (6.473893e+00%)
Noelle:     Loop "  %57 = icmp slt i64 %indvars.iv, %28" (6.337835e+00%)
Noelle:  Function "cffts2"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (1.099857e-06%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 2" (3.696594e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 0" (3.696592e+01%)
Noelle:     Loop "  %42 = icmp slt i64 %indvars.iv7, %40" (3.677430e+00%)
Noelle:     Loop "  %45 = icmp slt i64 %indvars.iv, %39" (3.610236e+00%)
Noelle:     Loop "  %69 = icmp slt i64 %indvars.iv11, %67" (3.319760e+00%)
Noelle:     Loop "  %72 = icmp slt i64 %indvars.iv9, %65" (3.252566e+00%)
Noelle:  Function "cffts3"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (1.253450e-06%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 1" (3.696753e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 0" (3.696752e+01%)
Noelle:     Loop "  %42 = icmp slt i64 %indvars.iv7, %40" (3.677430e+00%)
Noelle:     Loop "  %45 = icmp slt i64 %indvars.iv, %39" (3.610236e+00%)
Noelle:     Loop "  %69 = icmp slt i64 %indvars.iv11, %67" (3.319760e+00%)
Noelle:     Loop "  %72 = icmp slt i64 %indvars.iv9, %65" (3.252566e+00%)
Noelle:  Function "cffts1"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv14, 3" (1.099857e-06%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (2.107333e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 1" (2.107332e+01%)
Noelle:     Loop "  %41 = icmp slt i64 %indvars.iv6, %39" (3.044456e+00%)
Noelle:     Loop "  %47 = icmp slt i64 %indvars.iv, %38" (3.041247e+00%)
Noelle:     Loop "  %65 = icmp slt i64 %indvars.iv10, %62" (3.044805e+00%)
Noelle:     Loop "  %72 = icmp slt i64 %indvars.iv8, %70" (3.041247e+00%)
Noelle:  Function "evolve"
Noelle:     Loop "  %10 = icmp slt i64 %indvars.iv5, %8" (3.417952e+00%)
Noelle:     Loop "  %16 = icmp slt i64 %indvars.iv3, %14" (3.417941e+00%)
Noelle:     Loop "  %22 = icmp slt i64 %indvars.iv, %20" (3.415080e+00%)
Noelle:  Function "compute_initial_conditions"
Noelle:     Loop "  %22 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (1.301069e+00%)
Noelle:     Loop "  %36 = icmp slt i64 %indvars.iv6, %34" (3.256000e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 512" (3.252820e-01%)
Noelle:  Function "vranlc"
Noelle:     Loop "  %13 = icmp sgt i64 %indvars.iv, %11" (9.754613e-01%)
Noelle:  Function "compute_indexmap"
Noelle:     Loop "  %6 = icmp slt i64 %indvars.iv10, %4" (2.614626e-01%)
Noelle:     Loop "  %19 = icmp slt i64 %indvars.iv8, %17" (2.614583e-01%)
Noelle:     Loop "  %33 = icmp slt i64 %indvars.iv6, %31" (2.603145e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 1966081" (1.238685e-02%)
Noelle:  Function "checksum"
Noelle:     Loop "  %exitcond = icmp eq i32 %.0, 1025" (2.084060e-04%)
Noelle:  Function "randlc"
Noelle:  Function "fft_init"
Noelle:     Loop "  %7 = icmp sgt i32 %.01, %2" (3.790390e-06%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count" (3.726918e-06%)
Noelle:  Function "ilog2"
Noelle:     Loop "  %4 = icmp slt i32 %.01, %0" (2.683264e-06%)
Noelle:  Function "ipow46"
Noelle:     Loop "  %11 = icmp sgt i32 %.01, 1" (3.592706e-07%)
Noelle:  Function "verify"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 21" (1.121661e-07%)
Noelle:  Function "setup"
Noelle:     Loop "  %exitcond3 = icmp eq i64 %indvars.iv1, 3" (8.721336e-09%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 3" (1.308200e-08%)
Noelle:  Function "elapsed_time"
Noelle:  Function "timer_clear"
Noelle:  Function "wtime_"
Noelle:  Function "c_print_results"
Noelle:  Function "timer_stop"
Noelle:  Function "timer_start"
Noelle:  Function "timer_read"
Noelle:  Function "main"
Noelle:     Loop "  %exitcond8 = icmp eq i32 %.02, 7" (1.623138e-08%)
Noelle:     Loop "  %exitcond = icmp eq i32 %.1, 7" (1.623138e-08%)
Noelle:     Loop "  %.b4 = load i1, i1* @niter, align 4" (8.978672e+01%)
Noelle:  Function "fft"
Noelle:  Function "cfftz"
Noelle:     Loop "  %16 = icmp sgt i32 %.0, %1" (7.177684e+01%)
Noelle:     Loop "  %35 = icmp slt i64 %indvars.iv5, %33" (3.140859e+00%)
Noelle:     Loop "  %38 = icmp slt i64 %indvars.iv, %32" (3.073731e+00%)
Noelle:  Function "fftz2"
Noelle:     Loop "  %83 = icmp slt i64 %indvars.iv16, %22" (6.522931e+01%)
Noelle:     Loop "  %96 = icmp slt i64 %indvars.iv14, %21" (6.474078e+01%)
Noelle:     Loop "  %103 = icmp slt i64 %indvars.iv12, %20" (6.337955e+01%)
Noelle:     Loop "  %37 = icmp slt i64 %indvars.iv10, %30" (6.519601e+00%)
Noelle:     Loop "  %49 = icmp slt i64 %indvars.iv8, %29" (6.473893e+00%)
Noelle:     Loop "  %57 = icmp slt i64 %indvars.iv, %28" (6.337835e+00%)
Noelle:  Function "cffts2"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (1.099857e-06%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 2" (3.696594e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 0" (3.696592e+01%)
Noelle:     Loop "  %42 = icmp slt i64 %indvars.iv7, %40" (3.677430e+00%)
Noelle:     Loop "  %45 = icmp slt i64 %indvars.iv, %39" (3.610236e+00%)
Noelle:     Loop "  %69 = icmp slt i64 %indvars.iv11, %67" (3.319760e+00%)
Noelle:     Loop "  %72 = icmp slt i64 %indvars.iv9, %65" (3.252566e+00%)
Noelle:  Function "cffts3"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (1.253450e-06%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 1" (3.696753e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 0" (3.696752e+01%)
Noelle:     Loop "  %42 = icmp slt i64 %indvars.iv7, %40" (3.677430e+00%)
Noelle:     Loop "  %45 = icmp slt i64 %indvars.iv, %39" (3.610236e+00%)
Noelle:     Loop "  %69 = icmp slt i64 %indvars.iv11, %67" (3.319760e+00%)
Noelle:     Loop "  %72 = icmp slt i64 %indvars.iv9, %65" (3.252566e+00%)
Noelle:  Function "cffts1"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv14, 3" (1.099857e-06%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (2.107333e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 1" (2.107332e+01%)
Noelle:     Loop "  %41 = icmp slt i64 %indvars.iv6, %39" (3.044456e+00%)
Noelle:     Loop "  %47 = icmp slt i64 %indvars.iv, %38" (3.041247e+00%)
Noelle:     Loop "  %65 = icmp slt i64 %indvars.iv10, %62" (3.044805e+00%)
Noelle:     Loop "  %72 = icmp slt i64 %indvars.iv8, %70" (3.041247e+00%)
Noelle:  Function "evolve"
Noelle:     Loop "  %10 = icmp slt i64 %indvars.iv5, %8" (3.417952e+00%)
Noelle:     Loop "  %16 = icmp slt i64 %indvars.iv3, %14" (3.417941e+00%)
Noelle:     Loop "  %22 = icmp slt i64 %indvars.iv, %20" (3.415080e+00%)
Noelle:  Function "compute_initial_conditions"
Noelle:     Loop "  %22 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (1.301069e+00%)
Noelle:     Loop "  %36 = icmp slt i64 %indvars.iv6, %34" (3.256000e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 512" (3.252820e-01%)
Noelle:  Function "vranlc"
Noelle:     Loop "  %13 = icmp sgt i64 %indvars.iv, %11" (9.754613e-01%)
Noelle:  Function "compute_indexmap"
Noelle:     Loop "  %6 = icmp slt i64 %indvars.iv10, %4" (2.614626e-01%)
Noelle:     Loop "  %19 = icmp slt i64 %indvars.iv8, %17" (2.614583e-01%)
Noelle:     Loop "  %33 = icmp slt i64 %indvars.iv6, %31" (2.603145e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 1966081" (1.238685e-02%)
Noelle:  Function "checksum"
Noelle:     Loop "  %exitcond = icmp eq i32 %.0, 1025" (2.084060e-04%)
Noelle:  Function "randlc"
Noelle:  Function "fft_init"
Noelle:     Loop "  %7 = icmp sgt i32 %.01, %2" (3.790390e-06%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count" (3.726918e-06%)
Noelle:  Function "ilog2"
Noelle:     Loop "  %4 = icmp slt i32 %.01, %0" (2.683264e-06%)
Noelle:  Function "ipow46"
Noelle:     Loop "  %11 = icmp sgt i32 %.01, 1" (3.592706e-07%)
Noelle:  Function "verify"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 21" (1.121661e-07%)
Noelle:  Function "setup"
Noelle:     Loop "  %exitcond3 = icmp eq i64 %indvars.iv1, 3" (8.721336e-09%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 3" (1.308200e-08%)
Noelle:  Function "elapsed_time"
Noelle:  Function "timer_clear"
Noelle:  Function "wtime_"
Noelle:  Function "c_print_results"
Noelle:  Function "timer_stop"
Noelle:  Function "timer_start"
Noelle:  Function "timer_read"
NOELLE: FixedPoint: Exit
NOELLE: DeadFunctions: Exit
noelle-simplification baseline_pre.bc -o baseline_pre.bc
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -tbaa -early-cse-memssa -licm -simplifycfg -simplifycfg-sink-common=false -instcombine -tailcallelim -loop-simplify -lcssa -licm -loop-unswitch -globalopt -instcombine -ipsccp -dce -gvn -dse -adce -loop-simplify -lcssa -indvars -loop-deletion -instcombine -indvars -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa --functionattrs --rpo-functionattrs baseline_pre.bc -o baseline_pre.bc
noelle-inline baseline_pre.bc "-noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier"
NOELLE: Inliner: Start
noelle-fixedpoint baseline_pre.bc baseline_pre.bc "noelle-parallel-load" -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier
NOELLE: FixedPoint: Start
NOELLE: FixedPoint:   Loader: noelle-parallel-load
NOELLE: FixedPoint:   Options: -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier
NOELLE: FixedPoint:   Input: baseline_pre.bc
NOELLE: FixedPoint:   Output: baseline_pre.bc
NOELLE: FixedPoint:   Temporary input: /tmp/tmp.1zCLAhAajz (.ll version is /tmp/tmp.Biza76EueF)
NOELLE: FixedPoint:   Temporary output: /tmp/tmp.mEnWC8flov (.ll version is /tmp/tmp.CGbc45C0fS)
NOELLE: FixedPoint:   Normalize the code
noelle-norm /tmp/tmp.1zCLAhAajz -o /tmp/tmp.mEnWC8flov
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.1zCLAhAajz -o /tmp/tmp.mEnWC8flov
NOELLE: FixedPoint:   Run until a fixed point is reached
NOELLE: FixedPoint:     Invocation 0
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.1zCLAhAajz -o /tmp/tmp.mEnWC8flov
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.1zCLAhAajz -o /tmp/tmp.mEnWC8flov
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.1zCLAhAajz -o /tmp/tmp.mEnWC8flov
Inliner: Start
Inliner:   Number of program instructions = 1306
Inliner:   Profiles are available and will be used
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %100, double* %101, align 8, !tbaa !36
DOALL:     	  store double %102, double* %103, align 8, !tbaa !41
DOALL:     	  store double %108, double* %109, align 8, !tbaa !36
DOALL:     	  store double %112, double* %113, align 8, !tbaa !41
DOALL:     External nodes: 9
DOALL:     	  br i1 %90, label %91, label %114, !prof !46
DOALL:     	  %100 = fadd double %93, %97
DOALL:     	  %101 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %8, i64 %87, i64 %indvars.iv12, i32 0
DOALL:     	  %102 = fadd double %95, %99
DOALL:     	  %103 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %8, i64 %87, i64 %indvars.iv12, i32 1
DOALL:     	  %108 = fsub double %105, %107
DOALL:     	  %109 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %8, i64 %88, i64 %indvars.iv12, i32 0
DOALL:     	  %112 = fadd double %110, %111
DOALL:     	  %113 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %8, i64 %88, i64 %indvars.iv12, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %100, double* %101, align 8, !tbaa !36 --->   store double %112, double* %113, align 8, !tbaa !41 via memory
DOALL:         store double %100, double* %101, align 8, !tbaa !36 --->   store double %108, double* %109, align 8, !tbaa !36 via memory
DOALL:         store double %100, double* %101, align 8, !tbaa !36 --->   store double %100, double* %101, align 8, !tbaa !36 via memory
DOALL:         store double %100, double* %101, align 8, !tbaa !36 --->   store double %102, double* %103, align 8, !tbaa !41 via memory
DOALL:         store double %102, double* %103, align 8, !tbaa !41 --->   store double %112, double* %113, align 8, !tbaa !41 via memory
DOALL:         store double %102, double* %103, align 8, !tbaa !41 --->   store double %108, double* %109, align 8, !tbaa !36 via memory
DOALL:         store double %102, double* %103, align 8, !tbaa !41 --->   store double %100, double* %101, align 8, !tbaa !36 via memory
DOALL:         store double %102, double* %103, align 8, !tbaa !41 --->   store double %102, double* %103, align 8, !tbaa !41 via memory
DOALL:         store double %108, double* %109, align 8, !tbaa !36 --->   store double %108, double* %109, align 8, !tbaa !36 via memory
DOALL:         store double %108, double* %109, align 8, !tbaa !36 --->   store double %100, double* %101, align 8, !tbaa !36 via memory
DOALL:         store double %108, double* %109, align 8, !tbaa !36 --->   store double %112, double* %113, align 8, !tbaa !41 via memory
DOALL:         store double %108, double* %109, align 8, !tbaa !36 --->   store double %102, double* %103, align 8, !tbaa !41 via memory
DOALL:         store double %112, double* %113, align 8, !tbaa !41 --->   store double %112, double* %113, align 8, !tbaa !41 via memory
DOALL:         store double %112, double* %113, align 8, !tbaa !41 --->   store double %108, double* %109, align 8, !tbaa !36 via memory
DOALL:         store double %112, double* %113, align 8, !tbaa !41 --->   store double %100, double* %101, align 8, !tbaa !36 via memory
DOALL:         store double %112, double* %113, align 8, !tbaa !41 --->   store double %102, double* %103, align 8, !tbaa !41 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %56, double* %57, align 8, !tbaa !36
DOALL:     	  store double %58, double* %59, align 8, !tbaa !41
DOALL:     	  store double %64, double* %65, align 8, !tbaa !36
DOALL:     	  store double %68, double* %69, align 8, !tbaa !41
DOALL:     External nodes: 9
DOALL:     	  br i1 %45, label %47, label %46, !prof !43
DOALL:     	  %56 = fadd double %49, %53
DOALL:     	  %57 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %8, i64 %42, i64 %indvars.iv, i32 0
DOALL:     	  %58 = fadd double %51, %55
DOALL:     	  %59 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %8, i64 %42, i64 %indvars.iv, i32 1
DOALL:     	  %64 = fsub double %61, %63
DOALL:     	  %65 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %8, i64 %43, i64 %indvars.iv, i32 0
DOALL:     	  %68 = fadd double %66, %67
DOALL:     	  %69 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %8, i64 %43, i64 %indvars.iv, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %56, double* %57, align 8, !tbaa !36 --->   store double %68, double* %69, align 8, !tbaa !41 via memory
DOALL:         store double %56, double* %57, align 8, !tbaa !36 --->   store double %64, double* %65, align 8, !tbaa !36 via memory
DOALL:         store double %56, double* %57, align 8, !tbaa !36 --->   store double %56, double* %57, align 8, !tbaa !36 via memory
DOALL:         store double %56, double* %57, align 8, !tbaa !36 --->   store double %58, double* %59, align 8, !tbaa !41 via memory
DOALL:         store double %58, double* %59, align 8, !tbaa !41 --->   store double %68, double* %69, align 8, !tbaa !41 via memory
DOALL:         store double %58, double* %59, align 8, !tbaa !41 --->   store double %64, double* %65, align 8, !tbaa !36 via memory
DOALL:         store double %58, double* %59, align 8, !tbaa !41 --->   store double %56, double* %57, align 8, !tbaa !36 via memory
DOALL:         store double %58, double* %59, align 8, !tbaa !41 --->   store double %58, double* %59, align 8, !tbaa !41 via memory
DOALL:         store double %64, double* %65, align 8, !tbaa !36 --->   store double %68, double* %69, align 8, !tbaa !41 via memory
DOALL:         store double %64, double* %65, align 8, !tbaa !36 --->   store double %64, double* %65, align 8, !tbaa !36 via memory
DOALL:         store double %64, double* %65, align 8, !tbaa !36 --->   store double %56, double* %57, align 8, !tbaa !36 via memory
DOALL:         store double %64, double* %65, align 8, !tbaa !36 --->   store double %58, double* %59, align 8, !tbaa !41 via memory
DOALL:         store double %68, double* %69, align 8, !tbaa !41 --->   store double %68, double* %69, align 8, !tbaa !41 via memory
DOALL:         store double %68, double* %69, align 8, !tbaa !41 --->   store double %64, double* %65, align 8, !tbaa !36 via memory
DOALL:         store double %68, double* %69, align 8, !tbaa !41 --->   store double %56, double* %57, align 8, !tbaa !36 via memory
DOALL:         store double %68, double* %69, align 8, !tbaa !41 --->   store double %58, double* %59, align 8, !tbaa !41 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %56, double* %57, align 8, !tbaa !36
DOALL:     	  store double %58, double* %59, align 8, !tbaa !41
DOALL:     	  store double %64, double* %65, align 8, !tbaa !36
DOALL:     	  store double %68, double* %69, align 8, !tbaa !41
DOALL:     External nodes: 9
DOALL:     	  br i1 %45, label %47, label %46, !prof !43
DOALL:     	  %56 = fadd double %49, %53
DOALL:     	  %57 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %8, i64 %42, i64 %indvars.iv, i32 0
DOALL:     	  %58 = fadd double %51, %55
DOALL:     	  %59 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %8, i64 %42, i64 %indvars.iv, i32 1
DOALL:     	  %64 = fsub double %61, %63
DOALL:     	  %65 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %8, i64 %43, i64 %indvars.iv, i32 0
DOALL:     	  %68 = fadd double %66, %67
DOALL:     	  %69 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %8, i64 %43, i64 %indvars.iv, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %56, double* %57, align 8, !tbaa !36 --->   store double %68, double* %69, align 8, !tbaa !41 via memory
DOALL:         store double %56, double* %57, align 8, !tbaa !36 --->   store double %64, double* %65, align 8, !tbaa !36 via memory
DOALL:         store double %58, double* %59, align 8, !tbaa !41 --->   store double %68, double* %69, align 8, !tbaa !41 via memory
DOALL:         store double %58, double* %59, align 8, !tbaa !41 --->   store double %64, double* %65, align 8, !tbaa !36 via memory
DOALL:         store double %64, double* %65, align 8, !tbaa !36 --->   store double %56, double* %57, align 8, !tbaa !36 via memory
DOALL:         store double %64, double* %65, align 8, !tbaa !36 --->   store double %58, double* %59, align 8, !tbaa !41 via memory
DOALL:         store double %68, double* %69, align 8, !tbaa !41 --->   store double %56, double* %57, align 8, !tbaa !36 via memory
DOALL:         store double %68, double* %69, align 8, !tbaa !41 --->   store double %58, double* %59, align 8, !tbaa !41 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %100, double* %101, align 8, !tbaa !36
DOALL:     	  store double %102, double* %103, align 8, !tbaa !41
DOALL:     	  store double %108, double* %109, align 8, !tbaa !36
DOALL:     	  store double %112, double* %113, align 8, !tbaa !41
DOALL:     External nodes: 9
DOALL:     	  br i1 %90, label %91, label %114, !prof !46
DOALL:     	  %100 = fadd double %93, %97
DOALL:     	  %101 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %8, i64 %87, i64 %indvars.iv12, i32 0
DOALL:     	  %102 = fadd double %95, %99
DOALL:     	  %103 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %8, i64 %87, i64 %indvars.iv12, i32 1
DOALL:     	  %108 = fsub double %105, %107
DOALL:     	  %109 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %8, i64 %88, i64 %indvars.iv12, i32 0
DOALL:     	  %112 = fadd double %110, %111
DOALL:     	  %113 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %8, i64 %88, i64 %indvars.iv12, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %108, double* %109, align 8, !tbaa !36 --->   store double %102, double* %103, align 8, !tbaa !41 via memory
DOALL:         store double %108, double* %109, align 8, !tbaa !36 --->   store double %100, double* %101, align 8, !tbaa !36 via memory
DOALL:         store double %112, double* %113, align 8, !tbaa !41 --->   store double %102, double* %103, align 8, !tbaa !41 via memory
DOALL:         store double %112, double* %113, align 8, !tbaa !41 --->   store double %100, double* %101, align 8, !tbaa !36 via memory
DOALL:         store double %100, double* %101, align 8, !tbaa !36 --->   store double %112, double* %113, align 8, !tbaa !41 via memory
DOALL:         store double %100, double* %101, align 8, !tbaa !36 --->   store double %108, double* %109, align 8, !tbaa !36 via memory
DOALL:         store double %102, double* %103, align 8, !tbaa !41 --->   store double %112, double* %113, align 8, !tbaa !41 via memory
DOALL:         store double %102, double* %103, align 8, !tbaa !41 --->   store double %108, double* %109, align 8, !tbaa !36 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
Inliner:   Inlining in: cfftz (74 instructions. The inlining will add 136 instructions),   tail call fastcc void @fftz2(i32 %0, i32 %19, i32 %1, i32 %2, i32 %20, i32 %21, %struct.dcomplex* %22, [18 x %struct.dcomplex]* %4, [18 x %struct.dcomplex]* %3)
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca double, align 8 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 2
DOALL:     	  %28 = load i64, i64* %19, align 8, !tbaa !33
DOALL:     	  %60 = call double @randlc(double* nonnull %4, double %21)
DOALL:     External nodes: 3
DOALL:     	  br i1 %26, label %27, label %61, !prof !39
DOALL:     	  store i64 %28, i64* %20, align 8, !tbaa !33
DOALL:     	  br i1 %58, label %.._crit_edge_crit_edge, label %59, !prof !45
DOALL:     Edges: 8
DOALL:     Loop-carried data dependences
DOALL:         %28 = load i64, i64* %19, align 8, !tbaa !33 --->   %60 = call double @randlc(double* nonnull %4, double %21) via memory
DOALL:         %60 = call double @randlc(double* nonnull %4, double %21) --->   %60 = call double @randlc(double* nonnull %4, double %21) via memory
DOALL:         %60 = call double @randlc(double* nonnull %4, double %21) --->   %60 = call double @randlc(double* nonnull %4, double %21) via memory
DOALL:         %60 = call double @randlc(double* nonnull %4, double %21) --->   %28 = load i64, i64* %19, align 8, !tbaa !33 via memory
DOALL:         %60 = call double @randlc(double* nonnull %4, double %21) --->   %60 = call double @randlc(double* nonnull %4, double %21) via memory
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store i64 %28, i64* %20, align 8, !tbaa !33
DOALL:     	  call void @vranlc(i32 %31, double* nonnull %3, double 0x41D2309CE5400000, double* %32)
DOALL:     	  %45 = load i64, i64* %44, align 8, !tbaa !33
DOALL:     	  %50 = load i64, i64* %49, align 8, !tbaa !33
DOALL:     External nodes: 9
DOALL:     	  br i1 %26, label %27, label %61, !prof !39
DOALL:     	  %28 = load i64, i64* %19, align 8, !tbaa !33
DOALL:     	  %31 = shl nsw i32 %30, 10
DOALL:     	  %32 = getelementptr [524289 x double], [524289 x double]* @compute_initial_conditions.tmp, i64 0, i64 0
DOALL:     	  br i1 %exitcond, label %53, label %41, !prof !41
DOALL:     	  %44 = bitcast double* %43 to i64*
DOALL:     	  store i64 %45, i64* %47, align 16, !tbaa !42
DOALL:     	  %49 = bitcast double* %48 to i64*
DOALL:     	  store i64 %50, i64* %52, align 8, !tbaa !44
DOALL:     Edges: 23
DOALL:     Loop-carried data dependences
DOALL:         store i64 %28, i64* %20, align 8, !tbaa !33 --->   store i64 %28, i64* %20, align 8, !tbaa !33 via memory
DOALL:         call void @vranlc(i32 %31, double* nonnull %3, double 0x41D2309CE5400000, double* %32) --->   %50 = load i64, i64* %49, align 8, !tbaa !33 via memory
DOALL:         call void @vranlc(i32 %31, double* nonnull %3, double 0x41D2309CE5400000, double* %32) --->   store i64 %28, i64* %20, align 8, !tbaa !33 via memory
DOALL:         call void @vranlc(i32 %31, double* nonnull %3, double 0x41D2309CE5400000, double* %32) --->   call void @vranlc(i32 %31, double* nonnull %3, double 0x41D2309CE5400000, double* %32) via memory
DOALL:         call void @vranlc(i32 %31, double* nonnull %3, double 0x41D2309CE5400000, double* %32) --->   store i64 %28, i64* %20, align 8, !tbaa !33 via memory
DOALL:         call void @vranlc(i32 %31, double* nonnull %3, double 0x41D2309CE5400000, double* %32) --->   call void @vranlc(i32 %31, double* nonnull %3, double 0x41D2309CE5400000, double* %32) via memory
DOALL:         call void @vranlc(i32 %31, double* nonnull %3, double 0x41D2309CE5400000, double* %32) --->   %45 = load i64, i64* %44, align 8, !tbaa !33 via memory
DOALL:         call void @vranlc(i32 %31, double* nonnull %3, double 0x41D2309CE5400000, double* %32) --->   call void @vranlc(i32 %31, double* nonnull %3, double 0x41D2309CE5400000, double* %32) via memory
DOALL:         %45 = load i64, i64* %44, align 8, !tbaa !33 --->   call void @vranlc(i32 %31, double* nonnull %3, double 0x41D2309CE5400000, double* %32) via memory
DOALL:         %50 = load i64, i64* %49, align 8, !tbaa !33 --->   call void @vranlc(i32 %31, double* nonnull %3, double 0x41D2309CE5400000, double* %32) via memory
Inliner:   Inlining in: compute_initial_conditions (87 instructions. The inlining will add 41 instructions),   call void @vranlc(i32 %31, double* nonnull %3, double 0x41D2309CE5400000, double* %32)
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
Inliner:   Inlined calls due to loop-carried data dependences
Inliner: Exit
Noelle:  Function "main"
Noelle:     Loop "  %exitcond8 = icmp eq i32 %.02, 7" (1.623777e-08%)
Noelle:     Loop "  %exitcond = icmp eq i32 %.1, 7" (1.623777e-08%)
Noelle:     Loop "  %.b4 = load i1, i1* @niter, align 4" (8.981779e+01%)
Noelle:  Function "fft"
Noelle:  Function "cfftz"
Noelle:     Loop "  %12 = icmp sgt i32 %.0, %1" (7.180252e+01%)
Noelle:     Loop "  %31 = icmp slt i64 %indvars.iv5, %29" (3.142097e+00%)
Noelle:     Loop "  %33 = icmp slt i64 %indvars.iv, %28" (3.074942e+00%)
Noelle:  Function "fftz2"
Noelle:     Loop "  %70 = icmp slt i64 %indvars.iv16, %22" (6.525502e+01%)
Noelle:     Loop "  %83 = icmp slt i64 %indvars.iv14, %21" (6.476629e+01%)
Noelle:     Loop "  %90 = icmp slt i64 %indvars.iv12, %20" (6.340452e+01%)
Noelle:     Loop "  %25 = icmp slt i64 %indvars.iv10, %22" (6.522170e+00%)
Noelle:     Loop "  %37 = icmp slt i64 %indvars.iv8, %21" (6.476444e+00%)
Noelle:     Loop "  %45 = icmp slt i64 %indvars.iv, %20" (6.340332e+00%)
Noelle:  Function "cffts3"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (1.253944e-06%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 1" (3.698096e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 0" (3.698095e+01%)
Noelle:     Loop "  %42 = icmp slt i64 %indvars.iv7, %40" (3.678879e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv, %39" (3.611659e+00%)
Noelle:     Loop "  %68 = icmp slt i64 %indvars.iv11, %66" (3.321068e+00%)
Noelle:     Loop "  %70 = icmp slt i64 %indvars.iv9, %64" (3.253847e+00%)
Noelle:  Function "cffts2"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (1.100291e-06%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 2" (3.697946e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 0" (3.697944e+01%)
Noelle:     Loop "  %42 = icmp slt i64 %indvars.iv7, %40" (3.678879e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv, %39" (3.611659e+00%)
Noelle:     Loop "  %68 = icmp slt i64 %indvars.iv11, %66" (3.321068e+00%)
Noelle:     Loop "  %70 = icmp slt i64 %indvars.iv9, %64" (3.253847e+00%)
Noelle:  Function "cffts1"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv14, 3" (1.100291e-06%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (2.108013e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 1" (2.108012e+01%)
Noelle:     Loop "  %41 = icmp slt i64 %indvars.iv6, %39" (3.045656e+00%)
Noelle:     Loop "  %47 = icmp slt i64 %indvars.iv, %38" (3.042445e+00%)
Noelle:     Loop "  %68 = icmp slt i64 %indvars.iv10, %62" (3.044957e+00%)
Noelle:     Loop "  %72 = icmp slt i64 %indvars.iv8, %66" (3.042445e+00%)
Noelle:  Function "evolve"
Noelle:     Loop "  %16 = icmp slt i64 %indvars.iv5, %8" (3.418342e+00%)
Noelle:     Loop "  %18 = icmp slt i64 %indvars.iv3, %11" (3.418335e+00%)
Noelle:     Loop "  %20 = icmp slt i64 %indvars.iv, %14" (3.416425e+00%)
Noelle:  Function "compute_initial_conditions"
Noelle:     Loop "  %23 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (1.301582e+00%)
Noelle:     Loop "  %37 = icmp slt i64 %indvars.iv6, %35" (3.257283e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 512" (3.254101e-01%)
Noelle:  Function "vranlc"
Noelle:     Loop "  %13 = icmp sgt i64 %indvars.iv, %11" (9.758457e-01%)
Noelle:  Function "compute_indexmap"
Noelle:     Loop "  %15 = icmp slt i64 %indvars.iv10, %4" (2.287184e-01%)
Noelle:     Loop "  %23 = icmp slt i64 %indvars.iv8, %8" (2.287154e-01%)
Noelle:     Loop "  %33 = icmp slt i64 %indvars.iv6, %12" (2.278887e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 1966081" (1.048531e-02%)
Noelle:  Function "checksum"
Noelle:     Loop "  %exitcond = icmp eq i32 %.0, 1025" (2.084881e-04%)
Noelle:  Function "randlc"
Noelle:  Function "fft_init"
Noelle:     Loop "  %7 = icmp sgt i32 %.01, %2" (3.791883e-06%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count" (3.728386e-06%)
Noelle:  Function "ilog2"
Noelle:     Loop "  %3 = icmp slt i32 %.01, %0" (2.684322e-06%)
Noelle:  Function "ipow46"
Noelle:     Loop "  %11 = icmp sgt i32 %.01, 1" (3.594122e-07%)
Noelle:  Function "verify"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 21" (1.122103e-07%)
Noelle:  Function "setup"
Noelle:     Loop "  %exitcond3 = icmp eq i64 %indvars.iv1, 3" (8.724773e-09%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 3" (1.308716e-08%)
Noelle:  Function "elapsed_time"
Noelle:  Function "timer_clear"
Noelle:  Function "c_print_results"
Noelle:  Function "wtime_"
Noelle:  Function "timer_stop"
Noelle:  Function "timer_start"
Noelle:  Function "timer_read"
Noelle:  Function "main"
Noelle:     Loop "  %exitcond8 = icmp eq i32 %.02, 7" (1.193981e-08%)
Noelle:     Loop "  %exitcond = icmp eq i32 %.1, 7" (1.193981e-08%)
Noelle:     Loop "  %.b4 = load i1, i1* @niter, align 4" (6.604308e+01%)
Noelle:  Function "fft"
Noelle:  Function "cfftz"
Noelle:     Loop "  %12 = icmp sgt i32 %.0, %1" (7.854885e+01%)
Noelle:     Loop "  %82 = icmp slt i64 %indvars.iv16.i, %34" (2.340635e+01%)
Noelle:     Loop "  %95 = icmp slt i64 %indvars.iv14.i, %33" (2.323103e+01%)
Noelle:     Loop "  %102 = icmp slt i64 %indvars.iv12.i, %32" (2.274256e+01%)
Noelle:     Loop "  %37 = icmp slt i64 %indvars.iv10.i, %34" (2.339544e+00%)
Noelle:     Loop "  %49 = icmp slt i64 %indvars.iv8.i, %33" (2.323103e+00%)
Noelle:     Loop "  %57 = icmp slt i64 %indvars.iv.i, %32" (2.274256e+00%)
Noelle:     Loop "  %136 = icmp slt i64 %indvars.iv5, %134" (2.310419e+00%)
Noelle:     Loop "  %138 = icmp slt i64 %indvars.iv, %133" (2.261039e+00%)
Noelle:  Function "fftz2"
Noelle:     Loop "  %70 = icmp slt i64 %indvars.iv16, %22" (4.798273e+01%)
Noelle:     Loop "  %83 = icmp slt i64 %indvars.iv14, %21" (4.762336e+01%)
Noelle:     Loop "  %90 = icmp slt i64 %indvars.iv12, %20" (4.662204e+01%)
Noelle:     Loop "  %25 = icmp slt i64 %indvars.iv10, %22" (4.795823e+00%)
Noelle:     Loop "  %37 = icmp slt i64 %indvars.iv8, %21" (4.762200e+00%)
Noelle:     Loop "  %45 = icmp slt i64 %indvars.iv, %20" (4.662116e+00%)
Noelle:  Function "cffts3"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (9.220386e-07%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 1" (2.719211e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 0" (2.719210e+01%)
Noelle:     Loop "  %42 = icmp slt i64 %indvars.iv7, %40" (2.705120e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv, %39" (2.655692e+00%)
Noelle:     Loop "  %68 = icmp slt i64 %indvars.iv11, %66" (2.442018e+00%)
Noelle:     Loop "  %70 = icmp slt i64 %indvars.iv9, %64" (2.392590e+00%)
Noelle:  Function "cffts2"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (8.090559e-07%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 2" (2.719098e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 0" (2.719097e+01%)
Noelle:     Loop "  %42 = icmp slt i64 %indvars.iv7, %40" (2.705120e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv, %39" (2.655692e+00%)
Noelle:     Loop "  %68 = icmp slt i64 %indvars.iv11, %66" (2.442018e+00%)
Noelle:     Loop "  %70 = icmp slt i64 %indvars.iv9, %64" (2.392590e+00%)
Noelle:  Function "cffts1"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv14, 3" (8.090559e-07%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (1.550024e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 1" (1.550023e+01%)
Noelle:     Loop "  %41 = icmp slt i64 %indvars.iv6, %39" (2.239504e+00%)
Noelle:     Loop "  %47 = icmp slt i64 %indvars.iv, %38" (2.237143e+00%)
Noelle:     Loop "  %68 = icmp slt i64 %indvars.iv10, %62" (2.238990e+00%)
Noelle:     Loop "  %72 = icmp slt i64 %indvars.iv8, %66" (2.237143e+00%)
Noelle:  Function "evolve"
Noelle:     Loop "  %16 = icmp slt i64 %indvars.iv5, %8" (2.513545e+00%)
Noelle:     Loop "  %18 = icmp slt i64 %indvars.iv3, %11" (2.513539e+00%)
Noelle:     Loop "  %20 = icmp slt i64 %indvars.iv, %14" (2.512135e+00%)
Noelle:  Function "compute_initial_conditions"
Noelle:     Loop "  %23 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (9.570672e-01%)
Noelle:     Loop "  %36 = icmp sgt i64 %indvars.iv.i, %34" (7.175503e-01%)
Noelle:     Loop "  %65 = icmp slt i64 %indvars.iv6, %63" (2.395116e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 512" (2.392776e-01%)
Noelle:  Function "vranlc"
Noelle:     Loop "  %13 = icmp sgt i64 %indvars.iv, %11" (7.175500e-01%)
Noelle:  Function "compute_indexmap"
Noelle:     Loop "  %15 = icmp slt i64 %indvars.iv10, %4" (1.681791e-01%)
Noelle:     Loop "  %23 = icmp slt i64 %indvars.iv8, %8" (1.681770e-01%)
Noelle:     Loop "  %33 = icmp slt i64 %indvars.iv6, %12" (1.675691e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 1966081" (7.709966e-03%)
Noelle:  Function "checksum"
Noelle:     Loop "  %exitcond = icmp eq i32 %.0, 1025" (1.533036e-04%)
Noelle:  Function "randlc"
Noelle:  Function "fft_init"
Noelle:     Loop "  %7 = icmp sgt i32 %.01, %2" (2.788213e-06%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count" (2.741523e-06%)
Noelle:  Function "ilog2"
Noelle:     Loop "  %3 = icmp slt i32 %.01, %0" (1.973811e-06%)
Noelle:  Function "ipow46"
Noelle:     Loop "  %11 = icmp sgt i32 %.01, 1" (2.642797e-07%)
Noelle:  Function "verify"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 21" (8.250945e-08%)
Noelle:  Function "setup"
Noelle:     Loop "  %exitcond3 = icmp eq i64 %indvars.iv1, 3" (6.415422e-09%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 3" (9.623132e-09%)
Noelle:  Function "elapsed_time"
Noelle:  Function "timer_clear"
Noelle:  Function "c_print_results"
Noelle:  Function "wtime_"
Noelle:  Function "timer_stop"
Noelle:  Function "timer_start"
Noelle:  Function "timer_read"
NOELLE: FixedPoint:       There are 141 different instructions and 395 different loop instructions
NOELLE: FixedPoint:       Normalize the code
noelle-norm /tmp/tmp.mEnWC8flov -o /tmp/tmp.mEnWC8flov
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.mEnWC8flov -o /tmp/tmp.mEnWC8flov
NOELLE: FixedPoint:     Invocation 1
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.1zCLAhAajz -o /tmp/tmp.mEnWC8flov
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.1zCLAhAajz -o /tmp/tmp.mEnWC8flov
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.1zCLAhAajz -o /tmp/tmp.mEnWC8flov
Inliner: Start
Inliner:   Number of program instructions = 1472
Inliner:   Profiles are available and will be used
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %100, double* %101, align 8, !tbaa !36
DOALL:     	  store double %102, double* %103, align 8, !tbaa !41
DOALL:     	  store double %108, double* %109, align 8, !tbaa !36
DOALL:     	  store double %112, double* %113, align 8, !tbaa !41
DOALL:     External nodes: 9
DOALL:     	  br i1 %90, label %91, label %114, !prof !46
DOALL:     	  %100 = fadd double %93, %97
DOALL:     	  %101 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %8, i64 %87, i64 %indvars.iv12, i32 0
DOALL:     	  %102 = fadd double %95, %99
DOALL:     	  %103 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %8, i64 %87, i64 %indvars.iv12, i32 1
DOALL:     	  %108 = fsub double %105, %107
DOALL:     	  %109 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %8, i64 %88, i64 %indvars.iv12, i32 0
DOALL:     	  %112 = fadd double %110, %111
DOALL:     	  %113 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %8, i64 %88, i64 %indvars.iv12, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %100, double* %101, align 8, !tbaa !36 --->   store double %108, double* %109, align 8, !tbaa !36 via memory
DOALL:         store double %100, double* %101, align 8, !tbaa !36 --->   store double %112, double* %113, align 8, !tbaa !41 via memory
DOALL:         store double %100, double* %101, align 8, !tbaa !36 --->   store double %100, double* %101, align 8, !tbaa !36 via memory
DOALL:         store double %100, double* %101, align 8, !tbaa !36 --->   store double %102, double* %103, align 8, !tbaa !41 via memory
DOALL:         store double %102, double* %103, align 8, !tbaa !41 --->   store double %108, double* %109, align 8, !tbaa !36 via memory
DOALL:         store double %102, double* %103, align 8, !tbaa !41 --->   store double %100, double* %101, align 8, !tbaa !36 via memory
DOALL:         store double %102, double* %103, align 8, !tbaa !41 --->   store double %112, double* %113, align 8, !tbaa !41 via memory
DOALL:         store double %102, double* %103, align 8, !tbaa !41 --->   store double %102, double* %103, align 8, !tbaa !41 via memory
DOALL:         store double %108, double* %109, align 8, !tbaa !36 --->   store double %108, double* %109, align 8, !tbaa !36 via memory
DOALL:         store double %108, double* %109, align 8, !tbaa !36 --->   store double %112, double* %113, align 8, !tbaa !41 via memory
DOALL:         store double %108, double* %109, align 8, !tbaa !36 --->   store double %100, double* %101, align 8, !tbaa !36 via memory
DOALL:         store double %108, double* %109, align 8, !tbaa !36 --->   store double %102, double* %103, align 8, !tbaa !41 via memory
DOALL:         store double %112, double* %113, align 8, !tbaa !41 --->   store double %112, double* %113, align 8, !tbaa !41 via memory
DOALL:         store double %112, double* %113, align 8, !tbaa !41 --->   store double %108, double* %109, align 8, !tbaa !36 via memory
DOALL:         store double %112, double* %113, align 8, !tbaa !41 --->   store double %100, double* %101, align 8, !tbaa !36 via memory
DOALL:         store double %112, double* %113, align 8, !tbaa !41 --->   store double %102, double* %103, align 8, !tbaa !41 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %56, double* %57, align 8, !tbaa !36
DOALL:     	  store double %58, double* %59, align 8, !tbaa !41
DOALL:     	  store double %64, double* %65, align 8, !tbaa !36
DOALL:     	  store double %68, double* %69, align 8, !tbaa !41
DOALL:     External nodes: 9
DOALL:     	  br i1 %45, label %47, label %46, !prof !43
DOALL:     	  %56 = fadd double %49, %53
DOALL:     	  %57 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %8, i64 %42, i64 %indvars.iv, i32 0
DOALL:     	  %58 = fadd double %51, %55
DOALL:     	  %59 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %8, i64 %42, i64 %indvars.iv, i32 1
DOALL:     	  %64 = fsub double %61, %63
DOALL:     	  %65 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %8, i64 %43, i64 %indvars.iv, i32 0
DOALL:     	  %68 = fadd double %66, %67
DOALL:     	  %69 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %8, i64 %43, i64 %indvars.iv, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %56, double* %57, align 8, !tbaa !36 --->   store double %68, double* %69, align 8, !tbaa !41 via memory
DOALL:         store double %56, double* %57, align 8, !tbaa !36 --->   store double %64, double* %65, align 8, !tbaa !36 via memory
DOALL:         store double %56, double* %57, align 8, !tbaa !36 --->   store double %56, double* %57, align 8, !tbaa !36 via memory
DOALL:         store double %56, double* %57, align 8, !tbaa !36 --->   store double %58, double* %59, align 8, !tbaa !41 via memory
DOALL:         store double %58, double* %59, align 8, !tbaa !41 --->   store double %64, double* %65, align 8, !tbaa !36 via memory
DOALL:         store double %58, double* %59, align 8, !tbaa !41 --->   store double %56, double* %57, align 8, !tbaa !36 via memory
DOALL:         store double %58, double* %59, align 8, !tbaa !41 --->   store double %68, double* %69, align 8, !tbaa !41 via memory
DOALL:         store double %58, double* %59, align 8, !tbaa !41 --->   store double %58, double* %59, align 8, !tbaa !41 via memory
DOALL:         store double %64, double* %65, align 8, !tbaa !36 --->   store double %68, double* %69, align 8, !tbaa !41 via memory
DOALL:         store double %64, double* %65, align 8, !tbaa !36 --->   store double %64, double* %65, align 8, !tbaa !36 via memory
DOALL:         store double %64, double* %65, align 8, !tbaa !36 --->   store double %56, double* %57, align 8, !tbaa !36 via memory
DOALL:         store double %64, double* %65, align 8, !tbaa !36 --->   store double %58, double* %59, align 8, !tbaa !41 via memory
DOALL:         store double %68, double* %69, align 8, !tbaa !41 --->   store double %64, double* %65, align 8, !tbaa !36 via memory
DOALL:         store double %68, double* %69, align 8, !tbaa !41 --->   store double %56, double* %57, align 8, !tbaa !36 via memory
DOALL:         store double %68, double* %69, align 8, !tbaa !41 --->   store double %68, double* %69, align 8, !tbaa !41 via memory
DOALL:         store double %68, double* %69, align 8, !tbaa !41 --->   store double %58, double* %59, align 8, !tbaa !41 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %56, double* %57, align 8, !tbaa !36
DOALL:     	  store double %58, double* %59, align 8, !tbaa !41
DOALL:     	  store double %64, double* %65, align 8, !tbaa !36
DOALL:     	  store double %68, double* %69, align 8, !tbaa !41
DOALL:     External nodes: 9
DOALL:     	  br i1 %45, label %47, label %46, !prof !43
DOALL:     	  %56 = fadd double %49, %53
DOALL:     	  %57 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %8, i64 %42, i64 %indvars.iv, i32 0
DOALL:     	  %58 = fadd double %51, %55
DOALL:     	  %59 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %8, i64 %42, i64 %indvars.iv, i32 1
DOALL:     	  %64 = fsub double %61, %63
DOALL:     	  %65 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %8, i64 %43, i64 %indvars.iv, i32 0
DOALL:     	  %68 = fadd double %66, %67
DOALL:     	  %69 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %8, i64 %43, i64 %indvars.iv, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %56, double* %57, align 8, !tbaa !36 --->   store double %64, double* %65, align 8, !tbaa !36 via memory
DOALL:         store double %56, double* %57, align 8, !tbaa !36 --->   store double %68, double* %69, align 8, !tbaa !41 via memory
DOALL:         store double %58, double* %59, align 8, !tbaa !41 --->   store double %68, double* %69, align 8, !tbaa !41 via memory
DOALL:         store double %58, double* %59, align 8, !tbaa !41 --->   store double %64, double* %65, align 8, !tbaa !36 via memory
DOALL:         store double %64, double* %65, align 8, !tbaa !36 --->   store double %56, double* %57, align 8, !tbaa !36 via memory
DOALL:         store double %64, double* %65, align 8, !tbaa !36 --->   store double %58, double* %59, align 8, !tbaa !41 via memory
DOALL:         store double %68, double* %69, align 8, !tbaa !41 --->   store double %56, double* %57, align 8, !tbaa !36 via memory
DOALL:         store double %68, double* %69, align 8, !tbaa !41 --->   store double %58, double* %59, align 8, !tbaa !41 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %100, double* %101, align 8, !tbaa !36
DOALL:     	  store double %102, double* %103, align 8, !tbaa !41
DOALL:     	  store double %108, double* %109, align 8, !tbaa !36
DOALL:     	  store double %112, double* %113, align 8, !tbaa !41
DOALL:     External nodes: 9
DOALL:     	  br i1 %90, label %91, label %114, !prof !46
DOALL:     	  %100 = fadd double %93, %97
DOALL:     	  %101 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %8, i64 %87, i64 %indvars.iv12, i32 0
DOALL:     	  %102 = fadd double %95, %99
DOALL:     	  %103 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %8, i64 %87, i64 %indvars.iv12, i32 1
DOALL:     	  %108 = fsub double %105, %107
DOALL:     	  %109 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %8, i64 %88, i64 %indvars.iv12, i32 0
DOALL:     	  %112 = fadd double %110, %111
DOALL:     	  %113 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %8, i64 %88, i64 %indvars.iv12, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %100, double* %101, align 8, !tbaa !36 --->   store double %112, double* %113, align 8, !tbaa !41 via memory
DOALL:         store double %100, double* %101, align 8, !tbaa !36 --->   store double %108, double* %109, align 8, !tbaa !36 via memory
DOALL:         store double %102, double* %103, align 8, !tbaa !41 --->   store double %112, double* %113, align 8, !tbaa !41 via memory
DOALL:         store double %102, double* %103, align 8, !tbaa !41 --->   store double %108, double* %109, align 8, !tbaa !36 via memory
DOALL:         store double %108, double* %109, align 8, !tbaa !36 --->   store double %100, double* %101, align 8, !tbaa !36 via memory
DOALL:         store double %108, double* %109, align 8, !tbaa !36 --->   store double %102, double* %103, align 8, !tbaa !41 via memory
DOALL:         store double %112, double* %113, align 8, !tbaa !41 --->   store double %100, double* %101, align 8, !tbaa !36 via memory
DOALL:         store double %112, double* %113, align 8, !tbaa !41 --->   store double %102, double* %103, align 8, !tbaa !41 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
Inliner:   Inlining in: cfftz (206 instructions. The inlining will add 136 instructions),   tail call fastcc void @fftz2(i32 %0, i32 %.0, i32 %1, i32 %2, i32 %14, i32 %15, %struct.dcomplex* %16, [18 x %struct.dcomplex]* %3, [18 x %struct.dcomplex]* %4)
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8
ClonableMemoryObject:   It is clonable
ClonableMemoryObject:   It requires initialization
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca double, align 8 can be cloned
MemoryCloningAnalysis:     The private copies need to be initialized with the original object.
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 3
DOALL:     	  store double %59, double* %60, align 8, !tbaa !33
DOALL:     	  %73 = load i64, i64* %72, align 8, !tbaa !33
DOALL:     	  %78 = load i64, i64* %77, align 8, !tbaa !33
DOALL:     External nodes: 8
DOALL:     	  br i1 %36, label %vranlc.exit, label %37, !prof !40
DOALL:     	  %59 = fmul double %58, 0x3D10000000000000
DOALL:     	  %60 = getelementptr inbounds double, double* %32, i64 %indvars.iv.i
DOALL:     	  br i1 %exitcond, label %81, label %69, !prof !42
DOALL:     	  %72 = bitcast double* %71 to i64*
DOALL:     	  store i64 %73, i64* %75, align 16, !tbaa !43
DOALL:     	  %77 = bitcast double* %76 to i64*
DOALL:     	  store i64 %78, i64* %80, align 8, !tbaa !45
DOALL:     Edges: 14
DOALL:     Loop-carried data dependences
DOALL:         store double %59, double* %60, align 8, !tbaa !33 --->   %78 = load i64, i64* %77, align 8, !tbaa !33 via memory
DOALL:         store double %59, double* %60, align 8, !tbaa !33 --->   store double %59, double* %60, align 8, !tbaa !33 via memory
DOALL:         store double %59, double* %60, align 8, !tbaa !33 --->   %73 = load i64, i64* %72, align 8, !tbaa !33 via memory
DOALL:         %73 = load i64, i64* %72, align 8, !tbaa !33 --->   store double %59, double* %60, align 8, !tbaa !33 via memory
DOALL:         %78 = load i64, i64* %77, align 8, !tbaa !33 --->   store double %59, double* %60, align 8, !tbaa !33 via memory
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 2
DOALL:     	  %28 = load i64, i64* %19, align 8, !tbaa !33
DOALL:     	  %88 = call double @randlc(double* nonnull %4, double %21)
DOALL:     External nodes: 3
DOALL:     	  br i1 %26, label %27, label %89, !prof !39
DOALL:     	  store i64 %28, i64* %20, align 8, !tbaa !33
DOALL:     	  br i1 %86, label %.._crit_edge_crit_edge, label %87, !prof !46
DOALL:     Edges: 8
DOALL:     Loop-carried data dependences
DOALL:         %28 = load i64, i64* %19, align 8, !tbaa !33 --->   %88 = call double @randlc(double* nonnull %4, double %21) via memory
DOALL:         %88 = call double @randlc(double* nonnull %4, double %21) --->   %88 = call double @randlc(double* nonnull %4, double %21) via memory
DOALL:         %88 = call double @randlc(double* nonnull %4, double %21) --->   %88 = call double @randlc(double* nonnull %4, double %21) via memory
DOALL:         %88 = call double @randlc(double* nonnull %4, double %21) --->   %28 = load i64, i64* %19, align 8, !tbaa !33 via memory
DOALL:         %88 = call double @randlc(double* nonnull %4, double %21) --->   %88 = call double @randlc(double* nonnull %4, double %21) via memory
Inliner:   Inlining in: compute_initial_conditions (121 instructions. The inlining will add 30 instructions),   %88 = call double @randlc(double* nonnull %4, double %21)
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
Inliner:   Inlined calls due to loop-carried data dependences
Inliner: Exit
Noelle:  Function "main"
Noelle:     Loop "  %exitcond8 = icmp eq i32 %.02, 7" (1.193981e-08%)
Noelle:     Loop "  %exitcond = icmp eq i32 %.1, 7" (1.193981e-08%)
Noelle:     Loop "  %.b4 = load i1, i1* @niter, align 4" (6.604308e+01%)
Noelle:  Function "fft"
Noelle:  Function "cfftz"
Noelle:     Loop "  %12 = icmp sgt i32 %.0, %1" (7.854885e+01%)
Noelle:     Loop "  %82 = icmp slt i64 %indvars.iv16.i, %34" (2.340635e+01%)
Noelle:     Loop "  %95 = icmp slt i64 %indvars.iv14.i, %33" (2.323103e+01%)
Noelle:     Loop "  %102 = icmp slt i64 %indvars.iv12.i, %32" (2.274256e+01%)
Noelle:     Loop "  %37 = icmp slt i64 %indvars.iv10.i, %34" (2.339544e+00%)
Noelle:     Loop "  %49 = icmp slt i64 %indvars.iv8.i, %33" (2.323103e+00%)
Noelle:     Loop "  %57 = icmp slt i64 %indvars.iv.i, %32" (2.274256e+00%)
Noelle:     Loop "  %136 = icmp slt i64 %indvars.iv5, %134" (2.310419e+00%)
Noelle:     Loop "  %138 = icmp slt i64 %indvars.iv, %133" (2.261039e+00%)
Noelle:  Function "fftz2"
Noelle:     Loop "  %70 = icmp slt i64 %indvars.iv16, %22" (4.798273e+01%)
Noelle:     Loop "  %83 = icmp slt i64 %indvars.iv14, %21" (4.762336e+01%)
Noelle:     Loop "  %90 = icmp slt i64 %indvars.iv12, %20" (4.662204e+01%)
Noelle:     Loop "  %25 = icmp slt i64 %indvars.iv10, %22" (4.795823e+00%)
Noelle:     Loop "  %37 = icmp slt i64 %indvars.iv8, %21" (4.762200e+00%)
Noelle:     Loop "  %45 = icmp slt i64 %indvars.iv, %20" (4.662116e+00%)
Noelle:  Function "cffts3"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (9.220386e-07%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 1" (2.719211e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 0" (2.719210e+01%)
Noelle:     Loop "  %42 = icmp slt i64 %indvars.iv7, %40" (2.705120e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv, %39" (2.655692e+00%)
Noelle:     Loop "  %68 = icmp slt i64 %indvars.iv11, %66" (2.442018e+00%)
Noelle:     Loop "  %70 = icmp slt i64 %indvars.iv9, %64" (2.392590e+00%)
Noelle:  Function "cffts2"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (8.090559e-07%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 2" (2.719098e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 0" (2.719097e+01%)
Noelle:     Loop "  %42 = icmp slt i64 %indvars.iv7, %40" (2.705120e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv, %39" (2.655692e+00%)
Noelle:     Loop "  %68 = icmp slt i64 %indvars.iv11, %66" (2.442018e+00%)
Noelle:     Loop "  %70 = icmp slt i64 %indvars.iv9, %64" (2.392590e+00%)
Noelle:  Function "cffts1"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv14, 3" (8.090559e-07%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (1.550024e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 1" (1.550023e+01%)
Noelle:     Loop "  %41 = icmp slt i64 %indvars.iv6, %39" (2.239504e+00%)
Noelle:     Loop "  %47 = icmp slt i64 %indvars.iv, %38" (2.237143e+00%)
Noelle:     Loop "  %68 = icmp slt i64 %indvars.iv10, %62" (2.238990e+00%)
Noelle:     Loop "  %72 = icmp slt i64 %indvars.iv8, %66" (2.237143e+00%)
Noelle:  Function "evolve"
Noelle:     Loop "  %16 = icmp slt i64 %indvars.iv5, %8" (2.513545e+00%)
Noelle:     Loop "  %18 = icmp slt i64 %indvars.iv3, %11" (2.513539e+00%)
Noelle:     Loop "  %20 = icmp slt i64 %indvars.iv, %14" (2.512135e+00%)
Noelle:  Function "compute_initial_conditions"
Noelle:     Loop "  %23 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (9.570673e-01%)
Noelle:     Loop "  %36 = icmp sgt i64 %indvars.iv.i, %34" (7.175503e-01%)
Noelle:     Loop "  %65 = icmp slt i64 %indvars.iv6, %63" (2.395116e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 512" (2.392776e-01%)
Noelle:  Function "vranlc"
Noelle:     Loop "  %13 = icmp sgt i64 %indvars.iv, %11" (7.175500e-01%)
Noelle:  Function "compute_indexmap"
Noelle:     Loop "  %15 = icmp slt i64 %indvars.iv10, %4" (1.681791e-01%)
Noelle:     Loop "  %23 = icmp slt i64 %indvars.iv8, %8" (1.681770e-01%)
Noelle:     Loop "  %33 = icmp slt i64 %indvars.iv6, %12" (1.675691e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 1966081" (7.709966e-03%)
Noelle:  Function "checksum"
Noelle:     Loop "  %exitcond = icmp eq i32 %.0, 1025" (1.533036e-04%)
Noelle:  Function "randlc"
Noelle:  Function "fft_init"
Noelle:     Loop "  %7 = icmp sgt i32 %.01, %2" (2.788213e-06%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count" (2.741523e-06%)
Noelle:  Function "ilog2"
Noelle:     Loop "  %3 = icmp slt i32 %.01, %0" (1.973811e-06%)
Noelle:  Function "ipow46"
Noelle:     Loop "  %11 = icmp sgt i32 %.01, 1" (2.642797e-07%)
Noelle:  Function "verify"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 21" (8.250945e-08%)
Noelle:  Function "setup"
Noelle:     Loop "  %exitcond3 = icmp eq i64 %indvars.iv1, 3" (6.415422e-09%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 3" (9.623132e-09%)
Noelle:  Function "elapsed_time"
Noelle:  Function "timer_clear"
Noelle:  Function "c_print_results"
Noelle:  Function "wtime_"
Noelle:  Function "timer_stop"
Noelle:  Function "timer_start"
Noelle:  Function "timer_read"
Noelle:  Function "main"
Noelle:     Loop "  %exitcond8 = icmp eq i32 %.02, 7" (9.398497e-09%)
Noelle:     Loop "  %exitcond = icmp eq i32 %.1, 7" (9.398497e-09%)
Noelle:     Loop "  %.b4 = load i1, i1* @niter, align 4" (5.198593e+01%)
Noelle:  Function "fft"
Noelle:  Function "cfftz"
Noelle:     Loop "  %12 = icmp sgt i32 %.0, %1" (4.155903e+01%)
Noelle:     Loop "  %77 = icmp slt i64 %indvars.iv16.i11, %29" (1.934567e+01%)
Noelle:     Loop "  %90 = icmp slt i64 %indvars.iv14.i13, %28" (1.920077e+01%)
Noelle:     Loop "  %97 = icmp slt i64 %indvars.iv12.i14, %27" (1.879704e+01%)
Noelle:     Loop "  %32 = icmp slt i64 %indvars.iv10.i4, %29" (1.933666e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv8.i6, %28" (1.920077e+00%)
Noelle:     Loop "  %52 = icmp slt i64 %indvars.iv.i8, %27" (1.879704e+00%)
Noelle:     Loop "  %188 = icmp slt i64 %indvars.iv16.i, %140" (1.842445e+01%)
Noelle:     Loop "  %201 = icmp slt i64 %indvars.iv14.i, %139" (1.828645e+01%)
Noelle:     Loop "  %208 = icmp slt i64 %indvars.iv12.i, %138" (1.790194e+01%)
Noelle:     Loop "  %143 = icmp slt i64 %indvars.iv10.i, %140" (1.841587e+00%)
Noelle:     Loop "  %155 = icmp slt i64 %indvars.iv8.i, %139" (1.828645e+00%)
Noelle:     Loop "  %163 = icmp slt i64 %indvars.iv.i, %138" (1.790194e+00%)
Noelle:     Loop "  %242 = icmp slt i64 %indvars.iv5, %240" (1.818660e+00%)
Noelle:     Loop "  %244 = icmp slt i64 %indvars.iv, %239" (1.779790e+00%)
Noelle:  Function "fftz2"
Noelle:     Loop "  %70 = icmp slt i64 %indvars.iv16, %22" (3.776990e+01%)
Noelle:     Loop "  %83 = icmp slt i64 %indvars.iv14, %21" (3.748702e+01%)
Noelle:     Loop "  %90 = icmp slt i64 %indvars.iv12, %20" (3.669883e+01%)
Noelle:     Loop "  %25 = icmp slt i64 %indvars.iv10, %22" (3.775062e+00%)
Noelle:     Loop "  %37 = icmp slt i64 %indvars.iv8, %21" (3.748595e+00%)
Noelle:     Loop "  %45 = icmp slt i64 %indvars.iv, %20" (3.669813e+00%)
Noelle:  Function "cffts3"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (7.257884e-07%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 1" (2.140431e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 0" (2.140430e+01%)
Noelle:     Loop "  %42 = icmp slt i64 %indvars.iv7, %40" (2.129352e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv, %39" (2.090445e+00%)
Noelle:     Loop "  %68 = icmp slt i64 %indvars.iv11, %66" (1.922249e+00%)
Noelle:     Loop "  %70 = icmp slt i64 %indvars.iv9, %64" (1.883342e+00%)
Noelle:  Function "cffts2"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (6.368534e-07%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 2" (2.140342e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 0" (2.140342e+01%)
Noelle:     Loop "  %42 = icmp slt i64 %indvars.iv7, %40" (2.129352e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv, %39" (2.090445e+00%)
Noelle:     Loop "  %68 = icmp slt i64 %indvars.iv11, %66" (1.922249e+00%)
Noelle:     Loop "  %70 = icmp slt i64 %indvars.iv9, %64" (1.883342e+00%)
Noelle:  Function "cffts1"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv14, 3" (6.368534e-07%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (1.220105e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 1" (1.220104e+01%)
Noelle:     Loop "  %41 = icmp slt i64 %indvars.iv6, %39" (1.762839e+00%)
Noelle:     Loop "  %47 = icmp slt i64 %indvars.iv, %38" (1.760981e+00%)
Noelle:     Loop "  %68 = icmp slt i64 %indvars.iv10, %62" (1.762435e+00%)
Noelle:     Loop "  %72 = icmp slt i64 %indvars.iv8, %66" (1.760981e+00%)
Noelle:  Function "evolve"
Noelle:     Loop "  %16 = icmp slt i64 %indvars.iv5, %8" (1.978552e+00%)
Noelle:     Loop "  %18 = icmp slt i64 %indvars.iv3, %11" (1.978548e+00%)
Noelle:     Loop "  %20 = icmp slt i64 %indvars.iv, %14" (1.977443e+00%)
Noelle:  Function "compute_initial_conditions"
Noelle:     Loop "  %23 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (7.533614e-01%)
Noelle:     Loop "  %36 = icmp sgt i64 %indvars.iv.i, %34" (5.648242e-01%)
Noelle:     Loop "  %65 = icmp slt i64 %indvars.iv6, %63" (1.885330e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 512" (1.883489e-01%)
Noelle:  Function "vranlc"
Noelle:     Loop "  %13 = icmp sgt i64 %indvars.iv, %11" (5.648239e-01%)
Noelle:  Function "compute_indexmap"
Noelle:     Loop "  %15 = icmp slt i64 %indvars.iv10, %4" (1.323832e-01%)
Noelle:     Loop "  %23 = icmp slt i64 %indvars.iv8, %8" (1.323815e-01%)
Noelle:     Loop "  %33 = icmp slt i64 %indvars.iv6, %12" (1.319030e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 1966081" (6.068947e-03%)
Noelle:  Function "checksum"
Noelle:     Loop "  %exitcond = icmp eq i32 %.0, 1025" (1.206739e-04%)
Noelle:  Function "randlc"
Noelle:  Function "fft_init"
Noelle:     Loop "  %7 = icmp sgt i32 %.01, %2" (2.194759e-06%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count" (2.158007e-06%)
Noelle:  Function "ilog2"
Noelle:     Loop "  %3 = icmp slt i32 %.01, %0" (1.553698e-06%)
Noelle:  Function "ipow46"
Noelle:     Loop "  %11 = icmp sgt i32 %.01, 1" (2.080294e-07%)
Noelle:  Function "verify"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 21" (6.494782e-08%)
Noelle:  Function "setup"
Noelle:     Loop "  %exitcond3 = icmp eq i64 %indvars.iv1, 3" (5.049939e-09%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 3" (7.574908e-09%)
Noelle:  Function "elapsed_time"
Noelle:  Function "timer_clear"
Noelle:  Function "c_print_results"
Noelle:  Function "wtime_"
Noelle:  Function "timer_stop"
Noelle:  Function "timer_start"
Noelle:  Function "timer_read"
NOELLE: FixedPoint:       There are 142 different instructions and 369 different loop instructions
NOELLE: FixedPoint:       Normalize the code
noelle-norm /tmp/tmp.mEnWC8flov -o /tmp/tmp.mEnWC8flov
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.mEnWC8flov -o /tmp/tmp.mEnWC8flov
NOELLE: FixedPoint:     Invocation 2
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.1zCLAhAajz -o /tmp/tmp.mEnWC8flov
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.1zCLAhAajz -o /tmp/tmp.mEnWC8flov
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.1zCLAhAajz -o /tmp/tmp.mEnWC8flov
Inliner: Start
Inliner:   Number of program instructions = 1634
Inliner:   Profiles are available and will be used
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %107, double* %108, align 8, !tbaa !33
DOALL:     	  store double %109, double* %110, align 8, !tbaa !48
DOALL:     	  store double %115, double* %116, align 8, !tbaa !33
DOALL:     	  store double %119, double* %120, align 8, !tbaa !48
DOALL:     External nodes: 9
DOALL:     	  br i1 %97, label %98, label %121, !prof !53
DOALL:     	  %107 = fadd double %100, %104
DOALL:     	  %108 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %4, i64 %94, i64 %indvars.iv12.i14, i32 0
DOALL:     	  %109 = fadd double %102, %106
DOALL:     	  %110 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %4, i64 %94, i64 %indvars.iv12.i14, i32 1
DOALL:     	  %115 = fsub double %112, %114
DOALL:     	  %116 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %4, i64 %95, i64 %indvars.iv12.i14, i32 0
DOALL:     	  %119 = fadd double %117, %118
DOALL:     	  %120 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %4, i64 %95, i64 %indvars.iv12.i14, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %107, double* %108, align 8, !tbaa !33 --->   store double %119, double* %120, align 8, !tbaa !48 via memory
DOALL:         store double %107, double* %108, align 8, !tbaa !33 --->   store double %115, double* %116, align 8, !tbaa !33 via memory
DOALL:         store double %107, double* %108, align 8, !tbaa !33 --->   store double %107, double* %108, align 8, !tbaa !33 via memory
DOALL:         store double %107, double* %108, align 8, !tbaa !33 --->   store double %109, double* %110, align 8, !tbaa !48 via memory
DOALL:         store double %109, double* %110, align 8, !tbaa !48 --->   store double %119, double* %120, align 8, !tbaa !48 via memory
DOALL:         store double %109, double* %110, align 8, !tbaa !48 --->   store double %115, double* %116, align 8, !tbaa !33 via memory
DOALL:         store double %109, double* %110, align 8, !tbaa !48 --->   store double %107, double* %108, align 8, !tbaa !33 via memory
DOALL:         store double %109, double* %110, align 8, !tbaa !48 --->   store double %109, double* %110, align 8, !tbaa !48 via memory
DOALL:         store double %115, double* %116, align 8, !tbaa !33 --->   store double %119, double* %120, align 8, !tbaa !48 via memory
DOALL:         store double %115, double* %116, align 8, !tbaa !33 --->   store double %115, double* %116, align 8, !tbaa !33 via memory
DOALL:         store double %115, double* %116, align 8, !tbaa !33 --->   store double %107, double* %108, align 8, !tbaa !33 via memory
DOALL:         store double %115, double* %116, align 8, !tbaa !33 --->   store double %109, double* %110, align 8, !tbaa !48 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !48 --->   store double %119, double* %120, align 8, !tbaa !48 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !48 --->   store double %115, double* %116, align 8, !tbaa !33 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !48 --->   store double %107, double* %108, align 8, !tbaa !33 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !48 --->   store double %109, double* %110, align 8, !tbaa !48 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %218, double* %219, align 8, !tbaa !33
DOALL:     	  store double %220, double* %221, align 8, !tbaa !48
DOALL:     	  store double %226, double* %227, align 8, !tbaa !33
DOALL:     	  store double %230, double* %231, align 8, !tbaa !48
DOALL:     External nodes: 9
DOALL:     	  %218 = fadd double %211, %215
DOALL:     	  %219 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %3, i64 %205, i64 %indvars.iv12.i, i32 0
DOALL:     	  %220 = fadd double %213, %217
DOALL:     	  %221 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %3, i64 %205, i64 %indvars.iv12.i, i32 1
DOALL:     	  br i1 %208, label %209, label %232, !prof !53
DOALL:     	  %226 = fsub double %223, %225
DOALL:     	  %227 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %3, i64 %206, i64 %indvars.iv12.i, i32 0
DOALL:     	  %230 = fadd double %228, %229
DOALL:     	  %231 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %3, i64 %206, i64 %indvars.iv12.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %226, double* %227, align 8, !tbaa !33 --->   store double %230, double* %231, align 8, !tbaa !48 via memory
DOALL:         store double %226, double* %227, align 8, !tbaa !33 --->   store double %218, double* %219, align 8, !tbaa !33 via memory
DOALL:         store double %226, double* %227, align 8, !tbaa !33 --->   store double %220, double* %221, align 8, !tbaa !48 via memory
DOALL:         store double %230, double* %231, align 8, !tbaa !48 --->   store double %218, double* %219, align 8, !tbaa !33 via memory
DOALL:         store double %230, double* %231, align 8, !tbaa !48 --->   store double %230, double* %231, align 8, !tbaa !48 via memory
DOALL:         store double %230, double* %231, align 8, !tbaa !48 --->   store double %220, double* %221, align 8, !tbaa !48 via memory
DOALL:         store double %230, double* %231, align 8, !tbaa !48 --->   store double %226, double* %227, align 8, !tbaa !33 via memory
DOALL:         store double %218, double* %219, align 8, !tbaa !33 --->   store double %230, double* %231, align 8, !tbaa !48 via memory
DOALL:         store double %218, double* %219, align 8, !tbaa !33 --->   store double %226, double* %227, align 8, !tbaa !33 via memory
DOALL:         store double %218, double* %219, align 8, !tbaa !33 --->   store double %218, double* %219, align 8, !tbaa !33 via memory
DOALL:         store double %218, double* %219, align 8, !tbaa !33 --->   store double %220, double* %221, align 8, !tbaa !48 via memory
DOALL:         store double %220, double* %221, align 8, !tbaa !48 --->   store double %220, double* %221, align 8, !tbaa !48 via memory
DOALL:         store double %220, double* %221, align 8, !tbaa !48 --->   store double %218, double* %219, align 8, !tbaa !33 via memory
DOALL:         store double %220, double* %221, align 8, !tbaa !48 --->   store double %226, double* %227, align 8, !tbaa !33 via memory
DOALL:         store double %220, double* %221, align 8, !tbaa !48 --->   store double %230, double* %231, align 8, !tbaa !48 via memory
DOALL:         store double %226, double* %227, align 8, !tbaa !33 --->   store double %226, double* %227, align 8, !tbaa !33 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %63, double* %64, align 8, !tbaa !33
DOALL:     	  store double %65, double* %66, align 8, !tbaa !48
DOALL:     	  store double %71, double* %72, align 8, !tbaa !33
DOALL:     	  store double %75, double* %76, align 8, !tbaa !48
DOALL:     External nodes: 9
DOALL:     	  br i1 %52, label %54, label %53, !prof !50
DOALL:     	  %63 = fadd double %56, %60
DOALL:     	  %64 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %4, i64 %49, i64 %indvars.iv.i8, i32 0
DOALL:     	  %65 = fadd double %58, %62
DOALL:     	  %66 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %4, i64 %49, i64 %indvars.iv.i8, i32 1
DOALL:     	  %71 = fsub double %68, %70
DOALL:     	  %72 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %4, i64 %50, i64 %indvars.iv.i8, i32 0
DOALL:     	  %75 = fadd double %73, %74
DOALL:     	  %76 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %4, i64 %50, i64 %indvars.iv.i8, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %63, double* %64, align 8, !tbaa !33 --->   store double %75, double* %76, align 8, !tbaa !48 via memory
DOALL:         store double %63, double* %64, align 8, !tbaa !33 --->   store double %71, double* %72, align 8, !tbaa !33 via memory
DOALL:         store double %63, double* %64, align 8, !tbaa !33 --->   store double %63, double* %64, align 8, !tbaa !33 via memory
DOALL:         store double %63, double* %64, align 8, !tbaa !33 --->   store double %65, double* %66, align 8, !tbaa !48 via memory
DOALL:         store double %65, double* %66, align 8, !tbaa !48 --->   store double %75, double* %76, align 8, !tbaa !48 via memory
DOALL:         store double %65, double* %66, align 8, !tbaa !48 --->   store double %71, double* %72, align 8, !tbaa !33 via memory
DOALL:         store double %65, double* %66, align 8, !tbaa !48 --->   store double %63, double* %64, align 8, !tbaa !33 via memory
DOALL:         store double %65, double* %66, align 8, !tbaa !48 --->   store double %65, double* %66, align 8, !tbaa !48 via memory
DOALL:         store double %71, double* %72, align 8, !tbaa !33 --->   store double %75, double* %76, align 8, !tbaa !48 via memory
DOALL:         store double %71, double* %72, align 8, !tbaa !33 --->   store double %71, double* %72, align 8, !tbaa !33 via memory
DOALL:         store double %71, double* %72, align 8, !tbaa !33 --->   store double %63, double* %64, align 8, !tbaa !33 via memory
DOALL:         store double %71, double* %72, align 8, !tbaa !33 --->   store double %65, double* %66, align 8, !tbaa !48 via memory
DOALL:         store double %75, double* %76, align 8, !tbaa !48 --->   store double %75, double* %76, align 8, !tbaa !48 via memory
DOALL:         store double %75, double* %76, align 8, !tbaa !48 --->   store double %71, double* %72, align 8, !tbaa !33 via memory
DOALL:         store double %75, double* %76, align 8, !tbaa !48 --->   store double %63, double* %64, align 8, !tbaa !33 via memory
DOALL:         store double %75, double* %76, align 8, !tbaa !48 --->   store double %65, double* %66, align 8, !tbaa !48 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %174, double* %175, align 8, !tbaa !33
DOALL:     	  store double %176, double* %177, align 8, !tbaa !48
DOALL:     	  store double %182, double* %183, align 8, !tbaa !33
DOALL:     	  store double %186, double* %187, align 8, !tbaa !48
DOALL:     External nodes: 9
DOALL:     	  br i1 %163, label %165, label %164, !prof !50
DOALL:     	  %174 = fadd double %167, %171
DOALL:     	  %175 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %3, i64 %160, i64 %indvars.iv.i, i32 0
DOALL:     	  %176 = fadd double %169, %173
DOALL:     	  %177 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %3, i64 %160, i64 %indvars.iv.i, i32 1
DOALL:     	  %182 = fsub double %179, %181
DOALL:     	  %183 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %3, i64 %161, i64 %indvars.iv.i, i32 0
DOALL:     	  %186 = fadd double %184, %185
DOALL:     	  %187 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %3, i64 %161, i64 %indvars.iv.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %174, double* %175, align 8, !tbaa !33 --->   store double %176, double* %177, align 8, !tbaa !48 via memory
DOALL:         store double %174, double* %175, align 8, !tbaa !33 --->   store double %182, double* %183, align 8, !tbaa !33 via memory
DOALL:         store double %174, double* %175, align 8, !tbaa !33 --->   store double %186, double* %187, align 8, !tbaa !48 via memory
DOALL:         store double %174, double* %175, align 8, !tbaa !33 --->   store double %174, double* %175, align 8, !tbaa !33 via memory
DOALL:         store double %176, double* %177, align 8, !tbaa !48 --->   store double %182, double* %183, align 8, !tbaa !33 via memory
DOALL:         store double %176, double* %177, align 8, !tbaa !48 --->   store double %176, double* %177, align 8, !tbaa !48 via memory
DOALL:         store double %176, double* %177, align 8, !tbaa !48 --->   store double %186, double* %187, align 8, !tbaa !48 via memory
DOALL:         store double %176, double* %177, align 8, !tbaa !48 --->   store double %174, double* %175, align 8, !tbaa !33 via memory
DOALL:         store double %182, double* %183, align 8, !tbaa !33 --->   store double %186, double* %187, align 8, !tbaa !48 via memory
DOALL:         store double %182, double* %183, align 8, !tbaa !33 --->   store double %182, double* %183, align 8, !tbaa !33 via memory
DOALL:         store double %182, double* %183, align 8, !tbaa !33 --->   store double %174, double* %175, align 8, !tbaa !33 via memory
DOALL:         store double %182, double* %183, align 8, !tbaa !33 --->   store double %176, double* %177, align 8, !tbaa !48 via memory
DOALL:         store double %186, double* %187, align 8, !tbaa !48 --->   store double %182, double* %183, align 8, !tbaa !33 via memory
DOALL:         store double %186, double* %187, align 8, !tbaa !48 --->   store double %174, double* %175, align 8, !tbaa !33 via memory
DOALL:         store double %186, double* %187, align 8, !tbaa !48 --->   store double %186, double* %187, align 8, !tbaa !48 via memory
DOALL:         store double %186, double* %187, align 8, !tbaa !48 --->   store double %176, double* %177, align 8, !tbaa !48 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %63, double* %64, align 8, !tbaa !33
DOALL:     	  store double %65, double* %66, align 8, !tbaa !48
DOALL:     	  store double %71, double* %72, align 8, !tbaa !33
DOALL:     	  store double %75, double* %76, align 8, !tbaa !48
DOALL:     External nodes: 9
DOALL:     	  br i1 %52, label %54, label %53, !prof !50
DOALL:     	  %63 = fadd double %56, %60
DOALL:     	  %64 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %4, i64 %49, i64 %indvars.iv.i8, i32 0
DOALL:     	  %65 = fadd double %58, %62
DOALL:     	  %66 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %4, i64 %49, i64 %indvars.iv.i8, i32 1
DOALL:     	  %71 = fsub double %68, %70
DOALL:     	  %72 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %4, i64 %50, i64 %indvars.iv.i8, i32 0
DOALL:     	  %75 = fadd double %73, %74
DOALL:     	  %76 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %4, i64 %50, i64 %indvars.iv.i8, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %63, double* %64, align 8, !tbaa !33 --->   store double %75, double* %76, align 8, !tbaa !48 via memory
DOALL:         store double %63, double* %64, align 8, !tbaa !33 --->   store double %71, double* %72, align 8, !tbaa !33 via memory
DOALL:         store double %65, double* %66, align 8, !tbaa !48 --->   store double %75, double* %76, align 8, !tbaa !48 via memory
DOALL:         store double %65, double* %66, align 8, !tbaa !48 --->   store double %71, double* %72, align 8, !tbaa !33 via memory
DOALL:         store double %71, double* %72, align 8, !tbaa !33 --->   store double %63, double* %64, align 8, !tbaa !33 via memory
DOALL:         store double %71, double* %72, align 8, !tbaa !33 --->   store double %65, double* %66, align 8, !tbaa !48 via memory
DOALL:         store double %75, double* %76, align 8, !tbaa !48 --->   store double %63, double* %64, align 8, !tbaa !33 via memory
DOALL:         store double %75, double* %76, align 8, !tbaa !48 --->   store double %65, double* %66, align 8, !tbaa !48 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %107, double* %108, align 8, !tbaa !33
DOALL:     	  store double %109, double* %110, align 8, !tbaa !48
DOALL:     	  store double %115, double* %116, align 8, !tbaa !33
DOALL:     	  store double %119, double* %120, align 8, !tbaa !48
DOALL:     External nodes: 9
DOALL:     	  br i1 %97, label %98, label %121, !prof !53
DOALL:     	  %107 = fadd double %100, %104
DOALL:     	  %108 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %4, i64 %94, i64 %indvars.iv12.i14, i32 0
DOALL:     	  %109 = fadd double %102, %106
DOALL:     	  %110 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %4, i64 %94, i64 %indvars.iv12.i14, i32 1
DOALL:     	  %115 = fsub double %112, %114
DOALL:     	  %116 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %4, i64 %95, i64 %indvars.iv12.i14, i32 0
DOALL:     	  %119 = fadd double %117, %118
DOALL:     	  %120 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %4, i64 %95, i64 %indvars.iv12.i14, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %115, double* %116, align 8, !tbaa !33 --->   store double %107, double* %108, align 8, !tbaa !33 via memory
DOALL:         store double %115, double* %116, align 8, !tbaa !33 --->   store double %109, double* %110, align 8, !tbaa !48 via memory
DOALL:         store double %107, double* %108, align 8, !tbaa !33 --->   store double %119, double* %120, align 8, !tbaa !48 via memory
DOALL:         store double %107, double* %108, align 8, !tbaa !33 --->   store double %115, double* %116, align 8, !tbaa !33 via memory
DOALL:         store double %109, double* %110, align 8, !tbaa !48 --->   store double %119, double* %120, align 8, !tbaa !48 via memory
DOALL:         store double %109, double* %110, align 8, !tbaa !48 --->   store double %115, double* %116, align 8, !tbaa !33 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !48 --->   store double %109, double* %110, align 8, !tbaa !48 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !48 --->   store double %107, double* %108, align 8, !tbaa !33 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %218, double* %219, align 8, !tbaa !33
DOALL:     	  store double %220, double* %221, align 8, !tbaa !48
DOALL:     	  store double %226, double* %227, align 8, !tbaa !33
DOALL:     	  store double %230, double* %231, align 8, !tbaa !48
DOALL:     External nodes: 9
DOALL:     	  %218 = fadd double %211, %215
DOALL:     	  %219 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %3, i64 %205, i64 %indvars.iv12.i, i32 0
DOALL:     	  %220 = fadd double %213, %217
DOALL:     	  %221 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %3, i64 %205, i64 %indvars.iv12.i, i32 1
DOALL:     	  br i1 %208, label %209, label %232, !prof !53
DOALL:     	  %226 = fsub double %223, %225
DOALL:     	  %227 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %3, i64 %206, i64 %indvars.iv12.i, i32 0
DOALL:     	  %230 = fadd double %228, %229
DOALL:     	  %231 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %3, i64 %206, i64 %indvars.iv12.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %218, double* %219, align 8, !tbaa !33 --->   store double %230, double* %231, align 8, !tbaa !48 via memory
DOALL:         store double %218, double* %219, align 8, !tbaa !33 --->   store double %226, double* %227, align 8, !tbaa !33 via memory
DOALL:         store double %220, double* %221, align 8, !tbaa !48 --->   store double %226, double* %227, align 8, !tbaa !33 via memory
DOALL:         store double %220, double* %221, align 8, !tbaa !48 --->   store double %230, double* %231, align 8, !tbaa !48 via memory
DOALL:         store double %226, double* %227, align 8, !tbaa !33 --->   store double %218, double* %219, align 8, !tbaa !33 via memory
DOALL:         store double %226, double* %227, align 8, !tbaa !33 --->   store double %220, double* %221, align 8, !tbaa !48 via memory
DOALL:         store double %230, double* %231, align 8, !tbaa !48 --->   store double %218, double* %219, align 8, !tbaa !33 via memory
DOALL:         store double %230, double* %231, align 8, !tbaa !48 --->   store double %220, double* %221, align 8, !tbaa !48 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %174, double* %175, align 8, !tbaa !33
DOALL:     	  store double %176, double* %177, align 8, !tbaa !48
DOALL:     	  store double %182, double* %183, align 8, !tbaa !33
DOALL:     	  store double %186, double* %187, align 8, !tbaa !48
DOALL:     External nodes: 9
DOALL:     	  br i1 %163, label %165, label %164, !prof !50
DOALL:     	  %174 = fadd double %167, %171
DOALL:     	  %175 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %3, i64 %160, i64 %indvars.iv.i, i32 0
DOALL:     	  %176 = fadd double %169, %173
DOALL:     	  %177 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %3, i64 %160, i64 %indvars.iv.i, i32 1
DOALL:     	  %182 = fsub double %179, %181
DOALL:     	  %183 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %3, i64 %161, i64 %indvars.iv.i, i32 0
DOALL:     	  %186 = fadd double %184, %185
DOALL:     	  %187 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %3, i64 %161, i64 %indvars.iv.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %174, double* %175, align 8, !tbaa !33 --->   store double %182, double* %183, align 8, !tbaa !33 via memory
DOALL:         store double %186, double* %187, align 8, !tbaa !48 --->   store double %174, double* %175, align 8, !tbaa !33 via memory
DOALL:         store double %186, double* %187, align 8, !tbaa !48 --->   store double %176, double* %177, align 8, !tbaa !48 via memory
DOALL:         store double %174, double* %175, align 8, !tbaa !33 --->   store double %186, double* %187, align 8, !tbaa !48 via memory
DOALL:         store double %176, double* %177, align 8, !tbaa !48 --->   store double %182, double* %183, align 8, !tbaa !33 via memory
DOALL:         store double %176, double* %177, align 8, !tbaa !48 --->   store double %186, double* %187, align 8, !tbaa !48 via memory
DOALL:         store double %182, double* %183, align 8, !tbaa !33 --->   store double %174, double* %175, align 8, !tbaa !33 via memory
DOALL:         store double %182, double* %183, align 8, !tbaa !33 --->   store double %176, double* %177, align 8, !tbaa !48 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject:   It requires initialization
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
MemoryCloningAnalysis:     The private copies need to be initialized with the original object.
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 1
DOALL:     	  %.pre = load i32, i32* @fftblock, align 4, !tbaa !34
DOALL:     External nodes: 3
DOALL:     	  br i1 %28, label %29, label %87, !prof !38
DOALL:     	  %31 = phi i32 [ %.pre, %29 ], [ %63, %84 ]
DOALL:     	  call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23)
DOALL:     Edges: 3
DOALL:     Loop-carried data dependences
DOALL:         %.pre = load i32, i32* @fftblock, align 4, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %.pre = load i32, i32* @fftblock, align 4, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 63
DOALL:     	  %54 = getelementptr inbounds [256 x [256 x [512 x %struct.dcomplex]]], [256 x [256 x [512 x %struct.dcomplex]]]* @main.u1, i64 0, i64 %indvars.iv7, i64 %indvars.iv13, i64 %48, i32 1
DOALL:     	  %31 = phi i32 [ %.pre, %29 ], [ %63, %84 ]
DOALL:     	  %.0 = phi i32 [ 0, %29 ], [ %85, %84 ]
DOALL:     	  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 0
DOALL:     	  %33 = load i32, i32* %32, align 8, !tbaa !34
DOALL:     	  %34 = sub nsw i32 %33, %31
DOALL:     	  %35 = icmp sgt i32 %.0, %34
DOALL:     	  br i1 %35, label %86, label %36, !prof !39
DOALL:     	  %37 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 2
DOALL:     	  %38 = load i32, i32* %37, align 8, !tbaa !34
DOALL:     	  %39 = sext i32 %31 to i64
DOALL:     	  %40 = sext i32 %38 to i64
DOALL:     	  %indvars.iv7 = phi i64 [ %indvars.iv.next8, %59 ], [ 0, %36 ]
DOALL:     	  %42 = icmp slt i64 %indvars.iv7, %40
DOALL:     	  br i1 %42, label %.preheader1, label %60, !prof !40
DOALL:     	  %indvars.iv = phi i64 [ %indvars.iv.next, %45 ], [ 0, %.preheader1 ]
DOALL:     	  %44 = icmp slt i64 %indvars.iv, %39
DOALL:     	  br i1 %44, label %45, label %59, !prof !41
DOALL:     	  %46 = trunc i64 %indvars.iv to i32
DOALL:     	  %47 = add nsw i32 %.0, %46
DOALL:     	  %48 = sext i32 %47 to i64
DOALL:     	  %49 = getelementptr inbounds [256 x [256 x [512 x %struct.dcomplex]]], [256 x [256 x [512 x %struct.dcomplex]]]* @main.u1, i64 0, i64 %indvars.iv7, i64 %indvars.iv13, i64 %48
DOALL:     	  %50 = bitcast %struct.dcomplex* %49 to i64*
DOALL:     	  %51 = load i64, i64* %50, align 16, !tbaa !42
DOALL:     	  %52 = getelementptr inbounds [512 x [18 x %struct.dcomplex]], [512 x [18 x %struct.dcomplex]]* %8, i64 0, i64 %indvars.iv7, i64 %indvars.iv
DOALL:     	  %53 = bitcast %struct.dcomplex* %52 to i64*
DOALL:     	  store i64 %51, i64* %53, align 16, !tbaa !42
DOALL:     	  %55 = bitcast double* %54 to i64*
DOALL:     	  %56 = load i64, i64* %55, align 8, !tbaa !45
DOALL:     	  %57 = getelementptr inbounds [512 x [18 x %struct.dcomplex]], [512 x [18 x %struct.dcomplex]]* %8, i64 0, i64 %indvars.iv7, i64 %indvars.iv, i32 1
DOALL:     	  %58 = bitcast double* %57 to i64*
DOALL:     	  store i64 %56, i64* %58, align 8, !tbaa !45
DOALL:     	  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
DOALL:     	  %indvars.iv.next8 = add nuw nsw i64 %indvars.iv7, 1
DOALL:     	  call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23)
DOALL:     	  %61 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 2
DOALL:     	  %62 = load i32, i32* %61, align 8, !tbaa !34
DOALL:     	  %63 = load i32, i32* @fftblock, align 4
DOALL:     	  %64 = sext i32 %63 to i64
DOALL:     	  %65 = sext i32 %.0 to i64
DOALL:     	  %66 = sext i32 %62 to i64
DOALL:     	  %indvars.iv11 = phi i64 [ %indvars.iv.next12, %83 ], [ 0, %60 ]
DOALL:     	  %68 = icmp slt i64 %indvars.iv11, %66
DOALL:     	  br i1 %68, label %.preheader, label %84, !prof !40
DOALL:     	  %indvars.iv9 = phi i64 [ %indvars.iv.next10, %71 ], [ 0, %.preheader ]
DOALL:     	  %70 = icmp slt i64 %indvars.iv9, %64
DOALL:     	  br i1 %70, label %71, label %83, !prof !41
DOALL:     	  %72 = getelementptr inbounds [512 x [18 x %struct.dcomplex]], [512 x [18 x %struct.dcomplex]]* %8, i64 0, i64 %indvars.iv11, i64 %indvars.iv9
DOALL:     	  %73 = bitcast %struct.dcomplex* %72 to i64*
DOALL:     	  %74 = load i64, i64* %73, align 16, !tbaa !42
DOALL:     	  %75 = add nsw i64 %indvars.iv9, %65
DOALL:     	  %76 = getelementptr inbounds [256 x [512 x %struct.dcomplex]], [256 x [512 x %struct.dcomplex]]* %3, i64 %indvars.iv11, i64 %indvars.iv13, i64 %75
DOALL:     	  %77 = bitcast %struct.dcomplex* %76 to i64*
DOALL:     	  store i64 %74, i64* %77, align 8, !tbaa !42
DOALL:     	  %78 = getelementptr inbounds [512 x [18 x %struct.dcomplex]], [512 x [18 x %struct.dcomplex]]* %8, i64 0, i64 %indvars.iv11, i64 %indvars.iv9, i32 1
DOALL:     	  %79 = bitcast double* %78 to i64*
DOALL:     	  %80 = load i64, i64* %79, align 8, !tbaa !45
DOALL:     	  %81 = getelementptr inbounds [256 x [512 x %struct.dcomplex]], [256 x [512 x %struct.dcomplex]]* %3, i64 %indvars.iv11, i64 %indvars.iv13, i64 %75, i32 1
DOALL:     	  %82 = bitcast double* %81 to i64*
DOALL:     	  store i64 %80, i64* %82, align 8, !tbaa !45
DOALL:     	  %indvars.iv.next10 = add nuw nsw i64 %indvars.iv9, 1
DOALL:     	  %indvars.iv.next12 = add nuw nsw i64 %indvars.iv11, 1
DOALL:     	  %85 = add nsw i32 %.0, %63
DOALL:     External nodes: 13
DOALL:     	  %indvars.iv13 = phi i64 [ %indvars.iv.next14, %86 ], [ 0, %17 ]
DOALL:     	  %26 = load i32, i32* %25, align 4, !tbaa !34
DOALL:     	  br i1 %28, label %29, label %87, !prof !38
DOALL:     	  %.pre = load i32, i32* @fftblock, align 4, !tbaa !34
DOALL:     	  br label %41
DOALL:     	  br label %43
DOALL:     	  br label %43
DOALL:     	  br label %41
DOALL:     	  br label %67
DOALL:     	  br label %69
DOALL:     	  br label %69
DOALL:     	  br label %67
DOALL:     	  br label %30
DOALL:     Edges: 237
DOALL:     Loop-carried data dependences
DOALL:         %51 = load i64, i64* %50, align 16, !tbaa !42 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %51 = load i64, i64* %50, align 16, !tbaa !42 --->   store i64 %80, i64* %82, align 8, !tbaa !45 via memory
DOALL:         %51 = load i64, i64* %50, align 16, !tbaa !42 --->   store i64 %74, i64* %77, align 8, !tbaa !42 via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   %80 = load i64, i64* %79, align 8, !tbaa !45 via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   %74 = load i64, i64* %73, align 16, !tbaa !42 via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %56 = load i64, i64* %55, align 8, !tbaa !45 --->   store i64 %80, i64* %82, align 8, !tbaa !45 via memory
DOALL:         %56 = load i64, i64* %55, align 8, !tbaa !45 --->   store i64 %74, i64* %77, align 8, !tbaa !42 via memory
DOALL:         %56 = load i64, i64* %55, align 8, !tbaa !45 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %56, i64* %58, align 8, !tbaa !45 --->   %80 = load i64, i64* %79, align 8, !tbaa !45 via memory
DOALL:         store i64 %56, i64* %58, align 8, !tbaa !45 --->   %74 = load i64, i64* %73, align 16, !tbaa !42 via memory
DOALL:         store i64 %56, i64* %58, align 8, !tbaa !45 --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         store i64 %56, i64* %58, align 8, !tbaa !45 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %56, i64* %58, align 8, !tbaa !45 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %56, i64* %58, align 8, !tbaa !45 --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   %74 = load i64, i64* %73, align 16, !tbaa !42 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %74, i64* %77, align 8, !tbaa !42 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %80, i64* %82, align 8, !tbaa !45 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %74, i64* %77, align 8, !tbaa !42 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   %80 = load i64, i64* %79, align 8, !tbaa !45 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %80, i64* %82, align 8, !tbaa !45 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         %62 = load i32, i32* %61, align 8, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %63 = load i32, i32* @fftblock, align 4 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %38 = load i32, i32* %37, align 8, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %.pre = load i32, i32* @fftblock, align 4, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %.pre = load i32, i32* @fftblock, align 4, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %26 = load i32, i32* %25, align 4, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %26 = load i32, i32* %25, align 4, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %74 = load i64, i64* %73, align 16, !tbaa !42 --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         %74 = load i64, i64* %73, align 16, !tbaa !42 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %74 = load i64, i64* %73, align 16, !tbaa !42 --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         store i64 %74, i64* %77, align 8, !tbaa !42 --->   store i64 %80, i64* %82, align 8, !tbaa !45 via memory
DOALL:         store i64 %74, i64* %77, align 8, !tbaa !42 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %74, i64* %77, align 8, !tbaa !42 --->   %56 = load i64, i64* %55, align 8, !tbaa !45 via memory
DOALL:         store i64 %74, i64* %77, align 8, !tbaa !42 --->   store i64 %74, i64* %77, align 8, !tbaa !42 via memory
DOALL:         store i64 %74, i64* %77, align 8, !tbaa !42 --->   %51 = load i64, i64* %50, align 16, !tbaa !42 via memory
DOALL:         store i64 %74, i64* %77, align 8, !tbaa !42 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %80 = load i64, i64* %79, align 8, !tbaa !45 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %80 = load i64, i64* %79, align 8, !tbaa !45 --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         %80 = load i64, i64* %79, align 8, !tbaa !45 --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         store i64 %80, i64* %82, align 8, !tbaa !45 --->   %51 = load i64, i64* %50, align 16, !tbaa !42 via memory
DOALL:         store i64 %80, i64* %82, align 8, !tbaa !45 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %80, i64* %82, align 8, !tbaa !45 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %80, i64* %82, align 8, !tbaa !45 --->   %56 = load i64, i64* %55, align 8, !tbaa !45 via memory
DOALL:         store i64 %80, i64* %82, align 8, !tbaa !45 --->   store i64 %74, i64* %77, align 8, !tbaa !42 via memory
DOALL:         store i64 %80, i64* %82, align 8, !tbaa !45 --->   store i64 %80, i64* %82, align 8, !tbaa !45 via memory
DOALL:         %33 = load i32, i32* %32, align 8, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 63
DOALL:     	  %54 = getelementptr inbounds [256 x [256 x [512 x %struct.dcomplex]]], [256 x [256 x [512 x %struct.dcomplex]]]* @main.u1, i64 0, i64 %indvars.iv7, i64 %indvars.iv13, i64 %48, i32 1
DOALL:     	  %31 = phi i32 [ %.pre, %29 ], [ %63, %84 ]
DOALL:     	  %.0 = phi i32 [ 0, %29 ], [ %85, %84 ]
DOALL:     	  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 0
DOALL:     	  %33 = load i32, i32* %32, align 8, !tbaa !34
DOALL:     	  %34 = sub nsw i32 %33, %31
DOALL:     	  %35 = icmp sgt i32 %.0, %34
DOALL:     	  br i1 %35, label %86, label %36, !prof !39
DOALL:     	  %37 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 2
DOALL:     	  %38 = load i32, i32* %37, align 8, !tbaa !34
DOALL:     	  %39 = sext i32 %31 to i64
DOALL:     	  %40 = sext i32 %38 to i64
DOALL:     	  %indvars.iv7 = phi i64 [ %indvars.iv.next8, %59 ], [ 0, %36 ]
DOALL:     	  %42 = icmp slt i64 %indvars.iv7, %40
DOALL:     	  br i1 %42, label %.preheader1, label %60, !prof !40
DOALL:     	  %indvars.iv = phi i64 [ %indvars.iv.next, %45 ], [ 0, %.preheader1 ]
DOALL:     	  %44 = icmp slt i64 %indvars.iv, %39
DOALL:     	  br i1 %44, label %45, label %59, !prof !41
DOALL:     	  %46 = trunc i64 %indvars.iv to i32
DOALL:     	  %47 = add nsw i32 %.0, %46
DOALL:     	  %48 = sext i32 %47 to i64
DOALL:     	  %49 = getelementptr inbounds [256 x [256 x [512 x %struct.dcomplex]]], [256 x [256 x [512 x %struct.dcomplex]]]* @main.u1, i64 0, i64 %indvars.iv7, i64 %indvars.iv13, i64 %48
DOALL:     	  %50 = bitcast %struct.dcomplex* %49 to i64*
DOALL:     	  %51 = load i64, i64* %50, align 16, !tbaa !42
DOALL:     	  %52 = getelementptr inbounds [512 x [18 x %struct.dcomplex]], [512 x [18 x %struct.dcomplex]]* %8, i64 0, i64 %indvars.iv7, i64 %indvars.iv
DOALL:     	  %53 = bitcast %struct.dcomplex* %52 to i64*
DOALL:     	  store i64 %51, i64* %53, align 16, !tbaa !42
DOALL:     	  %55 = bitcast double* %54 to i64*
DOALL:     	  %56 = load i64, i64* %55, align 8, !tbaa !45
DOALL:     	  %57 = getelementptr inbounds [512 x [18 x %struct.dcomplex]], [512 x [18 x %struct.dcomplex]]* %8, i64 0, i64 %indvars.iv7, i64 %indvars.iv, i32 1
DOALL:     	  %58 = bitcast double* %57 to i64*
DOALL:     	  store i64 %56, i64* %58, align 8, !tbaa !45
DOALL:     	  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
DOALL:     	  %indvars.iv.next8 = add nuw nsw i64 %indvars.iv7, 1
DOALL:     	  call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23)
DOALL:     	  %61 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 2
DOALL:     	  %62 = load i32, i32* %61, align 8, !tbaa !34
DOALL:     	  %63 = load i32, i32* @fftblock, align 4
DOALL:     	  %64 = sext i32 %63 to i64
DOALL:     	  %65 = sext i32 %.0 to i64
DOALL:     	  %66 = sext i32 %62 to i64
DOALL:     	  %indvars.iv11 = phi i64 [ %indvars.iv.next12, %83 ], [ 0, %60 ]
DOALL:     	  %68 = icmp slt i64 %indvars.iv11, %66
DOALL:     	  br i1 %68, label %.preheader, label %84, !prof !40
DOALL:     	  %indvars.iv9 = phi i64 [ %indvars.iv.next10, %71 ], [ 0, %.preheader ]
DOALL:     	  %70 = icmp slt i64 %indvars.iv9, %64
DOALL:     	  br i1 %70, label %71, label %83, !prof !41
DOALL:     	  %72 = getelementptr inbounds [512 x [18 x %struct.dcomplex]], [512 x [18 x %struct.dcomplex]]* %8, i64 0, i64 %indvars.iv11, i64 %indvars.iv9
DOALL:     	  %73 = bitcast %struct.dcomplex* %72 to i64*
DOALL:     	  %74 = load i64, i64* %73, align 16, !tbaa !42
DOALL:     	  %75 = add nsw i64 %indvars.iv9, %65
DOALL:     	  %76 = getelementptr inbounds [256 x [512 x %struct.dcomplex]], [256 x [512 x %struct.dcomplex]]* %3, i64 %indvars.iv11, i64 %indvars.iv13, i64 %75
DOALL:     	  %77 = bitcast %struct.dcomplex* %76 to i64*
DOALL:     	  store i64 %74, i64* %77, align 8, !tbaa !42
DOALL:     	  %78 = getelementptr inbounds [512 x [18 x %struct.dcomplex]], [512 x [18 x %struct.dcomplex]]* %8, i64 0, i64 %indvars.iv11, i64 %indvars.iv9, i32 1
DOALL:     	  %79 = bitcast double* %78 to i64*
DOALL:     	  %80 = load i64, i64* %79, align 8, !tbaa !45
DOALL:     	  %81 = getelementptr inbounds [256 x [512 x %struct.dcomplex]], [256 x [512 x %struct.dcomplex]]* %3, i64 %indvars.iv11, i64 %indvars.iv13, i64 %75, i32 1
DOALL:     	  %82 = bitcast double* %81 to i64*
DOALL:     	  store i64 %80, i64* %82, align 8, !tbaa !45
DOALL:     	  %indvars.iv.next10 = add nuw nsw i64 %indvars.iv9, 1
DOALL:     	  %indvars.iv.next12 = add nuw nsw i64 %indvars.iv11, 1
DOALL:     	  %85 = add nsw i32 %.0, %63
DOALL:     External nodes: 9
DOALL:     	  br label %41
DOALL:     	  br label %43
DOALL:     	  br label %43
DOALL:     	  br label %41
DOALL:     	  br label %67
DOALL:     	  br label %69
DOALL:     	  br label %69
DOALL:     	  br label %67
DOALL:     	  br label %30
DOALL:     Edges: 219
DOALL:     Loop-carried data dependences
DOALL:         %51 = load i64, i64* %50, align 16, !tbaa !42 --->   store i64 %80, i64* %82, align 8, !tbaa !45 via memory
DOALL:         %51 = load i64, i64* %50, align 16, !tbaa !42 --->   store i64 %74, i64* %77, align 8, !tbaa !42 via memory
DOALL:         %51 = load i64, i64* %50, align 16, !tbaa !42 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %80, i64* %82, align 8, !tbaa !45 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %74 = load i64, i64* %73, align 16, !tbaa !42 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %74 = load i64, i64* %73, align 16, !tbaa !42 --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         %74 = load i64, i64* %73, align 16, !tbaa !42 --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         %85 = add nsw i32 %.0, %63 --->   %.0 = phi i32 [ 0, %29 ], [ %85, %84 ] via variable
DOALL:         %33 = load i32, i32* %32, align 8, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %38 = load i32, i32* %37, align 8, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   %74 = load i64, i64* %73, align 16, !tbaa !42 via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   %80 = load i64, i64* %79, align 8, !tbaa !45 via memory
DOALL:         %62 = load i32, i32* %61, align 8, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %63 = load i32, i32* @fftblock, align 4 --->   %31 = phi i32 [ %.pre, %29 ], [ %63, %84 ] via variable
DOALL:         %63 = load i32, i32* @fftblock, align 4 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %80, i64* %82, align 8, !tbaa !45 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %80, i64* %82, align 8, !tbaa !45 --->   store i64 %80, i64* %82, align 8, !tbaa !45 via memory
DOALL:         store i64 %80, i64* %82, align 8, !tbaa !45 --->   %56 = load i64, i64* %55, align 8, !tbaa !45 via memory
DOALL:         store i64 %80, i64* %82, align 8, !tbaa !45 --->   %51 = load i64, i64* %50, align 16, !tbaa !42 via memory
DOALL:         store i64 %80, i64* %82, align 8, !tbaa !45 --->   store i64 %74, i64* %77, align 8, !tbaa !42 via memory
DOALL:         store i64 %56, i64* %58, align 8, !tbaa !45 --->   %74 = load i64, i64* %73, align 16, !tbaa !42 via memory
DOALL:         store i64 %56, i64* %58, align 8, !tbaa !45 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %56, i64* %58, align 8, !tbaa !45 --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         store i64 %56, i64* %58, align 8, !tbaa !45 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %56, i64* %58, align 8, !tbaa !45 --->   %80 = load i64, i64* %79, align 8, !tbaa !45 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %80, i64* %82, align 8, !tbaa !45 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %74, i64* %77, align 8, !tbaa !42 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %80, i64* %82, align 8, !tbaa !45 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         store i64 %74, i64* %77, align 8, !tbaa !42 --->   %51 = load i64, i64* %50, align 16, !tbaa !42 via memory
DOALL:         store i64 %74, i64* %77, align 8, !tbaa !42 --->   store i64 %80, i64* %82, align 8, !tbaa !45 via memory
DOALL:         store i64 %74, i64* %77, align 8, !tbaa !42 --->   %56 = load i64, i64* %55, align 8, !tbaa !45 via memory
DOALL:         store i64 %74, i64* %77, align 8, !tbaa !42 --->   store i64 %74, i64* %77, align 8, !tbaa !42 via memory
DOALL:         store i64 %74, i64* %77, align 8, !tbaa !42 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %74, i64* %77, align 8, !tbaa !42 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %80 = load i64, i64* %79, align 8, !tbaa !45 --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         %80 = load i64, i64* %79, align 8, !tbaa !45 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %80 = load i64, i64* %79, align 8, !tbaa !45 --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         %56 = load i64, i64* %55, align 8, !tbaa !45 --->   store i64 %74, i64* %77, align 8, !tbaa !42 via memory
DOALL:         %56 = load i64, i64* %55, align 8, !tbaa !45 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %56 = load i64, i64* %55, align 8, !tbaa !45 --->   store i64 %80, i64* %82, align 8, !tbaa !45 via memory
DOALL:         store i64 %56, i64* %58, align 8, !tbaa !45 --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   %80 = load i64, i64* %79, align 8, !tbaa !45 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   %74 = load i64, i64* %73, align 16, !tbaa !42 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %74, i64* %77, align 8, !tbaa !42 via memory
Inliner:   Inlining in: cffts3 (111 instructions. The inlining will add 340 instructions),   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23)
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject:   It requires initialization
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
MemoryCloningAnalysis:     The private copies need to be initialized with the original object.
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 1
DOALL:     	  %.pre = load i32, i32* @fftblock, align 4, !tbaa !34
DOALL:     External nodes: 3
DOALL:     	  call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23)
DOALL:     	  br i1 %28, label %29, label %87, !prof !38
DOALL:     	  %31 = phi i32 [ %.pre, %29 ], [ %63, %84 ]
DOALL:     Edges: 3
DOALL:     Loop-carried data dependences
DOALL:         %.pre = load i32, i32* @fftblock, align 4, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %.pre = load i32, i32* @fftblock, align 4, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 63
DOALL:     	  %48 = sext i32 %47 to i64
DOALL:     	  %49 = getelementptr inbounds [256 x [256 x [512 x %struct.dcomplex]]], [256 x [256 x [512 x %struct.dcomplex]]]* @main.u1, i64 0, i64 %indvars.iv13, i64 %indvars.iv7, i64 %48
DOALL:     	  %50 = bitcast %struct.dcomplex* %49 to i64*
DOALL:     	  %51 = load i64, i64* %50, align 16, !tbaa !42
DOALL:     	  %52 = getelementptr inbounds [512 x [18 x %struct.dcomplex]], [512 x [18 x %struct.dcomplex]]* %8, i64 0, i64 %indvars.iv7, i64 %indvars.iv
DOALL:     	  %53 = bitcast %struct.dcomplex* %52 to i64*
DOALL:     	  store i64 %51, i64* %53, align 16, !tbaa !42
DOALL:     	  %55 = bitcast double* %54 to i64*
DOALL:     	  %56 = load i64, i64* %55, align 8, !tbaa !45
DOALL:     	  %57 = getelementptr inbounds [512 x [18 x %struct.dcomplex]], [512 x [18 x %struct.dcomplex]]* %8, i64 0, i64 %indvars.iv7, i64 %indvars.iv, i32 1
DOALL:     	  %58 = bitcast double* %57 to i64*
DOALL:     	  store i64 %56, i64* %58, align 8, !tbaa !45
DOALL:     	  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
DOALL:     	  %indvars.iv.next8 = add nuw nsw i64 %indvars.iv7, 1
DOALL:     	  call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23)
DOALL:     	  %61 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 1
DOALL:     	  %62 = load i32, i32* %61, align 4, !tbaa !34
DOALL:     	  %63 = load i32, i32* @fftblock, align 4
DOALL:     	  %64 = sext i32 %63 to i64
DOALL:     	  %65 = sext i32 %.0 to i64
DOALL:     	  %66 = sext i32 %62 to i64
DOALL:     	  %indvars.iv11 = phi i64 [ %indvars.iv.next12, %83 ], [ 0, %60 ]
DOALL:     	  %68 = icmp slt i64 %indvars.iv11, %66
DOALL:     	  br i1 %68, label %.preheader, label %84, !prof !40
DOALL:     	  %indvars.iv9 = phi i64 [ %indvars.iv.next10, %71 ], [ 0, %.preheader ]
DOALL:     	  %70 = icmp slt i64 %indvars.iv9, %64
DOALL:     	  br i1 %70, label %71, label %83, !prof !41
DOALL:     	  %72 = getelementptr inbounds [512 x [18 x %struct.dcomplex]], [512 x [18 x %struct.dcomplex]]* %8, i64 0, i64 %indvars.iv11, i64 %indvars.iv9
DOALL:     	  %73 = bitcast %struct.dcomplex* %72 to i64*
DOALL:     	  %74 = load i64, i64* %73, align 16, !tbaa !42
DOALL:     	  %75 = add nsw i64 %indvars.iv9, %65
DOALL:     	  %76 = getelementptr inbounds [256 x [256 x [512 x %struct.dcomplex]]], [256 x [256 x [512 x %struct.dcomplex]]]* @main.u1, i64 0, i64 %indvars.iv13, i64 %indvars.iv11, i64 %75
DOALL:     	  %77 = bitcast %struct.dcomplex* %76 to i64*
DOALL:     	  store i64 %74, i64* %77, align 16, !tbaa !42
DOALL:     	  %78 = getelementptr inbounds [512 x [18 x %struct.dcomplex]], [512 x [18 x %struct.dcomplex]]* %8, i64 0, i64 %indvars.iv11, i64 %indvars.iv9, i32 1
DOALL:     	  %79 = bitcast double* %78 to i64*
DOALL:     	  %80 = load i64, i64* %79, align 8, !tbaa !45
DOALL:     	  %81 = getelementptr inbounds [256 x [256 x [512 x %struct.dcomplex]]], [256 x [256 x [512 x %struct.dcomplex]]]* @main.u1, i64 0, i64 %indvars.iv13, i64 %indvars.iv11, i64 %75, i32 1
DOALL:     	  %82 = bitcast double* %81 to i64*
DOALL:     	  store i64 %80, i64* %82, align 8, !tbaa !45
DOALL:     	  %indvars.iv.next10 = add nuw nsw i64 %indvars.iv9, 1
DOALL:     	  %indvars.iv.next12 = add nuw nsw i64 %indvars.iv11, 1
DOALL:     	  %85 = add nsw i32 %.0, %63
DOALL:     	  %54 = getelementptr inbounds [256 x [256 x [512 x %struct.dcomplex]]], [256 x [256 x [512 x %struct.dcomplex]]]* @main.u1, i64 0, i64 %indvars.iv13, i64 %indvars.iv7, i64 %48, i32 1
DOALL:     	  %31 = phi i32 [ %.pre, %29 ], [ %63, %84 ]
DOALL:     	  %.0 = phi i32 [ 0, %29 ], [ %85, %84 ]
DOALL:     	  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 0
DOALL:     	  %33 = load i32, i32* %32, align 4, !tbaa !34
DOALL:     	  %34 = sub nsw i32 %33, %31
DOALL:     	  %35 = icmp sgt i32 %.0, %34
DOALL:     	  br i1 %35, label %86, label %36, !prof !39
DOALL:     	  %37 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 1
DOALL:     	  %38 = load i32, i32* %37, align 4, !tbaa !34
DOALL:     	  %39 = sext i32 %31 to i64
DOALL:     	  %40 = sext i32 %38 to i64
DOALL:     	  %indvars.iv7 = phi i64 [ %indvars.iv.next8, %59 ], [ 0, %36 ]
DOALL:     	  %42 = icmp slt i64 %indvars.iv7, %40
DOALL:     	  br i1 %42, label %.preheader1, label %60, !prof !40
DOALL:     	  %indvars.iv = phi i64 [ %indvars.iv.next, %45 ], [ 0, %.preheader1 ]
DOALL:     	  %44 = icmp slt i64 %indvars.iv, %39
DOALL:     	  br i1 %44, label %45, label %59, !prof !41
DOALL:     	  %46 = trunc i64 %indvars.iv to i32
DOALL:     	  %47 = add nsw i32 %.0, %46
DOALL:     External nodes: 13
DOALL:     	  br label %43
DOALL:     	  br label %41
DOALL:     	  br label %67
DOALL:     	  br label %69
DOALL:     	  br label %69
DOALL:     	  br label %67
DOALL:     	  br label %30
DOALL:     	  %indvars.iv13 = phi i64 [ %indvars.iv.next14, %86 ], [ 0, %17 ]
DOALL:     	  %26 = load i32, i32* %25, align 4, !tbaa !34
DOALL:     	  br i1 %28, label %29, label %87, !prof !38
DOALL:     	  %.pre = load i32, i32* @fftblock, align 4, !tbaa !34
DOALL:     	  br label %41
DOALL:     	  br label %43
DOALL:     Edges: 231
DOALL:     Loop-carried data dependences
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %80, i64* %82, align 8, !tbaa !45 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %74, i64* %77, align 16, !tbaa !42 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %80, i64* %82, align 8, !tbaa !45 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %74, i64* %77, align 16, !tbaa !42 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %62 = load i32, i32* %61, align 4, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %63 = load i32, i32* @fftblock, align 4 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %38 = load i32, i32* %37, align 4, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %51 = load i64, i64* %50, align 16, !tbaa !42 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   %80 = load i64, i64* %79, align 8, !tbaa !45 via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   %74 = load i64, i64* %73, align 16, !tbaa !42 via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         %56 = load i64, i64* %55, align 8, !tbaa !45 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %56, i64* %58, align 8, !tbaa !45 --->   %80 = load i64, i64* %79, align 8, !tbaa !45 via memory
DOALL:         store i64 %56, i64* %58, align 8, !tbaa !45 --->   %74 = load i64, i64* %73, align 16, !tbaa !42 via memory
DOALL:         store i64 %56, i64* %58, align 8, !tbaa !45 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %56, i64* %58, align 8, !tbaa !45 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %56, i64* %58, align 8, !tbaa !45 --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         store i64 %56, i64* %58, align 8, !tbaa !45 --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   %74 = load i64, i64* %73, align 16, !tbaa !42 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   %80 = load i64, i64* %79, align 8, !tbaa !45 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         %.pre = load i32, i32* @fftblock, align 4, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %26 = load i32, i32* %25, align 4, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %26 = load i32, i32* %25, align 4, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %74 = load i64, i64* %73, align 16, !tbaa !42 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %74 = load i64, i64* %73, align 16, !tbaa !42 --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         %74 = load i64, i64* %73, align 16, !tbaa !42 --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         %80 = load i64, i64* %79, align 8, !tbaa !45 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %80 = load i64, i64* %79, align 8, !tbaa !45 --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         %80 = load i64, i64* %79, align 8, !tbaa !45 --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         %33 = load i32, i32* %32, align 4, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %.pre = load i32, i32* @fftblock, align 4, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 63
DOALL:     	  %48 = sext i32 %47 to i64
DOALL:     	  %49 = getelementptr inbounds [256 x [256 x [512 x %struct.dcomplex]]], [256 x [256 x [512 x %struct.dcomplex]]]* @main.u1, i64 0, i64 %indvars.iv13, i64 %indvars.iv7, i64 %48
DOALL:     	  %50 = bitcast %struct.dcomplex* %49 to i64*
DOALL:     	  %51 = load i64, i64* %50, align 16, !tbaa !42
DOALL:     	  %52 = getelementptr inbounds [512 x [18 x %struct.dcomplex]], [512 x [18 x %struct.dcomplex]]* %8, i64 0, i64 %indvars.iv7, i64 %indvars.iv
DOALL:     	  %53 = bitcast %struct.dcomplex* %52 to i64*
DOALL:     	  store i64 %51, i64* %53, align 16, !tbaa !42
DOALL:     	  %55 = bitcast double* %54 to i64*
DOALL:     	  %56 = load i64, i64* %55, align 8, !tbaa !45
DOALL:     	  %57 = getelementptr inbounds [512 x [18 x %struct.dcomplex]], [512 x [18 x %struct.dcomplex]]* %8, i64 0, i64 %indvars.iv7, i64 %indvars.iv, i32 1
DOALL:     	  %58 = bitcast double* %57 to i64*
DOALL:     	  store i64 %56, i64* %58, align 8, !tbaa !45
DOALL:     	  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
DOALL:     	  %indvars.iv.next8 = add nuw nsw i64 %indvars.iv7, 1
DOALL:     	  call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23)
DOALL:     	  %61 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 1
DOALL:     	  %62 = load i32, i32* %61, align 4, !tbaa !34
DOALL:     	  %63 = load i32, i32* @fftblock, align 4
DOALL:     	  %64 = sext i32 %63 to i64
DOALL:     	  %65 = sext i32 %.0 to i64
DOALL:     	  %66 = sext i32 %62 to i64
DOALL:     	  %indvars.iv11 = phi i64 [ %indvars.iv.next12, %83 ], [ 0, %60 ]
DOALL:     	  %68 = icmp slt i64 %indvars.iv11, %66
DOALL:     	  br i1 %68, label %.preheader, label %84, !prof !40
DOALL:     	  %indvars.iv9 = phi i64 [ %indvars.iv.next10, %71 ], [ 0, %.preheader ]
DOALL:     	  %70 = icmp slt i64 %indvars.iv9, %64
DOALL:     	  br i1 %70, label %71, label %83, !prof !41
DOALL:     	  %72 = getelementptr inbounds [512 x [18 x %struct.dcomplex]], [512 x [18 x %struct.dcomplex]]* %8, i64 0, i64 %indvars.iv11, i64 %indvars.iv9
DOALL:     	  %73 = bitcast %struct.dcomplex* %72 to i64*
DOALL:     	  %74 = load i64, i64* %73, align 16, !tbaa !42
DOALL:     	  %75 = add nsw i64 %indvars.iv9, %65
DOALL:     	  %76 = getelementptr inbounds [256 x [256 x [512 x %struct.dcomplex]]], [256 x [256 x [512 x %struct.dcomplex]]]* @main.u1, i64 0, i64 %indvars.iv13, i64 %indvars.iv11, i64 %75
DOALL:     	  %77 = bitcast %struct.dcomplex* %76 to i64*
DOALL:     	  store i64 %74, i64* %77, align 16, !tbaa !42
DOALL:     	  %78 = getelementptr inbounds [512 x [18 x %struct.dcomplex]], [512 x [18 x %struct.dcomplex]]* %8, i64 0, i64 %indvars.iv11, i64 %indvars.iv9, i32 1
DOALL:     	  %79 = bitcast double* %78 to i64*
DOALL:     	  %80 = load i64, i64* %79, align 8, !tbaa !45
DOALL:     	  %81 = getelementptr inbounds [256 x [256 x [512 x %struct.dcomplex]]], [256 x [256 x [512 x %struct.dcomplex]]]* @main.u1, i64 0, i64 %indvars.iv13, i64 %indvars.iv11, i64 %75, i32 1
DOALL:     	  %82 = bitcast double* %81 to i64*
DOALL:     	  store i64 %80, i64* %82, align 8, !tbaa !45
DOALL:     	  %indvars.iv.next10 = add nuw nsw i64 %indvars.iv9, 1
DOALL:     	  %indvars.iv.next12 = add nuw nsw i64 %indvars.iv11, 1
DOALL:     	  %85 = add nsw i32 %.0, %63
DOALL:     	  %54 = getelementptr inbounds [256 x [256 x [512 x %struct.dcomplex]]], [256 x [256 x [512 x %struct.dcomplex]]]* @main.u1, i64 0, i64 %indvars.iv13, i64 %indvars.iv7, i64 %48, i32 1
DOALL:     	  %31 = phi i32 [ %.pre, %29 ], [ %63, %84 ]
DOALL:     	  %.0 = phi i32 [ 0, %29 ], [ %85, %84 ]
DOALL:     	  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 0
DOALL:     	  %33 = load i32, i32* %32, align 4, !tbaa !34
DOALL:     	  %34 = sub nsw i32 %33, %31
DOALL:     	  %35 = icmp sgt i32 %.0, %34
DOALL:     	  br i1 %35, label %86, label %36, !prof !39
DOALL:     	  %37 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 1
DOALL:     	  %38 = load i32, i32* %37, align 4, !tbaa !34
DOALL:     	  %39 = sext i32 %31 to i64
DOALL:     	  %40 = sext i32 %38 to i64
DOALL:     	  %indvars.iv7 = phi i64 [ %indvars.iv.next8, %59 ], [ 0, %36 ]
DOALL:     	  %42 = icmp slt i64 %indvars.iv7, %40
DOALL:     	  br i1 %42, label %.preheader1, label %60, !prof !40
DOALL:     	  %indvars.iv = phi i64 [ %indvars.iv.next, %45 ], [ 0, %.preheader1 ]
DOALL:     	  %44 = icmp slt i64 %indvars.iv, %39
DOALL:     	  br i1 %44, label %45, label %59, !prof !41
DOALL:     	  %46 = trunc i64 %indvars.iv to i32
DOALL:     	  %47 = add nsw i32 %.0, %46
DOALL:     External nodes: 9
DOALL:     	  br label %43
DOALL:     	  br label %41
DOALL:     	  br label %67
DOALL:     	  br label %69
DOALL:     	  br label %69
DOALL:     	  br label %67
DOALL:     	  br label %30
DOALL:     	  br label %41
DOALL:     	  br label %43
DOALL:     Edges: 215
DOALL:     Loop-carried data dependences
DOALL:         %56 = load i64, i64* %55, align 8, !tbaa !45 --->   store i64 %80, i64* %82, align 8, !tbaa !45 via memory
DOALL:         %33 = load i32, i32* %32, align 4, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %38 = load i32, i32* %37, align 4, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %56 = load i64, i64* %55, align 8, !tbaa !45 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %56, i64* %58, align 8, !tbaa !45 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %56, i64* %58, align 8, !tbaa !45 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %56, i64* %58, align 8, !tbaa !45 --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         store i64 %56, i64* %58, align 8, !tbaa !45 --->   %74 = load i64, i64* %73, align 16, !tbaa !42 via memory
DOALL:         store i64 %56, i64* %58, align 8, !tbaa !45 --->   %80 = load i64, i64* %79, align 8, !tbaa !45 via memory
DOALL:         store i64 %56, i64* %58, align 8, !tbaa !45 --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   %74 = load i64, i64* %73, align 16, !tbaa !42 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %80, i64* %82, align 8, !tbaa !45 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %74, i64* %77, align 16, !tbaa !42 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %74, i64* %77, align 16, !tbaa !42 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   %80 = load i64, i64* %79, align 8, !tbaa !45 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %80, i64* %82, align 8, !tbaa !45 via memory
DOALL:         %62 = load i32, i32* %61, align 4, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %63 = load i32, i32* @fftblock, align 4 --->   %31 = phi i32 [ %.pre, %29 ], [ %63, %84 ] via variable
DOALL:         %63 = load i32, i32* @fftblock, align 4 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %74 = load i64, i64* %73, align 16, !tbaa !42 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %74 = load i64, i64* %73, align 16, !tbaa !42 --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         %74 = load i64, i64* %73, align 16, !tbaa !42 --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         store i64 %74, i64* %77, align 16, !tbaa !42 --->   %51 = load i64, i64* %50, align 16, !tbaa !42 via memory
DOALL:         store i64 %74, i64* %77, align 16, !tbaa !42 --->   %56 = load i64, i64* %55, align 8, !tbaa !45 via memory
DOALL:         store i64 %74, i64* %77, align 16, !tbaa !42 --->   store i64 %74, i64* %77, align 16, !tbaa !42 via memory
DOALL:         store i64 %74, i64* %77, align 16, !tbaa !42 --->   store i64 %80, i64* %82, align 8, !tbaa !45 via memory
DOALL:         %80 = load i64, i64* %79, align 8, !tbaa !45 --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         %80 = load i64, i64* %79, align 8, !tbaa !45 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %80 = load i64, i64* %79, align 8, !tbaa !45 --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         store i64 %80, i64* %82, align 8, !tbaa !45 --->   %56 = load i64, i64* %55, align 8, !tbaa !45 via memory
DOALL:         store i64 %80, i64* %82, align 8, !tbaa !45 --->   store i64 %74, i64* %77, align 16, !tbaa !42 via memory
DOALL:         store i64 %80, i64* %82, align 8, !tbaa !45 --->   %51 = load i64, i64* %50, align 16, !tbaa !42 via memory
DOALL:         store i64 %80, i64* %82, align 8, !tbaa !45 --->   store i64 %80, i64* %82, align 8, !tbaa !45 via memory
DOALL:         %85 = add nsw i32 %.0, %63 --->   %.0 = phi i32 [ 0, %29 ], [ %85, %84 ] via variable
DOALL:         %51 = load i64, i64* %50, align 16, !tbaa !42 --->   store i64 %80, i64* %82, align 8, !tbaa !45 via memory
DOALL:         %51 = load i64, i64* %50, align 16, !tbaa !42 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %51 = load i64, i64* %50, align 16, !tbaa !42 --->   store i64 %74, i64* %77, align 16, !tbaa !42 via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   %74 = load i64, i64* %73, align 16, !tbaa !42 via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   %80 = load i64, i64* %79, align 8, !tbaa !45 via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %56 = load i64, i64* %55, align 8, !tbaa !45 --->   store i64 %74, i64* %77, align 16, !tbaa !42 via memory
Inliner:   Inlining in: cffts2 (111 instructions. The inlining will add 340 instructions),   call fastcc void @cfftz(i32 %0, i32 %21, i32 %38, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23)
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject:   It requires initialization
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
MemoryCloningAnalysis:     The private copies need to be initialized with the original object.
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 1
DOALL:     	  %.pre = load i32, i32* @fftblock, align 4, !tbaa !34
DOALL:     External nodes: 3
DOALL:     	  br i1 %28, label %29, label %88, !prof !38
DOALL:     	  %31 = phi i32 [ %.pre, %29 ], [ %61, %85 ]
DOALL:     	  call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23)
DOALL:     Edges: 3
DOALL:     Loop-carried data dependences
DOALL:         %.pre = load i32, i32* @fftblock, align 4, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %.pre = load i32, i32* @fftblock, align 4, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 63
DOALL:     	  %54 = getelementptr inbounds [256 x [256 x [512 x %struct.dcomplex]]], [256 x [256 x [512 x %struct.dcomplex]]]* @main.u1, i64 0, i64 %indvars.iv12, i64 %45, i64 %indvars.iv, i32 1
DOALL:     	  %31 = phi i32 [ %.pre, %29 ], [ %61, %85 ]
DOALL:     	  %.0 = phi i32 [ 0, %29 ], [ %86, %85 ]
DOALL:     	  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 1
DOALL:     	  %33 = load i32, i32* %32, align 4, !tbaa !34
DOALL:     	  %34 = sub nsw i32 %33, %31
DOALL:     	  %35 = icmp sgt i32 %.0, %34
DOALL:     	  br i1 %35, label %87, label %.preheader, !prof !39
DOALL:     	  %36 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 0
DOALL:     	  %37 = load i32, i32* %36, align 16, !tbaa !34
DOALL:     	  %38 = sext i32 %37 to i64
DOALL:     	  %39 = sext i32 %31 to i64
DOALL:     	  %indvars.iv6 = phi i64 [ 0, %.preheader ], [ %indvars.iv.next7, %59 ]
DOALL:     	  %41 = icmp slt i64 %indvars.iv6, %39
DOALL:     	  br i1 %41, label %42, label %60, !prof !40
DOALL:     	  %43 = trunc i64 %indvars.iv6 to i32
DOALL:     	  %44 = add nsw i32 %.0, %43
DOALL:     	  %45 = sext i32 %44 to i64
DOALL:     	  %indvars.iv = phi i64 [ %indvars.iv.next, %48 ], [ 0, %42 ]
DOALL:     	  %47 = icmp slt i64 %indvars.iv, %38
DOALL:     	  br i1 %47, label %48, label %59, !prof !41
DOALL:     	  %49 = getelementptr inbounds [256 x [256 x [512 x %struct.dcomplex]]], [256 x [256 x [512 x %struct.dcomplex]]]* @main.u1, i64 0, i64 %indvars.iv12, i64 %45, i64 %indvars.iv
DOALL:     	  %50 = bitcast %struct.dcomplex* %49 to i64*
DOALL:     	  %51 = load i64, i64* %50, align 16, !tbaa !42
DOALL:     	  %52 = getelementptr inbounds [512 x [18 x %struct.dcomplex]], [512 x [18 x %struct.dcomplex]]* %8, i64 0, i64 %indvars.iv, i64 %indvars.iv6
DOALL:     	  %53 = bitcast %struct.dcomplex* %52 to i64*
DOALL:     	  store i64 %51, i64* %53, align 16, !tbaa !42
DOALL:     	  %55 = bitcast double* %54 to i64*
DOALL:     	  %56 = load i64, i64* %55, align 8, !tbaa !45
DOALL:     	  %57 = getelementptr inbounds [512 x [18 x %struct.dcomplex]], [512 x [18 x %struct.dcomplex]]* %8, i64 0, i64 %indvars.iv, i64 %indvars.iv6, i32 1
DOALL:     	  %58 = bitcast double* %57 to i64*
DOALL:     	  store i64 %56, i64* %58, align 8, !tbaa !45
DOALL:     	  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
DOALL:     	  %indvars.iv.next7 = add nuw nsw i64 %indvars.iv6, 1
DOALL:     	  call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23)
DOALL:     	  %61 = load i32, i32* @fftblock, align 4, !tbaa !34
DOALL:     	  %62 = sext i32 %61 to i64
DOALL:     	  %63 = sext i32 %.0 to i64
DOALL:     	  %64 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 0
DOALL:     	  %65 = load i32, i32* %64, align 16
DOALL:     	  %66 = sext i32 %65 to i64
DOALL:     	  %indvars.iv10 = phi i64 [ %indvars.iv.next11, %84 ], [ 0, %60 ]
DOALL:     	  %68 = icmp slt i64 %indvars.iv10, %62
DOALL:     	  br i1 %68, label %69, label %85, !prof !40
DOALL:     	  %70 = add nsw i64 %indvars.iv10, %63
DOALL:     	  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %73 ], [ 0, %69 ]
DOALL:     	  %72 = icmp slt i64 %indvars.iv8, %66
DOALL:     	  br i1 %72, label %73, label %84, !prof !41
DOALL:     	  %74 = getelementptr inbounds [512 x [18 x %struct.dcomplex]], [512 x [18 x %struct.dcomplex]]* %8, i64 0, i64 %indvars.iv8, i64 %indvars.iv10
DOALL:     	  %75 = bitcast %struct.dcomplex* %74 to i64*
DOALL:     	  %76 = load i64, i64* %75, align 16, !tbaa !42
DOALL:     	  %77 = getelementptr inbounds [256 x [512 x %struct.dcomplex]], [256 x [512 x %struct.dcomplex]]* %3, i64 %indvars.iv12, i64 %70, i64 %indvars.iv8
DOALL:     	  %78 = bitcast %struct.dcomplex* %77 to i64*
DOALL:     	  store i64 %76, i64* %78, align 8, !tbaa !42
DOALL:     	  %79 = getelementptr inbounds [512 x [18 x %struct.dcomplex]], [512 x [18 x %struct.dcomplex]]* %8, i64 0, i64 %indvars.iv8, i64 %indvars.iv10, i32 1
DOALL:     	  %80 = bitcast double* %79 to i64*
DOALL:     	  %81 = load i64, i64* %80, align 8, !tbaa !45
DOALL:     	  %82 = getelementptr inbounds [256 x [512 x %struct.dcomplex]], [256 x [512 x %struct.dcomplex]]* %3, i64 %indvars.iv12, i64 %70, i64 %indvars.iv8, i32 1
DOALL:     	  %83 = bitcast double* %82 to i64*
DOALL:     	  store i64 %81, i64* %83, align 8, !tbaa !45
DOALL:     	  %indvars.iv.next9 = add nuw nsw i64 %indvars.iv8, 1
DOALL:     	  %indvars.iv.next11 = add nuw nsw i64 %indvars.iv10, 1
DOALL:     	  %86 = add nsw i32 %.0, %61
DOALL:     External nodes: 13
DOALL:     	  %indvars.iv12 = phi i64 [ %indvars.iv.next13, %87 ], [ 0, %17 ]
DOALL:     	  %26 = load i32, i32* %25, align 8, !tbaa !34
DOALL:     	  br i1 %28, label %29, label %88, !prof !38
DOALL:     	  %.pre = load i32, i32* @fftblock, align 4, !tbaa !34
DOALL:     	  br label %40
DOALL:     	  br label %46
DOALL:     	  br label %46
DOALL:     	  br label %40
DOALL:     	  br label %67
DOALL:     	  br label %71
DOALL:     	  br label %71
DOALL:     	  br label %67
DOALL:     	  br label %30
DOALL:     Edges: 235
DOALL:     Loop-carried data dependences
DOALL:         %76 = load i64, i64* %75, align 16, !tbaa !42 --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         %76 = load i64, i64* %75, align 16, !tbaa !42 --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         %76 = load i64, i64* %75, align 16, !tbaa !42 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %76, i64* %78, align 8, !tbaa !42 --->   %51 = load i64, i64* %50, align 16, !tbaa !42 via memory
DOALL:         store i64 %76, i64* %78, align 8, !tbaa !42 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %76, i64* %78, align 8, !tbaa !42 --->   %56 = load i64, i64* %55, align 8, !tbaa !45 via memory
DOALL:         store i64 %76, i64* %78, align 8, !tbaa !42 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %81 = load i64, i64* %80, align 8, !tbaa !45 --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         %81 = load i64, i64* %80, align 8, !tbaa !45 --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         %81 = load i64, i64* %80, align 8, !tbaa !45 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %81, i64* %83, align 8, !tbaa !45 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %81, i64* %83, align 8, !tbaa !45 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %81, i64* %83, align 8, !tbaa !45 --->   %51 = load i64, i64* %50, align 16, !tbaa !42 via memory
DOALL:         store i64 %81, i64* %83, align 8, !tbaa !45 --->   %56 = load i64, i64* %55, align 8, !tbaa !45 via memory
DOALL:         %.pre = load i32, i32* @fftblock, align 4, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %26 = load i32, i32* %25, align 8, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %.pre = load i32, i32* @fftblock, align 4, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %33 = load i32, i32* %32, align 4, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %37 = load i32, i32* %36, align 16, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %26 = load i32, i32* %25, align 8, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   %76 = load i64, i64* %75, align 16, !tbaa !42 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %76, i64* %78, align 8, !tbaa !42 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %81, i64* %83, align 8, !tbaa !45 via memory
DOALL:         %61 = load i32, i32* @fftblock, align 4, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %65 = load i32, i32* %64, align 16 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %51 = load i64, i64* %50, align 16, !tbaa !42 --->   store i64 %81, i64* %83, align 8, !tbaa !45 via memory
DOALL:         %51 = load i64, i64* %50, align 16, !tbaa !42 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %51 = load i64, i64* %50, align 16, !tbaa !42 --->   store i64 %76, i64* %78, align 8, !tbaa !42 via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   %76 = load i64, i64* %75, align 16, !tbaa !42 via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   %81 = load i64, i64* %80, align 8, !tbaa !45 via memory
DOALL:         %56 = load i64, i64* %55, align 8, !tbaa !45 --->   store i64 %76, i64* %78, align 8, !tbaa !42 via memory
DOALL:         %56 = load i64, i64* %55, align 8, !tbaa !45 --->   store i64 %81, i64* %83, align 8, !tbaa !45 via memory
DOALL:         %56 = load i64, i64* %55, align 8, !tbaa !45 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %56, i64* %58, align 8, !tbaa !45 --->   %76 = load i64, i64* %75, align 16, !tbaa !42 via memory
DOALL:         store i64 %56, i64* %58, align 8, !tbaa !45 --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         store i64 %56, i64* %58, align 8, !tbaa !45 --->   %81 = load i64, i64* %80, align 8, !tbaa !45 via memory
DOALL:         store i64 %56, i64* %58, align 8, !tbaa !45 --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %81, i64* %83, align 8, !tbaa !45 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %76, i64* %78, align 8, !tbaa !42 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 63
DOALL:     	  %54 = getelementptr inbounds [256 x [256 x [512 x %struct.dcomplex]]], [256 x [256 x [512 x %struct.dcomplex]]]* @main.u1, i64 0, i64 %indvars.iv12, i64 %45, i64 %indvars.iv, i32 1
DOALL:     	  %31 = phi i32 [ %.pre, %29 ], [ %61, %85 ]
DOALL:     	  %.0 = phi i32 [ 0, %29 ], [ %86, %85 ]
DOALL:     	  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 1
DOALL:     	  %33 = load i32, i32* %32, align 4, !tbaa !34
DOALL:     	  %34 = sub nsw i32 %33, %31
DOALL:     	  %35 = icmp sgt i32 %.0, %34
DOALL:     	  br i1 %35, label %87, label %.preheader, !prof !39
DOALL:     	  %36 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 0
DOALL:     	  %37 = load i32, i32* %36, align 16, !tbaa !34
DOALL:     	  %38 = sext i32 %37 to i64
DOALL:     	  %39 = sext i32 %31 to i64
DOALL:     	  %indvars.iv6 = phi i64 [ 0, %.preheader ], [ %indvars.iv.next7, %59 ]
DOALL:     	  %41 = icmp slt i64 %indvars.iv6, %39
DOALL:     	  br i1 %41, label %42, label %60, !prof !40
DOALL:     	  %43 = trunc i64 %indvars.iv6 to i32
DOALL:     	  %44 = add nsw i32 %.0, %43
DOALL:     	  %45 = sext i32 %44 to i64
DOALL:     	  %indvars.iv = phi i64 [ %indvars.iv.next, %48 ], [ 0, %42 ]
DOALL:     	  %47 = icmp slt i64 %indvars.iv, %38
DOALL:     	  br i1 %47, label %48, label %59, !prof !41
DOALL:     	  %49 = getelementptr inbounds [256 x [256 x [512 x %struct.dcomplex]]], [256 x [256 x [512 x %struct.dcomplex]]]* @main.u1, i64 0, i64 %indvars.iv12, i64 %45, i64 %indvars.iv
DOALL:     	  %50 = bitcast %struct.dcomplex* %49 to i64*
DOALL:     	  %51 = load i64, i64* %50, align 16, !tbaa !42
DOALL:     	  %52 = getelementptr inbounds [512 x [18 x %struct.dcomplex]], [512 x [18 x %struct.dcomplex]]* %8, i64 0, i64 %indvars.iv, i64 %indvars.iv6
DOALL:     	  %53 = bitcast %struct.dcomplex* %52 to i64*
DOALL:     	  store i64 %51, i64* %53, align 16, !tbaa !42
DOALL:     	  %55 = bitcast double* %54 to i64*
DOALL:     	  %56 = load i64, i64* %55, align 8, !tbaa !45
DOALL:     	  %57 = getelementptr inbounds [512 x [18 x %struct.dcomplex]], [512 x [18 x %struct.dcomplex]]* %8, i64 0, i64 %indvars.iv, i64 %indvars.iv6, i32 1
DOALL:     	  %58 = bitcast double* %57 to i64*
DOALL:     	  store i64 %56, i64* %58, align 8, !tbaa !45
DOALL:     	  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
DOALL:     	  %indvars.iv.next7 = add nuw nsw i64 %indvars.iv6, 1
DOALL:     	  call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23)
DOALL:     	  %61 = load i32, i32* @fftblock, align 4, !tbaa !34
DOALL:     	  %62 = sext i32 %61 to i64
DOALL:     	  %63 = sext i32 %.0 to i64
DOALL:     	  %64 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 0
DOALL:     	  %65 = load i32, i32* %64, align 16
DOALL:     	  %66 = sext i32 %65 to i64
DOALL:     	  %indvars.iv10 = phi i64 [ %indvars.iv.next11, %84 ], [ 0, %60 ]
DOALL:     	  %68 = icmp slt i64 %indvars.iv10, %62
DOALL:     	  br i1 %68, label %69, label %85, !prof !40
DOALL:     	  %70 = add nsw i64 %indvars.iv10, %63
DOALL:     	  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %73 ], [ 0, %69 ]
DOALL:     	  %72 = icmp slt i64 %indvars.iv8, %66
DOALL:     	  br i1 %72, label %73, label %84, !prof !41
DOALL:     	  %74 = getelementptr inbounds [512 x [18 x %struct.dcomplex]], [512 x [18 x %struct.dcomplex]]* %8, i64 0, i64 %indvars.iv8, i64 %indvars.iv10
DOALL:     	  %75 = bitcast %struct.dcomplex* %74 to i64*
DOALL:     	  %76 = load i64, i64* %75, align 16, !tbaa !42
DOALL:     	  %77 = getelementptr inbounds [256 x [512 x %struct.dcomplex]], [256 x [512 x %struct.dcomplex]]* %3, i64 %indvars.iv12, i64 %70, i64 %indvars.iv8
DOALL:     	  %78 = bitcast %struct.dcomplex* %77 to i64*
DOALL:     	  store i64 %76, i64* %78, align 8, !tbaa !42
DOALL:     	  %79 = getelementptr inbounds [512 x [18 x %struct.dcomplex]], [512 x [18 x %struct.dcomplex]]* %8, i64 0, i64 %indvars.iv8, i64 %indvars.iv10, i32 1
DOALL:     	  %80 = bitcast double* %79 to i64*
DOALL:     	  %81 = load i64, i64* %80, align 8, !tbaa !45
DOALL:     	  %82 = getelementptr inbounds [256 x [512 x %struct.dcomplex]], [256 x [512 x %struct.dcomplex]]* %3, i64 %indvars.iv12, i64 %70, i64 %indvars.iv8, i32 1
DOALL:     	  %83 = bitcast double* %82 to i64*
DOALL:     	  store i64 %81, i64* %83, align 8, !tbaa !45
DOALL:     	  %indvars.iv.next9 = add nuw nsw i64 %indvars.iv8, 1
DOALL:     	  %indvars.iv.next11 = add nuw nsw i64 %indvars.iv10, 1
DOALL:     	  %86 = add nsw i32 %.0, %61
DOALL:     External nodes: 9
DOALL:     	  br label %40
DOALL:     	  br label %46
DOALL:     	  br label %46
DOALL:     	  br label %40
DOALL:     	  br label %67
DOALL:     	  br label %71
DOALL:     	  br label %71
DOALL:     	  br label %67
DOALL:     	  br label %30
DOALL:     Edges: 219
DOALL:     Loop-carried data dependences
DOALL:         %37 = load i32, i32* %36, align 16, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %51 = load i64, i64* %50, align 16, !tbaa !42 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %51 = load i64, i64* %50, align 16, !tbaa !42 --->   store i64 %81, i64* %83, align 8, !tbaa !45 via memory
DOALL:         %51 = load i64, i64* %50, align 16, !tbaa !42 --->   store i64 %76, i64* %78, align 8, !tbaa !42 via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   %81 = load i64, i64* %80, align 8, !tbaa !45 via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   %76 = load i64, i64* %75, align 16, !tbaa !42 via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %51, i64* %53, align 16, !tbaa !42 --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         %56 = load i64, i64* %55, align 8, !tbaa !45 --->   store i64 %76, i64* %78, align 8, !tbaa !42 via memory
DOALL:         %56 = load i64, i64* %55, align 8, !tbaa !45 --->   store i64 %81, i64* %83, align 8, !tbaa !45 via memory
DOALL:         %56 = load i64, i64* %55, align 8, !tbaa !45 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %56, i64* %58, align 8, !tbaa !45 --->   %81 = load i64, i64* %80, align 8, !tbaa !45 via memory
DOALL:         store i64 %56, i64* %58, align 8, !tbaa !45 --->   %76 = load i64, i64* %75, align 16, !tbaa !42 via memory
DOALL:         store i64 %56, i64* %58, align 8, !tbaa !45 --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         store i64 %56, i64* %58, align 8, !tbaa !45 --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %81, i64* %83, align 8, !tbaa !45 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %81, i64* %83, align 8, !tbaa !45 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   %76 = load i64, i64* %75, align 16, !tbaa !42 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %76, i64* %78, align 8, !tbaa !42 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %76, i64* %78, align 8, !tbaa !42 via memory
DOALL:         call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         %61 = load i32, i32* @fftblock, align 4, !tbaa !34 --->   %31 = phi i32 [ %.pre, %29 ], [ %61, %85 ] via variable
DOALL:         %61 = load i32, i32* @fftblock, align 4, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %65 = load i32, i32* %64, align 16 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %33 = load i32, i32* %32, align 4, !tbaa !34 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %76 = load i64, i64* %75, align 16, !tbaa !42 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %76 = load i64, i64* %75, align 16, !tbaa !42 --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         %76 = load i64, i64* %75, align 16, !tbaa !42 --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         store i64 %76, i64* %78, align 8, !tbaa !42 --->   store i64 %76, i64* %78, align 8, !tbaa !42 via memory
DOALL:         store i64 %76, i64* %78, align 8, !tbaa !42 --->   store i64 %81, i64* %83, align 8, !tbaa !45 via memory
DOALL:         store i64 %76, i64* %78, align 8, !tbaa !42 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %76, i64* %78, align 8, !tbaa !42 --->   %51 = load i64, i64* %50, align 16, !tbaa !42 via memory
DOALL:         store i64 %76, i64* %78, align 8, !tbaa !42 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %76, i64* %78, align 8, !tbaa !42 --->   %56 = load i64, i64* %55, align 8, !tbaa !45 via memory
DOALL:         %81 = load i64, i64* %80, align 8, !tbaa !45 --->   store i64 %56, i64* %58, align 8, !tbaa !45 via memory
DOALL:         %81 = load i64, i64* %80, align 8, !tbaa !45 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         %81 = load i64, i64* %80, align 8, !tbaa !45 --->   store i64 %51, i64* %53, align 16, !tbaa !42 via memory
DOALL:         store i64 %81, i64* %83, align 8, !tbaa !45 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %81, i64* %83, align 8, !tbaa !45 --->   %51 = load i64, i64* %50, align 16, !tbaa !42 via memory
DOALL:         store i64 %81, i64* %83, align 8, !tbaa !45 --->   store i64 %81, i64* %83, align 8, !tbaa !45 via memory
DOALL:         store i64 %81, i64* %83, align 8, !tbaa !45 --->   store i64 %76, i64* %78, align 8, !tbaa !42 via memory
DOALL:         store i64 %81, i64* %83, align 8, !tbaa !45 --->   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23) via memory
DOALL:         store i64 %81, i64* %83, align 8, !tbaa !45 --->   %56 = load i64, i64* %55, align 8, !tbaa !45 via memory
DOALL:         %86 = add nsw i32 %.0, %61 --->   %.0 = phi i32 [ 0, %29 ], [ %86, %85 ] via variable
Inliner:   Inlining in: cffts1 (111 instructions. The inlining will add 340 instructions),   call fastcc void @cfftz(i32 %0, i32 %21, i32 %37, [18 x %struct.dcomplex]* nonnull %22, [18 x %struct.dcomplex]* nonnull %23)
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8
ClonableMemoryObject:   It is clonable
ClonableMemoryObject:   It requires initialization
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca double, align 8 can be cloned
MemoryCloningAnalysis:     The private copies need to be initialized with the original object.
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 24
DOALL:     	  %28 = load i64, i64* %19, align 8, !tbaa !33
DOALL:     	  %93 = load double, double* %4, align 8, !tbaa !33
DOALL:     	  %94 = fmul double %93, 0x3E80000000000000
DOALL:     	  %95 = fptosi double %94 to i32
DOALL:     	  %96 = sitofp i32 %95 to double
DOALL:     	  %97 = fmul double %96, 0x4160000000000000
DOALL:     	  %98 = fsub double %93, %97
DOALL:     	  %99 = fmul double %98, %90
DOALL:     	  %100 = fmul double %92, %96
DOALL:     	  %101 = fadd double %99, %100
DOALL:     	  %102 = fmul double %101, 0x3E80000000000000
DOALL:     	  %103 = fptosi double %102 to i32
DOALL:     	  %104 = sitofp i32 %103 to double
DOALL:     	  %105 = fmul double %104, 0x4160000000000000
DOALL:     	  %106 = fsub double %101, %105
DOALL:     	  %107 = fmul double %106, 0x4160000000000000
DOALL:     	  %108 = fmul double %92, %98
DOALL:     	  %109 = fadd double %107, %108
DOALL:     	  %110 = fmul double %109, 0x3D10000000000000
DOALL:     	  %111 = fptosi double %110 to i32
DOALL:     	  %112 = sitofp i32 %111 to double
DOALL:     	  %113 = fmul double %112, 0x42D0000000000000
DOALL:     	  %114 = fsub double %109, %113
DOALL:     	  store double %114, double* %4, align 8, !tbaa !33
DOALL:     External nodes: 6
DOALL:     	  br i1 %26, label %27, label %116, !prof !39
DOALL:     	  store i64 %28, i64* %20, align 8, !tbaa !33
DOALL:     	  br i1 %86, label %.._crit_edge_crit_edge, label %87, !prof !46
DOALL:     	  %90 = sitofp i32 %89 to double
DOALL:     	  %92 = fsub double %21, %91
DOALL:     	  %115 = fmul double %114, 0x3D10000000000000
DOALL:     Edges: 61
DOALL:     Loop-carried data dependences
DOALL:         store double %114, double* %4, align 8, !tbaa !33 --->   store double %114, double* %4, align 8, !tbaa !33 via memory
DOALL:         store double %114, double* %4, align 8, !tbaa !33 --->   %28 = load i64, i64* %19, align 8, !tbaa !33 via memory
DOALL:         store double %114, double* %4, align 8, !tbaa !33 --->   %93 = load double, double* %4, align 8, !tbaa !33 via memory
DOALL:         %28 = load i64, i64* %19, align 8, !tbaa !33 --->   store double %114, double* %4, align 8, !tbaa !33 via memory
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 3
DOALL:     	  store double %59, double* %60, align 8, !tbaa !33
DOALL:     	  %73 = load i64, i64* %72, align 8, !tbaa !33
DOALL:     	  %78 = load i64, i64* %77, align 8, !tbaa !33
DOALL:     External nodes: 8
DOALL:     	  br i1 %36, label %vranlc.exit, label %37, !prof !40
DOALL:     	  %59 = fmul double %58, 0x3D10000000000000
DOALL:     	  %60 = getelementptr inbounds double, double* %32, i64 %indvars.iv.i
DOALL:     	  br i1 %exitcond, label %81, label %69, !prof !42
DOALL:     	  %72 = bitcast double* %71 to i64*
DOALL:     	  store i64 %73, i64* %75, align 16, !tbaa !43
DOALL:     	  %77 = bitcast double* %76 to i64*
DOALL:     	  store i64 %78, i64* %80, align 8, !tbaa !45
DOALL:     Edges: 14
DOALL:     Loop-carried data dependences
DOALL:         store double %59, double* %60, align 8, !tbaa !33 --->   %78 = load i64, i64* %77, align 8, !tbaa !33 via memory
DOALL:         store double %59, double* %60, align 8, !tbaa !33 --->   store double %59, double* %60, align 8, !tbaa !33 via memory
DOALL:         store double %59, double* %60, align 8, !tbaa !33 --->   %73 = load i64, i64* %72, align 8, !tbaa !33 via memory
DOALL:         %73 = load i64, i64* %72, align 8, !tbaa !33 --->   store double %59, double* %60, align 8, !tbaa !33 via memory
DOALL:         %78 = load i64, i64* %77, align 8, !tbaa !33 --->   store double %59, double* %60, align 8, !tbaa !33 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 6
DOALL:     	  %.0 = phi i64 [ %indvars.iv4.lcssa, %81 ], [ 1, %vranlc.exit ]
DOALL:     	  %sext = shl i64 %.0, 32
DOALL:     	  %67 = ashr exact i64 %sext, 32
DOALL:     	  %indvars.iv4 = phi i64 [ %indvars.iv.next5, %69 ], [ %67, %66 ]
DOALL:     	  %indvars.iv.next5 = add nsw i64 %indvars.iv4, 2
DOALL:     	  %indvars.iv4.lcssa = phi i64 [ %indvars.iv4, %68 ]
DOALL:     External nodes: 4
DOALL:     	  br i1 %65, label %66, label %82, !prof !41
DOALL:     	  br i1 %exitcond, label %81, label %69, !prof !42
DOALL:     	  %70 = add nsw i64 %indvars.iv4, 1
DOALL:     	  %71 = getelementptr inbounds [524289 x double], [524289 x double]* @compute_initial_conditions.tmp, i64 0, i64 %indvars.iv4
DOALL:     Edges: 16
DOALL:     Loop-carried data dependences
DOALL:         %indvars.iv4.lcssa = phi i64 [ %indvars.iv4, %68 ] --->   %.0 = phi i64 [ %indvars.iv4.lcssa, %81 ], [ 1, %vranlc.exit ] via variable
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
Inliner:   Inlining in: main (93 instructions. The inlining will add 33 instructions),   tail call fastcc void @fft(i32 -1, [256 x [512 x %struct.dcomplex]]* %38, [256 x [512 x %struct.dcomplex]]* %39)
Inliner:   Inlined calls due to loop-carried data dependences
Inliner: Exit
Noelle:  Function "main"
Noelle:     Loop "  %exitcond8 = icmp eq i32 %.02, 7" (9.398497e-09%)
Noelle:     Loop "  %exitcond = icmp eq i32 %.1, 7" (9.398497e-09%)
Noelle:     Loop "  %.b4 = load i1, i1* @niter, align 4" (5.198593e+01%)
Noelle:  Function "fft"
Noelle:  Function "cfftz"
Noelle:     Loop "  %12 = icmp sgt i32 %.0, %1" (4.155903e+01%)
Noelle:     Loop "  %77 = icmp slt i64 %indvars.iv16.i11, %29" (1.934567e+01%)
Noelle:     Loop "  %90 = icmp slt i64 %indvars.iv14.i13, %28" (1.920077e+01%)
Noelle:     Loop "  %97 = icmp slt i64 %indvars.iv12.i14, %27" (1.879704e+01%)
Noelle:     Loop "  %32 = icmp slt i64 %indvars.iv10.i4, %29" (1.933666e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv8.i6, %28" (1.920077e+00%)
Noelle:     Loop "  %52 = icmp slt i64 %indvars.iv.i8, %27" (1.879704e+00%)
Noelle:     Loop "  %188 = icmp slt i64 %indvars.iv16.i, %140" (1.842445e+01%)
Noelle:     Loop "  %201 = icmp slt i64 %indvars.iv14.i, %139" (1.828645e+01%)
Noelle:     Loop "  %208 = icmp slt i64 %indvars.iv12.i, %138" (1.790194e+01%)
Noelle:     Loop "  %143 = icmp slt i64 %indvars.iv10.i, %140" (1.841587e+00%)
Noelle:     Loop "  %155 = icmp slt i64 %indvars.iv8.i, %139" (1.828645e+00%)
Noelle:     Loop "  %163 = icmp slt i64 %indvars.iv.i, %138" (1.790194e+00%)
Noelle:     Loop "  %242 = icmp slt i64 %indvars.iv5, %240" (1.818660e+00%)
Noelle:     Loop "  %244 = icmp slt i64 %indvars.iv, %239" (1.779790e+00%)
Noelle:  Function "fftz2"
Noelle:     Loop "  %70 = icmp slt i64 %indvars.iv16, %22" (3.776990e+01%)
Noelle:     Loop "  %83 = icmp slt i64 %indvars.iv14, %21" (3.748702e+01%)
Noelle:     Loop "  %90 = icmp slt i64 %indvars.iv12, %20" (3.669883e+01%)
Noelle:     Loop "  %25 = icmp slt i64 %indvars.iv10, %22" (3.775062e+00%)
Noelle:     Loop "  %37 = icmp slt i64 %indvars.iv8, %21" (3.748595e+00%)
Noelle:     Loop "  %45 = icmp slt i64 %indvars.iv, %20" (3.669813e+00%)
Noelle:  Function "cffts3"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (7.257884e-07%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 1" (2.140431e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 0" (2.140430e+01%)
Noelle:     Loop "  %42 = icmp slt i64 %indvars.iv7, %40" (2.129352e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv, %39" (2.090445e+00%)
Noelle:     Loop "  %68 = icmp slt i64 %indvars.iv11, %66" (1.922249e+00%)
Noelle:     Loop "  %70 = icmp slt i64 %indvars.iv9, %64" (1.883342e+00%)
Noelle:  Function "cffts2"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (6.368534e-07%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 2" (2.140342e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 0" (2.140342e+01%)
Noelle:     Loop "  %42 = icmp slt i64 %indvars.iv7, %40" (2.129352e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv, %39" (2.090445e+00%)
Noelle:     Loop "  %68 = icmp slt i64 %indvars.iv11, %66" (1.922249e+00%)
Noelle:     Loop "  %70 = icmp slt i64 %indvars.iv9, %64" (1.883342e+00%)
Noelle:  Function "cffts1"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv14, 3" (6.368534e-07%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (1.220105e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 1" (1.220104e+01%)
Noelle:     Loop "  %41 = icmp slt i64 %indvars.iv6, %39" (1.762839e+00%)
Noelle:     Loop "  %47 = icmp slt i64 %indvars.iv, %38" (1.760981e+00%)
Noelle:     Loop "  %68 = icmp slt i64 %indvars.iv10, %62" (1.762435e+00%)
Noelle:     Loop "  %72 = icmp slt i64 %indvars.iv8, %66" (1.760981e+00%)
Noelle:  Function "evolve"
Noelle:     Loop "  %16 = icmp slt i64 %indvars.iv5, %8" (1.978552e+00%)
Noelle:     Loop "  %18 = icmp slt i64 %indvars.iv3, %11" (1.978548e+00%)
Noelle:     Loop "  %20 = icmp slt i64 %indvars.iv, %14" (1.977443e+00%)
Noelle:  Function "compute_initial_conditions"
Noelle:     Loop "  %23 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (7.533614e-01%)
Noelle:     Loop "  %36 = icmp sgt i64 %indvars.iv.i, %34" (5.648242e-01%)
Noelle:     Loop "  %65 = icmp slt i64 %indvars.iv6, %63" (1.885330e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 512" (1.883489e-01%)
Noelle:  Function "vranlc"
Noelle:     Loop "  %13 = icmp sgt i64 %indvars.iv, %11" (5.648239e-01%)
Noelle:  Function "compute_indexmap"
Noelle:     Loop "  %15 = icmp slt i64 %indvars.iv10, %4" (1.323832e-01%)
Noelle:     Loop "  %23 = icmp slt i64 %indvars.iv8, %8" (1.323815e-01%)
Noelle:     Loop "  %33 = icmp slt i64 %indvars.iv6, %12" (1.319030e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 1966081" (6.068947e-03%)
Noelle:  Function "checksum"
Noelle:     Loop "  %exitcond = icmp eq i32 %.0, 1025" (1.206739e-04%)
Noelle:  Function "randlc"
Noelle:  Function "fft_init"
Noelle:     Loop "  %7 = icmp sgt i32 %.01, %2" (2.194759e-06%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count" (2.158007e-06%)
Noelle:  Function "ilog2"
Noelle:     Loop "  %3 = icmp slt i32 %.01, %0" (1.553698e-06%)
Noelle:  Function "ipow46"
Noelle:     Loop "  %11 = icmp sgt i32 %.01, 1" (2.080294e-07%)
Noelle:  Function "verify"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 21" (6.494782e-08%)
Noelle:  Function "setup"
Noelle:     Loop "  %exitcond3 = icmp eq i64 %indvars.iv1, 3" (5.049939e-09%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 3" (7.574908e-09%)
Noelle:  Function "elapsed_time"
Noelle:  Function "timer_clear"
Noelle:  Function "c_print_results"
Noelle:  Function "wtime_"
Noelle:  Function "timer_stop"
Noelle:  Function "timer_start"
Noelle:  Function "timer_read"
Noelle:  Function "main"
Noelle:     Loop "  %exitcond8 = icmp eq i32 %.02, 7" (6.555052e-09%)
Noelle:     Loop "  %exitcond = icmp eq i32 %.1, 7" (6.555052e-09%)
Noelle:     Loop "  %.b4 = load i1, i1* @niter, align 4" (3.625788e+01%)
Noelle:  Function "fft"
Noelle:  Function "cfftz"
Noelle:     Loop "  %12 = icmp sgt i32 %.0, %1" (2.898565e+01%)
Noelle:     Loop "  %77 = icmp slt i64 %indvars.iv16.i11, %29" (1.349278e+01%)
Noelle:     Loop "  %90 = icmp slt i64 %indvars.iv14.i13, %28" (1.339172e+01%)
Noelle:     Loop "  %97 = icmp slt i64 %indvars.iv12.i14, %27" (1.311014e+01%)
Noelle:     Loop "  %32 = icmp slt i64 %indvars.iv10.i4, %29" (1.348650e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv8.i6, %28" (1.339172e+00%)
Noelle:     Loop "  %52 = icmp slt i64 %indvars.iv.i8, %27" (1.311014e+00%)
Noelle:     Loop "  %188 = icmp slt i64 %indvars.iv16.i, %140" (1.285027e+01%)
Noelle:     Loop "  %201 = icmp slt i64 %indvars.iv14.i, %139" (1.275402e+01%)
Noelle:     Loop "  %208 = icmp slt i64 %indvars.iv12.i, %138" (1.248584e+01%)
Noelle:     Loop "  %143 = icmp slt i64 %indvars.iv10.i, %140" (1.284428e+00%)
Noelle:     Loop "  %155 = icmp slt i64 %indvars.iv8.i, %139" (1.275402e+00%)
Noelle:     Loop "  %163 = icmp slt i64 %indvars.iv.i, %138" (1.248584e+00%)
Noelle:     Loop "  %242 = icmp slt i64 %indvars.iv5, %240" (1.268438e+00%)
Noelle:     Loop "  %244 = icmp slt i64 %indvars.iv, %239" (1.241328e+00%)
Noelle:  Function "fftz2"
Noelle:     Loop "  %70 = icmp slt i64 %indvars.iv16, %22" (2.634290e+01%)
Noelle:     Loop "  %83 = icmp slt i64 %indvars.iv14, %21" (2.614560e+01%)
Noelle:     Loop "  %90 = icmp slt i64 %indvars.iv12, %20" (2.559587e+01%)
Noelle:     Loop "  %25 = icmp slt i64 %indvars.iv10, %22" (2.632945e+00%)
Noelle:     Loop "  %37 = icmp slt i64 %indvars.iv8, %21" (2.614486e+00%)
Noelle:     Loop "  %45 = icmp slt i64 %indvars.iv, %20" (2.559539e+00%)
Noelle:  Function "cffts3"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (4.724529e-07%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 1" (1.492791e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 0" (1.492790e+01%)
Noelle:     Loop "  %42 = icmp slt i64 %indvars.iv7, %40" (1.485121e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv, %39" (1.457985e+00%)
Noelle:     Loop "  %68 = icmp sgt i32 %.0.i, %21" (1.159403e+01%)
Noelle:     Loop "  %132 = icmp slt i64 %indvars.iv16.i11.i, %84" (5.397072e+00%)
Noelle:     Loop "  %145 = icmp slt i64 %indvars.iv14.i13.i, %83" (5.356647e+00%)
Noelle:     Loop "  %152 = icmp slt i64 %indvars.iv12.i14.i, %82" (5.244014e+00%)
Noelle:     Loop "  %87 = icmp slt i64 %indvars.iv10.i4.i, %84" (5.394558e-01%)
Noelle:     Loop "  %99 = icmp slt i64 %indvars.iv8.i6.i, %83" (5.356647e-01%)
Noelle:     Loop "  %107 = icmp slt i64 %indvars.iv.i8.i, %82" (5.244014e-01%)
Noelle:     Loop "  %242 = icmp slt i64 %indvars.iv16.i.i, %194" (5.140069e+00%)
Noelle:     Loop "  %255 = icmp slt i64 %indvars.iv14.i.i, %193" (5.101568e+00%)
Noelle:     Loop "  %262 = icmp slt i64 %indvars.iv12.i.i, %192" (4.994299e+00%)
Noelle:     Loop "  %197 = icmp slt i64 %indvars.iv10.i.i, %194" (5.137674e-01%)
Noelle:     Loop "  %209 = icmp slt i64 %indvars.iv8.i.i, %193" (5.101568e-01%)
Noelle:     Loop "  %217 = icmp slt i64 %indvars.iv.i.i, %192" (4.994299e-01%)
Noelle:     Loop "  %296 = icmp slt i64 %indvars.iv5.i, %294" (5.073713e-01%)
Noelle:     Loop "  %298 = icmp slt i64 %indvars.iv.i, %293" (4.965274e-01%)
Noelle:     Loop "  %318 = icmp slt i64 %indvars.iv11, %316" (1.340677e+00%)
Noelle:     Loop "  %320 = icmp slt i64 %indvars.iv9, %314" (1.313541e+00%)
Noelle:  Function "cffts2"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (4.650173e-07%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 2" (1.492791e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 0" (1.492790e+01%)
Noelle:     Loop "  %42 = icmp slt i64 %indvars.iv7, %40" (1.485121e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv, %39" (1.457985e+00%)
Noelle:     Loop "  %68 = icmp sgt i32 %.0.i, %21" (1.159403e+01%)
Noelle:     Loop "  %132 = icmp slt i64 %indvars.iv16.i11.i, %84" (5.397072e+00%)
Noelle:     Loop "  %145 = icmp slt i64 %indvars.iv14.i13.i, %83" (5.356647e+00%)
Noelle:     Loop "  %152 = icmp slt i64 %indvars.iv12.i14.i, %82" (5.244014e+00%)
Noelle:     Loop "  %87 = icmp slt i64 %indvars.iv10.i4.i, %84" (5.394558e-01%)
Noelle:     Loop "  %99 = icmp slt i64 %indvars.iv8.i6.i, %83" (5.356647e-01%)
Noelle:     Loop "  %107 = icmp slt i64 %indvars.iv.i8.i, %82" (5.244014e-01%)
Noelle:     Loop "  %242 = icmp slt i64 %indvars.iv16.i.i, %194" (5.140069e+00%)
Noelle:     Loop "  %255 = icmp slt i64 %indvars.iv14.i.i, %193" (5.101568e+00%)
Noelle:     Loop "  %262 = icmp slt i64 %indvars.iv12.i.i, %192" (4.994299e+00%)
Noelle:     Loop "  %197 = icmp slt i64 %indvars.iv10.i.i, %194" (5.137674e-01%)
Noelle:     Loop "  %209 = icmp slt i64 %indvars.iv8.i.i, %193" (5.101568e-01%)
Noelle:     Loop "  %217 = icmp slt i64 %indvars.iv.i.i, %192" (4.994299e-01%)
Noelle:     Loop "  %296 = icmp slt i64 %indvars.iv5.i, %294" (5.073713e-01%)
Noelle:     Loop "  %298 = icmp slt i64 %indvars.iv.i, %293" (4.965274e-01%)
Noelle:     Loop "  %318 = icmp slt i64 %indvars.iv11, %316" (1.340677e+00%)
Noelle:     Loop "  %320 = icmp slt i64 %indvars.iv9, %314" (1.313541e+00%)
Noelle:  Function "cffts1"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv14, 3" (4.650173e-07%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (8.509802e+00%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 1" (8.509797e+00%)
Noelle:     Loop "  %41 = icmp slt i64 %indvars.iv6, %39" (1.229501e+00%)
Noelle:     Loop "  %47 = icmp slt i64 %indvars.iv, %38" (1.228205e+00%)
Noelle:     Loop "  %68 = icmp sgt i32 %.0.i, %21" (5.797036e+00%)
Noelle:     Loop "  %132 = icmp slt i64 %indvars.iv16.i11.i, %84" (2.698546e+00%)
Noelle:     Loop "  %145 = icmp slt i64 %indvars.iv14.i13.i, %83" (2.678334e+00%)
Noelle:     Loop "  %152 = icmp slt i64 %indvars.iv12.i14.i, %82" (2.622017e+00%)
Noelle:     Loop "  %87 = icmp slt i64 %indvars.iv10.i4.i, %84" (2.697289e-01%)
Noelle:     Loop "  %99 = icmp slt i64 %indvars.iv8.i6.i, %83" (2.678334e-01%)
Noelle:     Loop "  %107 = icmp slt i64 %indvars.iv.i8.i, %82" (2.622017e-01%)
Noelle:     Loop "  %242 = icmp slt i64 %indvars.iv16.i.i, %194" (2.570044e+00%)
Noelle:     Loop "  %255 = icmp slt i64 %indvars.iv14.i.i, %193" (2.550794e+00%)
Noelle:     Loop "  %262 = icmp slt i64 %indvars.iv12.i.i, %192" (2.497159e+00%)
Noelle:     Loop "  %197 = icmp slt i64 %indvars.iv10.i.i, %194" (2.568847e-01%)
Noelle:     Loop "  %209 = icmp slt i64 %indvars.iv8.i.i, %193" (2.550794e-01%)
Noelle:     Loop "  %217 = icmp slt i64 %indvars.iv.i.i, %192" (2.497159e-01%)
Noelle:     Loop "  %296 = icmp slt i64 %indvars.iv5.i, %294" (2.536866e-01%)
Noelle:     Loop "  %298 = icmp slt i64 %indvars.iv.i, %293" (2.482647e-01%)
Noelle:     Loop "  %318 = icmp slt i64 %indvars.iv10, %312" (1.229219e+00%)
Noelle:     Loop "  %322 = icmp slt i64 %indvars.iv8, %316" (1.228205e+00%)
Noelle:  Function "evolve"
Noelle:     Loop "  %16 = icmp slt i64 %indvars.iv5, %8" (1.379956e+00%)
Noelle:     Loop "  %18 = icmp slt i64 %indvars.iv3, %11" (1.379953e+00%)
Noelle:     Loop "  %20 = icmp slt i64 %indvars.iv, %14" (1.379182e+00%)
Noelle:  Function "compute_initial_conditions"
Noelle:     Loop "  %23 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (5.254375e-01%)
Noelle:     Loop "  %36 = icmp sgt i64 %indvars.iv.i, %34" (3.939408e-01%)
Noelle:     Loop "  %65 = icmp slt i64 %indvars.iv6, %63" (1.314938e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 512" (1.313653e-01%)
Noelle:  Function "vranlc"
Noelle:     Loop "  %13 = icmp sgt i64 %indvars.iv, %11" (3.939407e-01%)
Noelle:  Function "compute_indexmap"
Noelle:     Loop "  %15 = icmp slt i64 %indvars.iv10, %4" (9.233168e-02%)
Noelle:     Loop "  %23 = icmp slt i64 %indvars.iv8, %8" (9.233048e-02%)
Noelle:     Loop "  %33 = icmp slt i64 %indvars.iv6, %12" (9.199677e-02%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 1966081" (4.232832e-03%)
Noelle:  Function "checksum"
Noelle:     Loop "  %exitcond = icmp eq i32 %.0, 1025" (8.416491e-05%)
Noelle:  Function "randlc"
Noelle:  Function "fft_init"
Noelle:     Loop "  %7 = icmp sgt i32 %.01, %2" (1.530751e-06%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count" (1.505118e-06%)
Noelle:  Function "ilog2"
Noelle:     Loop "  %3 = icmp slt i32 %.01, %0" (1.083638e-06%)
Noelle:  Function "ipow46"
Noelle:     Loop "  %11 = icmp sgt i32 %.01, 1" (1.450917e-07%)
Noelle:  Function "verify"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 21" (4.529834e-08%)
Noelle:  Function "setup"
Noelle:     Loop "  %exitcond3 = icmp eq i64 %indvars.iv1, 3" (3.522117e-09%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 3" (5.283176e-09%)
Noelle:  Function "elapsed_time"
Noelle:  Function "timer_clear"
Noelle:  Function "c_print_results"
Noelle:  Function "wtime_"
Noelle:  Function "timer_stop"
Noelle:  Function "timer_start"
Noelle:  Function "timer_read"
NOELLE: FixedPoint:       There are 852 different instructions and 3835 different loop instructions
NOELLE: FixedPoint:       Normalize the code
noelle-norm /tmp/tmp.mEnWC8flov -o /tmp/tmp.mEnWC8flov
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.mEnWC8flov -o /tmp/tmp.mEnWC8flov
NOELLE: FixedPoint:     Invocation 3
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.1zCLAhAajz -o /tmp/tmp.mEnWC8flov
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.1zCLAhAajz -o /tmp/tmp.mEnWC8flov
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.1zCLAhAajz -o /tmp/tmp.mEnWC8flov
Inliner: Start
Inliner:   Number of program instructions = 2672
Inliner:   Profiles are available and will be used
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %163, double* %164, align 8, !tbaa !42
DOALL:     	  store double %165, double* %166, align 8, !tbaa !45
DOALL:     	  store double %171, double* %172, align 8, !tbaa !42
DOALL:     	  store double %175, double* %176, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %153, label %154, label %177, !prof !58
DOALL:     	  %163 = fadd double %156, %160
DOALL:     	  %164 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %165 = fadd double %158, %162
DOALL:     	  %166 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 1
DOALL:     	  %171 = fsub double %168, %170
DOALL:     	  %172 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %175 = fadd double %173, %174
DOALL:     	  %176 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %273, double* %274, align 8, !tbaa !42
DOALL:     	  store double %275, double* %276, align 8, !tbaa !45
DOALL:     	  store double %281, double* %282, align 8, !tbaa !42
DOALL:     	  store double %285, double* %286, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %263, label %264, label %287, !prof !58
DOALL:     	  %273 = fadd double %266, %270
DOALL:     	  %274 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %275 = fadd double %268, %272
DOALL:     	  %276 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 1
DOALL:     	  %281 = fsub double %278, %280
DOALL:     	  %282 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %285 = fadd double %283, %284
DOALL:     	  %286 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %229, double* %230, align 8, !tbaa !42
DOALL:     	  store double %231, double* %232, align 8, !tbaa !45
DOALL:     	  store double %237, double* %238, align 8, !tbaa !42
DOALL:     	  store double %241, double* %242, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %218, label %220, label %219, !prof !55
DOALL:     	  %229 = fadd double %222, %226
DOALL:     	  %230 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %231 = fadd double %224, %228
DOALL:     	  %232 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 1
DOALL:     	  %237 = fsub double %234, %236
DOALL:     	  %238 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %241 = fadd double %239, %240
DOALL:     	  %242 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %127, double* %128, align 8, !tbaa !42
DOALL:     	  store double %131, double* %132, align 8, !tbaa !45
DOALL:     	  store double %119, double* %120, align 8, !tbaa !42
DOALL:     	  store double %121, double* %122, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  %127 = fsub double %124, %126
DOALL:     	  %128 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %131 = fadd double %129, %130
DOALL:     	  %132 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 1
DOALL:     	  br i1 %108, label %110, label %109, !prof !55
DOALL:     	  %119 = fadd double %112, %116
DOALL:     	  %120 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %121 = fadd double %114, %118
DOALL:     	  %122 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %273, double* %274, align 8, !tbaa !42
DOALL:     	  store double %275, double* %276, align 8, !tbaa !45
DOALL:     	  store double %281, double* %282, align 8, !tbaa !42
DOALL:     	  store double %285, double* %286, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %263, label %264, label %287, !prof !58
DOALL:     	  %273 = fadd double %266, %270
DOALL:     	  %274 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %275 = fadd double %268, %272
DOALL:     	  %276 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 1
DOALL:     	  %281 = fsub double %278, %280
DOALL:     	  %282 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %285 = fadd double %283, %284
DOALL:     	  %286 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %229, double* %230, align 8, !tbaa !42
DOALL:     	  store double %231, double* %232, align 8, !tbaa !45
DOALL:     	  store double %237, double* %238, align 8, !tbaa !42
DOALL:     	  store double %241, double* %242, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %218, label %220, label %219, !prof !55
DOALL:     	  %229 = fadd double %222, %226
DOALL:     	  %230 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %231 = fadd double %224, %228
DOALL:     	  %232 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 1
DOALL:     	  %237 = fsub double %234, %236
DOALL:     	  %238 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %241 = fadd double %239, %240
DOALL:     	  %242 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %127, double* %128, align 8, !tbaa !42
DOALL:     	  store double %131, double* %132, align 8, !tbaa !45
DOALL:     	  store double %119, double* %120, align 8, !tbaa !42
DOALL:     	  store double %121, double* %122, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  %127 = fsub double %124, %126
DOALL:     	  %128 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %131 = fadd double %129, %130
DOALL:     	  %132 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 1
DOALL:     	  br i1 %108, label %110, label %109, !prof !55
DOALL:     	  %119 = fadd double %112, %116
DOALL:     	  %120 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %121 = fadd double %114, %118
DOALL:     	  %122 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %163, double* %164, align 8, !tbaa !42
DOALL:     	  store double %165, double* %166, align 8, !tbaa !45
DOALL:     	  store double %171, double* %172, align 8, !tbaa !42
DOALL:     	  store double %175, double* %176, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %153, label %154, label %177, !prof !58
DOALL:     	  %163 = fadd double %156, %160
DOALL:     	  %164 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %165 = fadd double %158, %162
DOALL:     	  %166 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 1
DOALL:     	  %171 = fsub double %168, %170
DOALL:     	  %172 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %175 = fadd double %173, %174
DOALL:     	  %176 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %273, double* %274, align 8, !tbaa !42
DOALL:     	  store double %275, double* %276, align 8, !tbaa !45
DOALL:     	  store double %281, double* %282, align 8, !tbaa !42
DOALL:     	  store double %285, double* %286, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %263, label %264, label %287, !prof !58
DOALL:     	  %273 = fadd double %266, %270
DOALL:     	  %274 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %275 = fadd double %268, %272
DOALL:     	  %276 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 1
DOALL:     	  %281 = fsub double %278, %280
DOALL:     	  %282 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %285 = fadd double %283, %284
DOALL:     	  %286 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %163, double* %164, align 8, !tbaa !42
DOALL:     	  store double %165, double* %166, align 8, !tbaa !45
DOALL:     	  store double %171, double* %172, align 8, !tbaa !42
DOALL:     	  store double %175, double* %176, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %153, label %154, label %177, !prof !58
DOALL:     	  %163 = fadd double %156, %160
DOALL:     	  %164 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %165 = fadd double %158, %162
DOALL:     	  %166 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 1
DOALL:     	  %171 = fsub double %168, %170
DOALL:     	  %172 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %175 = fadd double %173, %174
DOALL:     	  %176 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %229, double* %230, align 8, !tbaa !42
DOALL:     	  store double %231, double* %232, align 8, !tbaa !45
DOALL:     	  store double %237, double* %238, align 8, !tbaa !42
DOALL:     	  store double %241, double* %242, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %218, label %220, label %219, !prof !55
DOALL:     	  %229 = fadd double %222, %226
DOALL:     	  %230 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %231 = fadd double %224, %228
DOALL:     	  %232 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 1
DOALL:     	  %237 = fsub double %234, %236
DOALL:     	  %238 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %241 = fadd double %239, %240
DOALL:     	  %242 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %119, double* %120, align 8, !tbaa !42
DOALL:     	  store double %121, double* %122, align 8, !tbaa !45
DOALL:     	  store double %127, double* %128, align 8, !tbaa !42
DOALL:     	  store double %131, double* %132, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %108, label %110, label %109, !prof !55
DOALL:     	  %119 = fadd double %112, %116
DOALL:     	  %120 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %121 = fadd double %114, %118
DOALL:     	  %122 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 1
DOALL:     	  %127 = fsub double %124, %126
DOALL:     	  %128 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %131 = fadd double %129, %130
DOALL:     	  %132 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %229, double* %230, align 8, !tbaa !42
DOALL:     	  store double %231, double* %232, align 8, !tbaa !45
DOALL:     	  store double %237, double* %238, align 8, !tbaa !42
DOALL:     	  store double %241, double* %242, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %218, label %220, label %219, !prof !55
DOALL:     	  %229 = fadd double %222, %226
DOALL:     	  %230 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %231 = fadd double %224, %228
DOALL:     	  %232 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 1
DOALL:     	  %237 = fsub double %234, %236
DOALL:     	  %238 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %241 = fadd double %239, %240
DOALL:     	  %242 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %119, double* %120, align 8, !tbaa !42
DOALL:     	  store double %121, double* %122, align 8, !tbaa !45
DOALL:     	  store double %127, double* %128, align 8, !tbaa !42
DOALL:     	  store double %131, double* %132, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %108, label %110, label %109, !prof !55
DOALL:     	  %119 = fadd double %112, %116
DOALL:     	  %120 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %121 = fadd double %114, %118
DOALL:     	  %122 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 1
DOALL:     	  %127 = fsub double %124, %126
DOALL:     	  %128 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %131 = fadd double %129, %130
DOALL:     	  %132 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %163, double* %164, align 8, !tbaa !42
DOALL:     	  store double %165, double* %166, align 8, !tbaa !45
DOALL:     	  store double %171, double* %172, align 8, !tbaa !42
DOALL:     	  store double %175, double* %176, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %153, label %154, label %177, !prof !58
DOALL:     	  %163 = fadd double %156, %160
DOALL:     	  %164 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %165 = fadd double %158, %162
DOALL:     	  %166 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 1
DOALL:     	  %171 = fsub double %168, %170
DOALL:     	  %172 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %175 = fadd double %173, %174
DOALL:     	  %176 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %273, double* %274, align 8, !tbaa !42
DOALL:     	  store double %275, double* %276, align 8, !tbaa !45
DOALL:     	  store double %281, double* %282, align 8, !tbaa !42
DOALL:     	  store double %285, double* %286, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %263, label %264, label %287, !prof !58
DOALL:     	  %273 = fadd double %266, %270
DOALL:     	  %274 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %275 = fadd double %268, %272
DOALL:     	  %276 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 1
DOALL:     	  %281 = fsub double %278, %280
DOALL:     	  %282 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %285 = fadd double %283, %284
DOALL:     	  %286 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %163, double* %164, align 8, !tbaa !42
DOALL:     	  store double %165, double* %166, align 8, !tbaa !45
DOALL:     	  store double %171, double* %172, align 8, !tbaa !42
DOALL:     	  store double %175, double* %176, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %153, label %154, label %177, !prof !58
DOALL:     	  %163 = fadd double %156, %160
DOALL:     	  %164 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %165 = fadd double %158, %162
DOALL:     	  %166 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 1
DOALL:     	  %171 = fsub double %168, %170
DOALL:     	  %172 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %175 = fadd double %173, %174
DOALL:     	  %176 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %273, double* %274, align 8, !tbaa !42
DOALL:     	  store double %275, double* %276, align 8, !tbaa !45
DOALL:     	  store double %281, double* %282, align 8, !tbaa !42
DOALL:     	  store double %285, double* %286, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %263, label %264, label %287, !prof !58
DOALL:     	  %273 = fadd double %266, %270
DOALL:     	  %274 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %275 = fadd double %268, %272
DOALL:     	  %276 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 1
DOALL:     	  %281 = fsub double %278, %280
DOALL:     	  %282 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %285 = fadd double %283, %284
DOALL:     	  %286 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %119, double* %120, align 8, !tbaa !42
DOALL:     	  store double %121, double* %122, align 8, !tbaa !45
DOALL:     	  store double %127, double* %128, align 8, !tbaa !42
DOALL:     	  store double %131, double* %132, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %108, label %110, label %109, !prof !55
DOALL:     	  %119 = fadd double %112, %116
DOALL:     	  %120 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %121 = fadd double %114, %118
DOALL:     	  %122 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 1
DOALL:     	  %127 = fsub double %124, %126
DOALL:     	  %128 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %131 = fadd double %129, %130
DOALL:     	  %132 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %229, double* %230, align 8, !tbaa !42
DOALL:     	  store double %231, double* %232, align 8, !tbaa !45
DOALL:     	  store double %237, double* %238, align 8, !tbaa !42
DOALL:     	  store double %241, double* %242, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %218, label %220, label %219, !prof !55
DOALL:     	  %229 = fadd double %222, %226
DOALL:     	  %230 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %231 = fadd double %224, %228
DOALL:     	  %232 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 1
DOALL:     	  %237 = fsub double %234, %236
DOALL:     	  %238 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %241 = fadd double %239, %240
DOALL:     	  %242 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %229, double* %230, align 8, !tbaa !42
DOALL:     	  store double %231, double* %232, align 8, !tbaa !45
DOALL:     	  store double %237, double* %238, align 8, !tbaa !42
DOALL:     	  store double %241, double* %242, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %218, label %220, label %219, !prof !55
DOALL:     	  %229 = fadd double %222, %226
DOALL:     	  %230 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %231 = fadd double %224, %228
DOALL:     	  %232 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 1
DOALL:     	  %237 = fsub double %234, %236
DOALL:     	  %238 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %241 = fadd double %239, %240
DOALL:     	  %242 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %273, double* %274, align 8, !tbaa !42
DOALL:     	  store double %275, double* %276, align 8, !tbaa !45
DOALL:     	  store double %281, double* %282, align 8, !tbaa !42
DOALL:     	  store double %285, double* %286, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %263, label %264, label %287, !prof !58
DOALL:     	  %273 = fadd double %266, %270
DOALL:     	  %274 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %275 = fadd double %268, %272
DOALL:     	  %276 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 1
DOALL:     	  %281 = fsub double %278, %280
DOALL:     	  %282 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %285 = fadd double %283, %284
DOALL:     	  %286 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %163, double* %164, align 8, !tbaa !42
DOALL:     	  store double %165, double* %166, align 8, !tbaa !45
DOALL:     	  store double %171, double* %172, align 8, !tbaa !42
DOALL:     	  store double %175, double* %176, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %153, label %154, label %177, !prof !58
DOALL:     	  %163 = fadd double %156, %160
DOALL:     	  %164 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %165 = fadd double %158, %162
DOALL:     	  %166 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 1
DOALL:     	  %171 = fsub double %168, %170
DOALL:     	  %172 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %175 = fadd double %173, %174
DOALL:     	  %176 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %119, double* %120, align 8, !tbaa !42
DOALL:     	  store double %121, double* %122, align 8, !tbaa !45
DOALL:     	  store double %127, double* %128, align 8, !tbaa !42
DOALL:     	  store double %131, double* %132, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %108, label %110, label %109, !prof !55
DOALL:     	  %119 = fadd double %112, %116
DOALL:     	  %120 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %121 = fadd double %114, %118
DOALL:     	  %122 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 1
DOALL:     	  %127 = fsub double %124, %126
DOALL:     	  %128 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %131 = fadd double %129, %130
DOALL:     	  %132 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8
ClonableMemoryObject:   It is clonable
ClonableMemoryObject:   It requires initialization
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca double, align 8 can be cloned
MemoryCloningAnalysis:     The private copies need to be initialized with the original object.
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 3
DOALL:     	  store double %59, double* %60, align 8, !tbaa !33
DOALL:     	  %73 = load i64, i64* %72, align 8, !tbaa !33
DOALL:     	  %78 = load i64, i64* %77, align 8, !tbaa !33
DOALL:     External nodes: 8
DOALL:     	  br i1 %36, label %vranlc.exit, label %37, !prof !40
DOALL:     	  %59 = fmul double %58, 0x3D10000000000000
DOALL:     	  %60 = getelementptr inbounds double, double* %32, i64 %indvars.iv.i
DOALL:     	  br i1 %exitcond, label %81, label %69, !prof !42
DOALL:     	  %72 = bitcast double* %71 to i64*
DOALL:     	  store i64 %73, i64* %75, align 16, !tbaa !43
DOALL:     	  %77 = bitcast double* %76 to i64*
DOALL:     	  store i64 %78, i64* %80, align 8, !tbaa !45
DOALL:     Edges: 14
DOALL:     Loop-carried data dependences
DOALL:         store double %59, double* %60, align 8, !tbaa !33 --->   %78 = load i64, i64* %77, align 8, !tbaa !33 via memory
DOALL:         store double %59, double* %60, align 8, !tbaa !33 --->   store double %59, double* %60, align 8, !tbaa !33 via memory
DOALL:         store double %59, double* %60, align 8, !tbaa !33 --->   %73 = load i64, i64* %72, align 8, !tbaa !33 via memory
DOALL:         %73 = load i64, i64* %72, align 8, !tbaa !33 --->   store double %59, double* %60, align 8, !tbaa !33 via memory
DOALL:         %78 = load i64, i64* %77, align 8, !tbaa !33 --->   store double %59, double* %60, align 8, !tbaa !33 via memory
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 24
DOALL:     	  %28 = load i64, i64* %19, align 8, !tbaa !33
DOALL:     	  %93 = load double, double* %4, align 8, !tbaa !33
DOALL:     	  %94 = fmul double %93, 0x3E80000000000000
DOALL:     	  %95 = fptosi double %94 to i32
DOALL:     	  %96 = sitofp i32 %95 to double
DOALL:     	  %97 = fmul double %96, 0x4160000000000000
DOALL:     	  %98 = fsub double %93, %97
DOALL:     	  %99 = fmul double %98, %90
DOALL:     	  %100 = fmul double %92, %96
DOALL:     	  %101 = fadd double %99, %100
DOALL:     	  %102 = fmul double %101, 0x3E80000000000000
DOALL:     	  %103 = fptosi double %102 to i32
DOALL:     	  %104 = sitofp i32 %103 to double
DOALL:     	  %105 = fmul double %104, 0x4160000000000000
DOALL:     	  %106 = fsub double %101, %105
DOALL:     	  %107 = fmul double %106, 0x4160000000000000
DOALL:     	  %108 = fmul double %92, %98
DOALL:     	  %109 = fadd double %107, %108
DOALL:     	  %110 = fmul double %109, 0x3D10000000000000
DOALL:     	  %111 = fptosi double %110 to i32
DOALL:     	  %112 = sitofp i32 %111 to double
DOALL:     	  %113 = fmul double %112, 0x42D0000000000000
DOALL:     	  %114 = fsub double %109, %113
DOALL:     	  store double %114, double* %4, align 8, !tbaa !33
DOALL:     External nodes: 6
DOALL:     	  br i1 %26, label %27, label %116, !prof !39
DOALL:     	  store i64 %28, i64* %20, align 8, !tbaa !33
DOALL:     	  br i1 %86, label %.._crit_edge_crit_edge, label %87, !prof !46
DOALL:     	  %90 = sitofp i32 %89 to double
DOALL:     	  %92 = fsub double %21, %91
DOALL:     	  %115 = fmul double %114, 0x3D10000000000000
DOALL:     Edges: 61
DOALL:     Loop-carried data dependences
DOALL:         store double %114, double* %4, align 8, !tbaa !33 --->   %28 = load i64, i64* %19, align 8, !tbaa !33 via memory
DOALL:         store double %114, double* %4, align 8, !tbaa !33 --->   %93 = load double, double* %4, align 8, !tbaa !33 via memory
DOALL:         store double %114, double* %4, align 8, !tbaa !33 --->   store double %114, double* %4, align 8, !tbaa !33 via memory
DOALL:         %28 = load i64, i64* %19, align 8, !tbaa !33 --->   store double %114, double* %4, align 8, !tbaa !33 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 6
DOALL:     	  %.0 = phi i64 [ %indvars.iv4.lcssa, %81 ], [ 1, %vranlc.exit ]
DOALL:     	  %sext = shl i64 %.0, 32
DOALL:     	  %67 = ashr exact i64 %sext, 32
DOALL:     	  %indvars.iv4 = phi i64 [ %indvars.iv.next5, %69 ], [ %67, %66 ]
DOALL:     	  %indvars.iv.next5 = add nsw i64 %indvars.iv4, 2
DOALL:     	  %indvars.iv4.lcssa = phi i64 [ %indvars.iv4, %68 ]
DOALL:     External nodes: 4
DOALL:     	  br i1 %65, label %66, label %82, !prof !41
DOALL:     	  br i1 %exitcond, label %81, label %69, !prof !42
DOALL:     	  %70 = add nsw i64 %indvars.iv4, 1
DOALL:     	  %71 = getelementptr inbounds [524289 x double], [524289 x double]* @compute_initial_conditions.tmp, i64 0, i64 %indvars.iv4
DOALL:     Edges: 16
DOALL:     Loop-carried data dependences
DOALL:         %indvars.iv4.lcssa = phi i64 [ %indvars.iv4, %68 ] --->   %.0 = phi i64 [ %indvars.iv4.lcssa, %81 ], [ 1, %vranlc.exit ] via variable
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
Inliner:   Inlining in: main (111 instructions. The inlining will add 451 instructions),   call fastcc void @cffts3(i32 -1, i32* %46, [256 x [512 x %struct.dcomplex]]* %47, [256 x [512 x %struct.dcomplex]]* %47, [18 x %struct.dcomplex]* nonnull %44, [18 x %struct.dcomplex]* nonnull %45) #13
Inliner:   Inlined calls due to loop-carried data dependences
Inliner: Exit
Noelle:  Function "main"
Noelle:     Loop "  %exitcond8 = icmp eq i32 %.02, 7" (6.555052e-09%)
Noelle:     Loop "  %exitcond = icmp eq i32 %.1, 7" (6.555052e-09%)
Noelle:     Loop "  %.b4 = load i1, i1* @niter, align 4" (3.625788e+01%)
Noelle:  Function "fft"
Noelle:  Function "cfftz"
Noelle:     Loop "  %12 = icmp sgt i32 %.0, %1" (2.898565e+01%)
Noelle:     Loop "  %77 = icmp slt i64 %indvars.iv16.i11, %29" (1.349278e+01%)
Noelle:     Loop "  %90 = icmp slt i64 %indvars.iv14.i13, %28" (1.339172e+01%)
Noelle:     Loop "  %97 = icmp slt i64 %indvars.iv12.i14, %27" (1.311014e+01%)
Noelle:     Loop "  %32 = icmp slt i64 %indvars.iv10.i4, %29" (1.348650e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv8.i6, %28" (1.339172e+00%)
Noelle:     Loop "  %52 = icmp slt i64 %indvars.iv.i8, %27" (1.311014e+00%)
Noelle:     Loop "  %188 = icmp slt i64 %indvars.iv16.i, %140" (1.285027e+01%)
Noelle:     Loop "  %201 = icmp slt i64 %indvars.iv14.i, %139" (1.275402e+01%)
Noelle:     Loop "  %208 = icmp slt i64 %indvars.iv12.i, %138" (1.248584e+01%)
Noelle:     Loop "  %143 = icmp slt i64 %indvars.iv10.i, %140" (1.284428e+00%)
Noelle:     Loop "  %155 = icmp slt i64 %indvars.iv8.i, %139" (1.275402e+00%)
Noelle:     Loop "  %163 = icmp slt i64 %indvars.iv.i, %138" (1.248584e+00%)
Noelle:     Loop "  %242 = icmp slt i64 %indvars.iv5, %240" (1.268438e+00%)
Noelle:     Loop "  %244 = icmp slt i64 %indvars.iv, %239" (1.241328e+00%)
Noelle:  Function "fftz2"
Noelle:     Loop "  %70 = icmp slt i64 %indvars.iv16, %22" (2.634290e+01%)
Noelle:     Loop "  %83 = icmp slt i64 %indvars.iv14, %21" (2.614560e+01%)
Noelle:     Loop "  %90 = icmp slt i64 %indvars.iv12, %20" (2.559587e+01%)
Noelle:     Loop "  %25 = icmp slt i64 %indvars.iv10, %22" (2.632945e+00%)
Noelle:     Loop "  %37 = icmp slt i64 %indvars.iv8, %21" (2.614486e+00%)
Noelle:     Loop "  %45 = icmp slt i64 %indvars.iv, %20" (2.559539e+00%)
Noelle:  Function "cffts3"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (4.724529e-07%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 1" (1.492791e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 0" (1.492790e+01%)
Noelle:     Loop "  %42 = icmp slt i64 %indvars.iv7, %40" (1.485121e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv, %39" (1.457985e+00%)
Noelle:     Loop "  %69 = icmp sgt i32 %.0.i, %21" (1.159403e+01%)
Noelle:     Loop "  %133 = icmp slt i64 %indvars.iv16.i11.i, %85" (5.397072e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv14.i13.i, %84" (5.356647e+00%)
Noelle:     Loop "  %153 = icmp slt i64 %indvars.iv12.i14.i, %83" (5.244014e+00%)
Noelle:     Loop "  %88 = icmp slt i64 %indvars.iv10.i4.i, %85" (5.394558e-01%)
Noelle:     Loop "  %100 = icmp slt i64 %indvars.iv8.i6.i, %84" (5.356647e-01%)
Noelle:     Loop "  %108 = icmp slt i64 %indvars.iv.i8.i, %83" (5.244014e-01%)
Noelle:     Loop "  %243 = icmp slt i64 %indvars.iv16.i.i, %195" (5.140069e+00%)
Noelle:     Loop "  %256 = icmp slt i64 %indvars.iv14.i.i, %194" (5.101568e+00%)
Noelle:     Loop "  %263 = icmp slt i64 %indvars.iv12.i.i, %193" (4.994299e+00%)
Noelle:     Loop "  %198 = icmp slt i64 %indvars.iv10.i.i, %195" (5.137674e-01%)
Noelle:     Loop "  %210 = icmp slt i64 %indvars.iv8.i.i, %194" (5.101568e-01%)
Noelle:     Loop "  %218 = icmp slt i64 %indvars.iv.i.i, %193" (4.994299e-01%)
Noelle:     Loop "  %297 = icmp slt i64 %indvars.iv5.i, %295" (5.073713e-01%)
Noelle:     Loop "  %299 = icmp slt i64 %indvars.iv.i, %294" (4.965274e-01%)
Noelle:     Loop "  %319 = icmp slt i64 %indvars.iv11, %317" (1.340677e+00%)
Noelle:     Loop "  %321 = icmp slt i64 %indvars.iv9, %315" (1.313541e+00%)
Noelle:  Function "cffts2"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (4.650173e-07%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 2" (1.492791e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 0" (1.492790e+01%)
Noelle:     Loop "  %42 = icmp slt i64 %indvars.iv7, %40" (1.485121e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv, %39" (1.457985e+00%)
Noelle:     Loop "  %69 = icmp sgt i32 %.0.i, %21" (1.159403e+01%)
Noelle:     Loop "  %133 = icmp slt i64 %indvars.iv16.i11.i, %85" (5.397072e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv14.i13.i, %84" (5.356647e+00%)
Noelle:     Loop "  %153 = icmp slt i64 %indvars.iv12.i14.i, %83" (5.244014e+00%)
Noelle:     Loop "  %88 = icmp slt i64 %indvars.iv10.i4.i, %85" (5.394558e-01%)
Noelle:     Loop "  %100 = icmp slt i64 %indvars.iv8.i6.i, %84" (5.356647e-01%)
Noelle:     Loop "  %108 = icmp slt i64 %indvars.iv.i8.i, %83" (5.244014e-01%)
Noelle:     Loop "  %243 = icmp slt i64 %indvars.iv16.i.i, %195" (5.140069e+00%)
Noelle:     Loop "  %256 = icmp slt i64 %indvars.iv14.i.i, %194" (5.101568e+00%)
Noelle:     Loop "  %263 = icmp slt i64 %indvars.iv12.i.i, %193" (4.994299e+00%)
Noelle:     Loop "  %198 = icmp slt i64 %indvars.iv10.i.i, %195" (5.137674e-01%)
Noelle:     Loop "  %210 = icmp slt i64 %indvars.iv8.i.i, %194" (5.101568e-01%)
Noelle:     Loop "  %218 = icmp slt i64 %indvars.iv.i.i, %193" (4.994299e-01%)
Noelle:     Loop "  %297 = icmp slt i64 %indvars.iv5.i, %295" (5.073713e-01%)
Noelle:     Loop "  %299 = icmp slt i64 %indvars.iv.i, %294" (4.965274e-01%)
Noelle:     Loop "  %319 = icmp slt i64 %indvars.iv11, %317" (1.340677e+00%)
Noelle:     Loop "  %321 = icmp slt i64 %indvars.iv9, %315" (1.313541e+00%)
Noelle:  Function "cffts1"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv14, 3" (4.650173e-07%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (8.509802e+00%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 1" (8.509797e+00%)
Noelle:     Loop "  %41 = icmp slt i64 %indvars.iv6, %39" (1.229501e+00%)
Noelle:     Loop "  %47 = icmp slt i64 %indvars.iv, %38" (1.228205e+00%)
Noelle:     Loop "  %69 = icmp sgt i32 %.0.i, %21" (5.797036e+00%)
Noelle:     Loop "  %133 = icmp slt i64 %indvars.iv16.i11.i, %85" (2.698546e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv14.i13.i, %84" (2.678334e+00%)
Noelle:     Loop "  %153 = icmp slt i64 %indvars.iv12.i14.i, %83" (2.622017e+00%)
Noelle:     Loop "  %88 = icmp slt i64 %indvars.iv10.i4.i, %85" (2.697289e-01%)
Noelle:     Loop "  %100 = icmp slt i64 %indvars.iv8.i6.i, %84" (2.678334e-01%)
Noelle:     Loop "  %108 = icmp slt i64 %indvars.iv.i8.i, %83" (2.622017e-01%)
Noelle:     Loop "  %243 = icmp slt i64 %indvars.iv16.i.i, %195" (2.570044e+00%)
Noelle:     Loop "  %256 = icmp slt i64 %indvars.iv14.i.i, %194" (2.550794e+00%)
Noelle:     Loop "  %263 = icmp slt i64 %indvars.iv12.i.i, %193" (2.497159e+00%)
Noelle:     Loop "  %198 = icmp slt i64 %indvars.iv10.i.i, %195" (2.568847e-01%)
Noelle:     Loop "  %210 = icmp slt i64 %indvars.iv8.i.i, %194" (2.550794e-01%)
Noelle:     Loop "  %218 = icmp slt i64 %indvars.iv.i.i, %193" (2.497159e-01%)
Noelle:     Loop "  %297 = icmp slt i64 %indvars.iv5.i, %295" (2.536866e-01%)
Noelle:     Loop "  %299 = icmp slt i64 %indvars.iv.i, %294" (2.482647e-01%)
Noelle:     Loop "  %319 = icmp slt i64 %indvars.iv10, %313" (1.229219e+00%)
Noelle:     Loop "  %323 = icmp slt i64 %indvars.iv8, %317" (1.228205e+00%)
Noelle:  Function "evolve"
Noelle:     Loop "  %16 = icmp slt i64 %indvars.iv5, %8" (1.379956e+00%)
Noelle:     Loop "  %18 = icmp slt i64 %indvars.iv3, %11" (1.379953e+00%)
Noelle:     Loop "  %20 = icmp slt i64 %indvars.iv, %14" (1.379182e+00%)
Noelle:  Function "compute_initial_conditions"
Noelle:     Loop "  %23 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (5.254375e-01%)
Noelle:     Loop "  %36 = icmp sgt i64 %indvars.iv.i, %34" (3.939408e-01%)
Noelle:     Loop "  %65 = icmp slt i64 %indvars.iv6, %63" (1.314938e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 512" (1.313653e-01%)
Noelle:  Function "vranlc"
Noelle:     Loop "  %13 = icmp sgt i64 %indvars.iv, %11" (3.939407e-01%)
Noelle:  Function "compute_indexmap"
Noelle:     Loop "  %15 = icmp slt i64 %indvars.iv10, %4" (9.233168e-02%)
Noelle:     Loop "  %23 = icmp slt i64 %indvars.iv8, %8" (9.233048e-02%)
Noelle:     Loop "  %33 = icmp slt i64 %indvars.iv6, %12" (9.199677e-02%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 1966081" (4.232832e-03%)
Noelle:  Function "checksum"
Noelle:     Loop "  %exitcond = icmp eq i32 %.0, 1025" (8.416491e-05%)
Noelle:  Function "randlc"
Noelle:  Function "fft_init"
Noelle:     Loop "  %7 = icmp sgt i32 %.01, %2" (1.530751e-06%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count" (1.505118e-06%)
Noelle:  Function "ilog2"
Noelle:     Loop "  %3 = icmp slt i32 %.01, %0" (1.083638e-06%)
Noelle:  Function "ipow46"
Noelle:     Loop "  %11 = icmp sgt i32 %.01, 1" (1.450917e-07%)
Noelle:  Function "verify"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 21" (4.529834e-08%)
Noelle:  Function "setup"
Noelle:     Loop "  %exitcond3 = icmp eq i64 %indvars.iv1, 3" (3.522117e-09%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 3" (5.283176e-09%)
Noelle:  Function "elapsed_time"
Noelle:  Function "timer_clear"
Noelle:  Function "c_print_results"
Noelle:  Function "wtime_"
Noelle:  Function "timer_stop"
Noelle:  Function "timer_start"
Noelle:  Function "timer_read"
Noelle:  Function "main"
Noelle:     Loop "  %exitcond8 = icmp eq i32 %.02, 7" (5.771826e-09%)
Noelle:     Loop "  %exitcond = icmp eq i32 %.1, 7" (5.771826e-09%)
Noelle:     Loop "  %.b4 = load i1, i1* @niter, align 4" (3.192474e+01%)
Noelle:     Loop "  %exitcond.i = icmp eq i64 %indvars.iv15.i, 3" (3.722397e-07%)
Noelle:     Loop "  %66 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 1" (1.194843e+01%)
Noelle:     Loop "  %73 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 0" (1.194843e+01%)
Noelle:     Loop "  %83 = icmp slt i64 %indvars.iv7.i, %81" (1.188707e+00%)
Noelle:     Loop "  %85 = icmp slt i64 %indvars.iv.i, %80" (1.166987e+00%)
Noelle:     Loop "  %109 = icmp sgt i32 %.0.i.i, %62" (9.280030e+00%)
Noelle:     Loop "  %127 = icmp slt i64 %indvars.iv16.i11.i.i, %124" (4.751862e+00%)
Noelle:     Loop "  %140 = icmp slt i64 %indvars.iv14.i13.i.i, %123" (4.716269e+00%)
Noelle:     Loop "  %147 = icmp slt i64 %indvars.iv12.i14.i.i, %122" (4.617102e+00%)
Noelle:     Loop "  %191 = icmp slt i64 %indvars.iv16.i.i.i, %188" (4.525583e+00%)
Noelle:     Loop "  %204 = icmp slt i64 %indvars.iv14.i.i.i, %187" (4.491685e+00%)
Noelle:     Loop "  %211 = icmp slt i64 %indvars.iv12.i.i.i, %186" (4.397240e+00%)
Noelle:     Loop "  %245 = icmp slt i64 %indvars.iv5.i.i, %243" (4.061055e-01%)
Noelle:     Loop "  %247 = icmp slt i64 %indvars.iv.i.i, %242" (3.974259e-01%)
Noelle:     Loop "  %267 = icmp slt i64 %indvars.iv11.i, %265" (1.073092e+00%)
Noelle:     Loop "  %269 = icmp slt i64 %indvars.iv9.i, %263" (1.051372e+00%)
Noelle:  Function "fft"
Noelle:  Function "cfftz"
Noelle:     Loop "  %12 = icmp sgt i32 %.0, %1" (2.552232e+01%)
Noelle:     Loop "  %77 = icmp slt i64 %indvars.iv16.i11, %29" (1.188061e+01%)
Noelle:     Loop "  %90 = icmp slt i64 %indvars.iv14.i13, %28" (1.179162e+01%)
Noelle:     Loop "  %97 = icmp slt i64 %indvars.iv12.i14, %27" (1.154368e+01%)
Noelle:     Loop "  %32 = icmp slt i64 %indvars.iv10.i4, %29" (1.187507e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv8.i6, %28" (1.179162e+00%)
Noelle:     Loop "  %52 = icmp slt i64 %indvars.iv.i8, %27" (1.154368e+00%)
Noelle:     Loop "  %188 = icmp slt i64 %indvars.iv16.i, %140" (1.131486e+01%)
Noelle:     Loop "  %201 = icmp slt i64 %indvars.iv14.i, %139" (1.123011e+01%)
Noelle:     Loop "  %208 = icmp slt i64 %indvars.iv12.i, %138" (1.099398e+01%)
Noelle:     Loop "  %143 = icmp slt i64 %indvars.iv10.i, %140" (1.130959e+00%)
Noelle:     Loop "  %155 = icmp slt i64 %indvars.iv8.i, %139" (1.123011e+00%)
Noelle:     Loop "  %163 = icmp slt i64 %indvars.iv.i, %138" (1.099398e+00%)
Noelle:     Loop "  %242 = icmp slt i64 %indvars.iv5, %240" (1.116880e+00%)
Noelle:     Loop "  %244 = icmp slt i64 %indvars.iv, %239" (1.093009e+00%)
Noelle:  Function "fftz2"
Noelle:     Loop "  %70 = icmp slt i64 %indvars.iv16, %22" (2.319534e+01%)
Noelle:     Loop "  %83 = icmp slt i64 %indvars.iv14, %21" (2.302161e+01%)
Noelle:     Loop "  %90 = icmp slt i64 %indvars.iv12, %20" (2.253757e+01%)
Noelle:     Loop "  %25 = icmp slt i64 %indvars.iv10, %22" (2.318349e+00%)
Noelle:     Loop "  %37 = icmp slt i64 %indvars.iv8, %21" (2.302096e+00%)
Noelle:     Loop "  %45 = icmp slt i64 %indvars.iv, %20" (2.253714e+00%)
Noelle:  Function "cffts3"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (9.553664e-08%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 1" (1.314426e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 0" (1.314425e+01%)
Noelle:     Loop "  %42 = icmp slt i64 %indvars.iv7, %40" (1.307673e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv, %39" (1.283779e+00%)
Noelle:     Loop "  %69 = icmp sgt i32 %.0.i, %21" (1.020872e+01%)
Noelle:     Loop "  %133 = icmp slt i64 %indvars.iv16.i11.i, %85" (4.752206e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv14.i13.i, %84" (4.716611e+00%)
Noelle:     Loop "  %153 = icmp slt i64 %indvars.iv12.i14.i, %83" (4.617437e+00%)
Noelle:     Loop "  %88 = icmp slt i64 %indvars.iv10.i4.i, %85" (4.749993e-01%)
Noelle:     Loop "  %100 = icmp slt i64 %indvars.iv8.i6.i, %84" (4.716611e-01%)
Noelle:     Loop "  %108 = icmp slt i64 %indvars.iv.i8.i, %83" (4.617437e-01%)
Noelle:     Loop "  %243 = icmp slt i64 %indvars.iv16.i.i, %195" (4.525911e+00%)
Noelle:     Loop "  %256 = icmp slt i64 %indvars.iv14.i.i, %194" (4.492011e+00%)
Noelle:     Loop "  %263 = icmp slt i64 %indvars.iv12.i.i, %193" (4.397559e+00%)
Noelle:     Loop "  %198 = icmp slt i64 %indvars.iv10.i.i, %195" (4.523803e-01%)
Noelle:     Loop "  %210 = icmp slt i64 %indvars.iv8.i.i, %194" (4.492011e-01%)
Noelle:     Loop "  %218 = icmp slt i64 %indvars.iv.i.i, %193" (4.397559e-01%)
Noelle:     Loop "  %297 = icmp slt i64 %indvars.iv5.i, %295" (4.467484e-01%)
Noelle:     Loop "  %299 = icmp slt i64 %indvars.iv.i, %294" (4.372002e-01%)
Noelle:     Loop "  %319 = icmp slt i64 %indvars.iv11, %317" (1.180487e+00%)
Noelle:     Loop "  %321 = icmp slt i64 %indvars.iv9, %315" (1.156593e+00%)
Noelle:  Function "cffts2"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (4.094550e-07%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 2" (1.314426e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 0" (1.314425e+01%)
Noelle:     Loop "  %42 = icmp slt i64 %indvars.iv7, %40" (1.307673e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv, %39" (1.283779e+00%)
Noelle:     Loop "  %69 = icmp sgt i32 %.0.i, %21" (1.020872e+01%)
Noelle:     Loop "  %133 = icmp slt i64 %indvars.iv16.i11.i, %85" (4.752206e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv14.i13.i, %84" (4.716611e+00%)
Noelle:     Loop "  %153 = icmp slt i64 %indvars.iv12.i14.i, %83" (4.617437e+00%)
Noelle:     Loop "  %88 = icmp slt i64 %indvars.iv10.i4.i, %85" (4.749993e-01%)
Noelle:     Loop "  %100 = icmp slt i64 %indvars.iv8.i6.i, %84" (4.716611e-01%)
Noelle:     Loop "  %108 = icmp slt i64 %indvars.iv.i8.i, %83" (4.617437e-01%)
Noelle:     Loop "  %243 = icmp slt i64 %indvars.iv16.i.i, %195" (4.525911e+00%)
Noelle:     Loop "  %256 = icmp slt i64 %indvars.iv14.i.i, %194" (4.492011e+00%)
Noelle:     Loop "  %263 = icmp slt i64 %indvars.iv12.i.i, %193" (4.397559e+00%)
Noelle:     Loop "  %198 = icmp slt i64 %indvars.iv10.i.i, %195" (4.523803e-01%)
Noelle:     Loop "  %210 = icmp slt i64 %indvars.iv8.i.i, %194" (4.492011e-01%)
Noelle:     Loop "  %218 = icmp slt i64 %indvars.iv.i.i, %193" (4.397559e-01%)
Noelle:     Loop "  %297 = icmp slt i64 %indvars.iv5.i, %295" (4.467484e-01%)
Noelle:     Loop "  %299 = icmp slt i64 %indvars.iv.i, %294" (4.372002e-01%)
Noelle:     Loop "  %319 = icmp slt i64 %indvars.iv11, %317" (1.180487e+00%)
Noelle:     Loop "  %321 = icmp slt i64 %indvars.iv9, %315" (1.156593e+00%)
Noelle:  Function "cffts1"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv14, 3" (4.094550e-07%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (7.493014e+00%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 1" (7.493009e+00%)
Noelle:     Loop "  %41 = icmp slt i64 %indvars.iv6, %39" (1.082595e+00%)
Noelle:     Loop "  %47 = icmp slt i64 %indvars.iv, %38" (1.081454e+00%)
Noelle:     Loop "  %69 = icmp sgt i32 %.0.i, %21" (5.104381e+00%)
Noelle:     Loop "  %133 = icmp slt i64 %indvars.iv16.i11.i, %85" (2.376112e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv14.i13.i, %84" (2.358315e+00%)
Noelle:     Loop "  %153 = icmp slt i64 %indvars.iv12.i14.i, %83" (2.308727e+00%)
Noelle:     Loop "  %88 = icmp slt i64 %indvars.iv10.i4.i, %85" (2.375005e-01%)
Noelle:     Loop "  %100 = icmp slt i64 %indvars.iv8.i6.i, %84" (2.358315e-01%)
Noelle:     Loop "  %108 = icmp slt i64 %indvars.iv.i8.i, %83" (2.308727e-01%)
Noelle:     Loop "  %243 = icmp slt i64 %indvars.iv16.i.i, %195" (2.262964e+00%)
Noelle:     Loop "  %256 = icmp slt i64 %indvars.iv14.i.i, %194" (2.246014e+00%)
Noelle:     Loop "  %263 = icmp slt i64 %indvars.iv12.i.i, %193" (2.198788e+00%)
Noelle:     Loop "  %198 = icmp slt i64 %indvars.iv10.i.i, %195" (2.261910e-01%)
Noelle:     Loop "  %210 = icmp slt i64 %indvars.iv8.i.i, %194" (2.246014e-01%)
Noelle:     Loop "  %218 = icmp slt i64 %indvars.iv.i.i, %193" (2.198788e-01%)
Noelle:     Loop "  %297 = icmp slt i64 %indvars.iv5.i, %295" (2.233751e-01%)
Noelle:     Loop "  %299 = icmp slt i64 %indvars.iv.i, %294" (2.186009e-01%)
Noelle:     Loop "  %319 = icmp slt i64 %indvars.iv10, %313" (1.082346e+00%)
Noelle:     Loop "  %323 = icmp slt i64 %indvars.iv8, %317" (1.081454e+00%)
Noelle:  Function "evolve"
Noelle:     Loop "  %16 = icmp slt i64 %indvars.iv5, %8" (1.215073e+00%)
Noelle:     Loop "  %18 = icmp slt i64 %indvars.iv3, %11" (1.215070e+00%)
Noelle:     Loop "  %20 = icmp slt i64 %indvars.iv, %14" (1.214391e+00%)
Noelle:  Function "compute_initial_conditions"
Noelle:     Loop "  %23 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (4.626560e-01%)
Noelle:     Loop "  %36 = icmp sgt i64 %indvars.iv.i, %34" (3.468711e-01%)
Noelle:     Loop "  %65 = icmp slt i64 %indvars.iv6, %63" (1.157823e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 512" (1.156692e-01%)
Noelle:  Function "vranlc"
Noelle:     Loop "  %13 = icmp sgt i64 %indvars.iv, %11" (3.468709e-01%)
Noelle:  Function "compute_indexmap"
Noelle:     Loop "  %15 = icmp slt i64 %indvars.iv10, %4" (8.129949e-02%)
Noelle:     Loop "  %23 = icmp slt i64 %indvars.iv8, %8" (8.129844e-02%)
Noelle:     Loop "  %33 = icmp slt i64 %indvars.iv6, %12" (8.100459e-02%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 1966081" (3.727075e-03%)
Noelle:  Function "checksum"
Noelle:     Loop "  %exitcond = icmp eq i32 %.0, 1025" (7.410852e-05%)
Noelle:  Function "randlc"
Noelle:  Function "fft_init"
Noelle:     Loop "  %7 = icmp sgt i32 %.01, %2" (1.347851e-06%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count" (1.325280e-06%)
Noelle:  Function "ilog2"
Noelle:     Loop "  %3 = icmp slt i32 %.01, %0" (9.541603e-07%)
Noelle:  Function "ipow46"
Noelle:     Loop "  %11 = icmp sgt i32 %.01, 1" (1.277555e-07%)
Noelle:  Function "verify"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 21" (3.988590e-08%)
Noelle:  Function "setup"
Noelle:     Loop "  %exitcond3 = icmp eq i64 %indvars.iv1, 3" (3.101280e-09%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 3" (4.651919e-09%)
Noelle:  Function "elapsed_time"
Noelle:  Function "timer_clear"
Noelle:  Function "c_print_results"
Noelle:  Function "wtime_"
Noelle:  Function "timer_stop"
Noelle:  Function "timer_start"
Noelle:  Function "timer_read"
NOELLE: FixedPoint:       There are 259 different instructions and 1190 different loop instructions
NOELLE: FixedPoint:       Normalize the code
noelle-norm /tmp/tmp.mEnWC8flov -o /tmp/tmp.mEnWC8flov
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.mEnWC8flov -o /tmp/tmp.mEnWC8flov
NOELLE: FixedPoint:     Invocation 4
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.1zCLAhAajz -o /tmp/tmp.mEnWC8flov
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.1zCLAhAajz -o /tmp/tmp.mEnWC8flov
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.1zCLAhAajz -o /tmp/tmp.mEnWC8flov
Inliner: Start
Inliner:   Number of program instructions = 2986
Inliner:   Profiles are available and will be used
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %163, double* %164, align 8, !tbaa !42
DOALL:     	  store double %165, double* %166, align 8, !tbaa !45
DOALL:     	  store double %171, double* %172, align 8, !tbaa !42
DOALL:     	  store double %175, double* %176, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %153, label %154, label %177, !prof !58
DOALL:     	  %163 = fadd double %156, %160
DOALL:     	  %164 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %165 = fadd double %158, %162
DOALL:     	  %166 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 1
DOALL:     	  %171 = fsub double %168, %170
DOALL:     	  %172 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %175 = fadd double %173, %174
DOALL:     	  %176 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %273, double* %274, align 8, !tbaa !42
DOALL:     	  store double %275, double* %276, align 8, !tbaa !45
DOALL:     	  store double %281, double* %282, align 8, !tbaa !42
DOALL:     	  store double %285, double* %286, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %263, label %264, label %287, !prof !58
DOALL:     	  %273 = fadd double %266, %270
DOALL:     	  %274 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %275 = fadd double %268, %272
DOALL:     	  %276 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 1
DOALL:     	  %281 = fsub double %278, %280
DOALL:     	  %282 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %285 = fadd double %283, %284
DOALL:     	  %286 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %229, double* %230, align 8, !tbaa !42
DOALL:     	  store double %231, double* %232, align 8, !tbaa !45
DOALL:     	  store double %237, double* %238, align 8, !tbaa !42
DOALL:     	  store double %241, double* %242, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %218, label %220, label %219, !prof !55
DOALL:     	  %229 = fadd double %222, %226
DOALL:     	  %230 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %231 = fadd double %224, %228
DOALL:     	  %232 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 1
DOALL:     	  %237 = fsub double %234, %236
DOALL:     	  %238 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %241 = fadd double %239, %240
DOALL:     	  %242 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %119, double* %120, align 8, !tbaa !42
DOALL:     	  store double %121, double* %122, align 8, !tbaa !45
DOALL:     	  store double %127, double* %128, align 8, !tbaa !42
DOALL:     	  store double %131, double* %132, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %108, label %110, label %109, !prof !55
DOALL:     	  %119 = fadd double %112, %116
DOALL:     	  %120 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %121 = fadd double %114, %118
DOALL:     	  %122 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 1
DOALL:     	  %127 = fsub double %124, %126
DOALL:     	  %128 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %131 = fadd double %129, %130
DOALL:     	  %132 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %273, double* %274, align 8, !tbaa !42
DOALL:     	  store double %275, double* %276, align 8, !tbaa !45
DOALL:     	  store double %281, double* %282, align 8, !tbaa !42
DOALL:     	  store double %285, double* %286, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %263, label %264, label %287, !prof !58
DOALL:     	  %273 = fadd double %266, %270
DOALL:     	  %274 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %275 = fadd double %268, %272
DOALL:     	  %276 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 1
DOALL:     	  %281 = fsub double %278, %280
DOALL:     	  %282 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %285 = fadd double %283, %284
DOALL:     	  %286 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %229, double* %230, align 8, !tbaa !42
DOALL:     	  store double %231, double* %232, align 8, !tbaa !45
DOALL:     	  store double %237, double* %238, align 8, !tbaa !42
DOALL:     	  store double %241, double* %242, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %218, label %220, label %219, !prof !55
DOALL:     	  %229 = fadd double %222, %226
DOALL:     	  %230 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %231 = fadd double %224, %228
DOALL:     	  %232 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 1
DOALL:     	  %237 = fsub double %234, %236
DOALL:     	  %238 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %241 = fadd double %239, %240
DOALL:     	  %242 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %119, double* %120, align 8, !tbaa !42
DOALL:     	  store double %121, double* %122, align 8, !tbaa !45
DOALL:     	  store double %127, double* %128, align 8, !tbaa !42
DOALL:     	  store double %131, double* %132, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %108, label %110, label %109, !prof !55
DOALL:     	  %119 = fadd double %112, %116
DOALL:     	  %120 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %121 = fadd double %114, %118
DOALL:     	  %122 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 1
DOALL:     	  %127 = fsub double %124, %126
DOALL:     	  %128 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %131 = fadd double %129, %130
DOALL:     	  %132 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %163, double* %164, align 8, !tbaa !42
DOALL:     	  store double %165, double* %166, align 8, !tbaa !45
DOALL:     	  store double %171, double* %172, align 8, !tbaa !42
DOALL:     	  store double %175, double* %176, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %153, label %154, label %177, !prof !58
DOALL:     	  %163 = fadd double %156, %160
DOALL:     	  %164 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %165 = fadd double %158, %162
DOALL:     	  %166 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 1
DOALL:     	  %171 = fsub double %168, %170
DOALL:     	  %172 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %175 = fadd double %173, %174
DOALL:     	  %176 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %273, double* %274, align 8, !tbaa !42
DOALL:     	  store double %275, double* %276, align 8, !tbaa !45
DOALL:     	  store double %281, double* %282, align 8, !tbaa !42
DOALL:     	  store double %285, double* %286, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %263, label %264, label %287, !prof !58
DOALL:     	  %273 = fadd double %266, %270
DOALL:     	  %274 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %275 = fadd double %268, %272
DOALL:     	  %276 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 1
DOALL:     	  %281 = fsub double %278, %280
DOALL:     	  %282 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %285 = fadd double %283, %284
DOALL:     	  %286 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %163, double* %164, align 8, !tbaa !42
DOALL:     	  store double %165, double* %166, align 8, !tbaa !45
DOALL:     	  store double %171, double* %172, align 8, !tbaa !42
DOALL:     	  store double %175, double* %176, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %153, label %154, label %177, !prof !58
DOALL:     	  %163 = fadd double %156, %160
DOALL:     	  %164 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %165 = fadd double %158, %162
DOALL:     	  %166 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 1
DOALL:     	  %171 = fsub double %168, %170
DOALL:     	  %172 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %175 = fadd double %173, %174
DOALL:     	  %176 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %119, double* %120, align 8, !tbaa !42
DOALL:     	  store double %121, double* %122, align 8, !tbaa !45
DOALL:     	  store double %127, double* %128, align 8, !tbaa !42
DOALL:     	  store double %131, double* %132, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %108, label %110, label %109, !prof !55
DOALL:     	  %119 = fadd double %112, %116
DOALL:     	  %120 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %121 = fadd double %114, %118
DOALL:     	  %122 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 1
DOALL:     	  %127 = fsub double %124, %126
DOALL:     	  %128 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %131 = fadd double %129, %130
DOALL:     	  %132 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %229, double* %230, align 8, !tbaa !42
DOALL:     	  store double %231, double* %232, align 8, !tbaa !45
DOALL:     	  store double %237, double* %238, align 8, !tbaa !42
DOALL:     	  store double %241, double* %242, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %218, label %220, label %219, !prof !55
DOALL:     	  %229 = fadd double %222, %226
DOALL:     	  %230 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %231 = fadd double %224, %228
DOALL:     	  %232 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 1
DOALL:     	  %237 = fsub double %234, %236
DOALL:     	  %238 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %241 = fadd double %239, %240
DOALL:     	  %242 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %273, double* %274, align 8, !tbaa !42
DOALL:     	  store double %275, double* %276, align 8, !tbaa !45
DOALL:     	  store double %281, double* %282, align 8, !tbaa !42
DOALL:     	  store double %285, double* %286, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %263, label %264, label %287, !prof !58
DOALL:     	  %273 = fadd double %266, %270
DOALL:     	  %274 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %275 = fadd double %268, %272
DOALL:     	  %276 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 1
DOALL:     	  %281 = fsub double %278, %280
DOALL:     	  %282 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %285 = fadd double %283, %284
DOALL:     	  %286 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %229, double* %230, align 8, !tbaa !42
DOALL:     	  store double %231, double* %232, align 8, !tbaa !45
DOALL:     	  store double %237, double* %238, align 8, !tbaa !42
DOALL:     	  store double %241, double* %242, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %218, label %220, label %219, !prof !55
DOALL:     	  %229 = fadd double %222, %226
DOALL:     	  %230 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %231 = fadd double %224, %228
DOALL:     	  %232 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 1
DOALL:     	  %237 = fsub double %234, %236
DOALL:     	  %238 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %241 = fadd double %239, %240
DOALL:     	  %242 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %119, double* %120, align 8, !tbaa !42
DOALL:     	  store double %121, double* %122, align 8, !tbaa !45
DOALL:     	  store double %127, double* %128, align 8, !tbaa !42
DOALL:     	  store double %131, double* %132, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %108, label %110, label %109, !prof !55
DOALL:     	  %119 = fadd double %112, %116
DOALL:     	  %120 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %121 = fadd double %114, %118
DOALL:     	  %122 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 1
DOALL:     	  %127 = fsub double %124, %126
DOALL:     	  %128 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %131 = fadd double %129, %130
DOALL:     	  %132 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %163, double* %164, align 8, !tbaa !42
DOALL:     	  store double %165, double* %166, align 8, !tbaa !45
DOALL:     	  store double %171, double* %172, align 8, !tbaa !42
DOALL:     	  store double %175, double* %176, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %153, label %154, label %177, !prof !58
DOALL:     	  %163 = fadd double %156, %160
DOALL:     	  %164 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %165 = fadd double %158, %162
DOALL:     	  %166 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 1
DOALL:     	  %171 = fsub double %168, %170
DOALL:     	  %172 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %175 = fadd double %173, %174
DOALL:     	  %176 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %163, double* %164, align 8, !tbaa !42
DOALL:     	  store double %165, double* %166, align 8, !tbaa !45
DOALL:     	  store double %171, double* %172, align 8, !tbaa !42
DOALL:     	  store double %175, double* %176, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %153, label %154, label %177, !prof !58
DOALL:     	  %163 = fadd double %156, %160
DOALL:     	  %164 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %165 = fadd double %158, %162
DOALL:     	  %166 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 1
DOALL:     	  %171 = fsub double %168, %170
DOALL:     	  %172 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %175 = fadd double %173, %174
DOALL:     	  %176 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %273, double* %274, align 8, !tbaa !42
DOALL:     	  store double %275, double* %276, align 8, !tbaa !45
DOALL:     	  store double %281, double* %282, align 8, !tbaa !42
DOALL:     	  store double %285, double* %286, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %263, label %264, label %287, !prof !58
DOALL:     	  %273 = fadd double %266, %270
DOALL:     	  %274 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %275 = fadd double %268, %272
DOALL:     	  %276 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 1
DOALL:     	  %281 = fsub double %278, %280
DOALL:     	  %282 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %285 = fadd double %283, %284
DOALL:     	  %286 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %119, double* %120, align 8, !tbaa !42
DOALL:     	  store double %121, double* %122, align 8, !tbaa !45
DOALL:     	  store double %127, double* %128, align 8, !tbaa !42
DOALL:     	  store double %131, double* %132, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %108, label %110, label %109, !prof !55
DOALL:     	  %119 = fadd double %112, %116
DOALL:     	  %120 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %121 = fadd double %114, %118
DOALL:     	  %122 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 1
DOALL:     	  %127 = fsub double %124, %126
DOALL:     	  %128 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %131 = fadd double %129, %130
DOALL:     	  %132 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %229, double* %230, align 8, !tbaa !42
DOALL:     	  store double %231, double* %232, align 8, !tbaa !45
DOALL:     	  store double %237, double* %238, align 8, !tbaa !42
DOALL:     	  store double %241, double* %242, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %218, label %220, label %219, !prof !55
DOALL:     	  %229 = fadd double %222, %226
DOALL:     	  %230 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %231 = fadd double %224, %228
DOALL:     	  %232 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 1
DOALL:     	  %237 = fsub double %234, %236
DOALL:     	  %238 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %241 = fadd double %239, %240
DOALL:     	  %242 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %119, double* %120, align 8, !tbaa !42
DOALL:     	  store double %121, double* %122, align 8, !tbaa !45
DOALL:     	  store double %127, double* %128, align 8, !tbaa !42
DOALL:     	  store double %131, double* %132, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %108, label %110, label %109, !prof !55
DOALL:     	  %119 = fadd double %112, %116
DOALL:     	  %120 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %121 = fadd double %114, %118
DOALL:     	  %122 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 1
DOALL:     	  %127 = fsub double %124, %126
DOALL:     	  %128 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %131 = fadd double %129, %130
DOALL:     	  %132 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %273, double* %274, align 8, !tbaa !42
DOALL:     	  store double %275, double* %276, align 8, !tbaa !45
DOALL:     	  store double %281, double* %282, align 8, !tbaa !42
DOALL:     	  store double %285, double* %286, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %263, label %264, label %287, !prof !58
DOALL:     	  %273 = fadd double %266, %270
DOALL:     	  %274 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %275 = fadd double %268, %272
DOALL:     	  %276 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 1
DOALL:     	  %281 = fsub double %278, %280
DOALL:     	  %282 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %285 = fadd double %283, %284
DOALL:     	  %286 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %229, double* %230, align 8, !tbaa !42
DOALL:     	  store double %231, double* %232, align 8, !tbaa !45
DOALL:     	  store double %237, double* %238, align 8, !tbaa !42
DOALL:     	  store double %241, double* %242, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %218, label %220, label %219, !prof !55
DOALL:     	  %229 = fadd double %222, %226
DOALL:     	  %230 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %231 = fadd double %224, %228
DOALL:     	  %232 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 1
DOALL:     	  %237 = fsub double %234, %236
DOALL:     	  %238 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %241 = fadd double %239, %240
DOALL:     	  %242 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %163, double* %164, align 8, !tbaa !42
DOALL:     	  store double %165, double* %166, align 8, !tbaa !45
DOALL:     	  store double %171, double* %172, align 8, !tbaa !42
DOALL:     	  store double %175, double* %176, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %153, label %154, label %177, !prof !58
DOALL:     	  %163 = fadd double %156, %160
DOALL:     	  %164 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %165 = fadd double %158, %162
DOALL:     	  %166 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 1
DOALL:     	  %171 = fsub double %168, %170
DOALL:     	  %172 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %175 = fadd double %173, %174
DOALL:     	  %176 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8
ClonableMemoryObject:   It is clonable
ClonableMemoryObject:   It requires initialization
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca double, align 8 can be cloned
MemoryCloningAnalysis:     The private copies need to be initialized with the original object.
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 24
DOALL:     	  %28 = load i64, i64* %19, align 8, !tbaa !33
DOALL:     	  %93 = load double, double* %4, align 8, !tbaa !33
DOALL:     	  %94 = fmul double %93, 0x3E80000000000000
DOALL:     	  %95 = fptosi double %94 to i32
DOALL:     	  %96 = sitofp i32 %95 to double
DOALL:     	  %97 = fmul double %96, 0x4160000000000000
DOALL:     	  %98 = fsub double %93, %97
DOALL:     	  %99 = fmul double %98, %90
DOALL:     	  %100 = fmul double %92, %96
DOALL:     	  %101 = fadd double %99, %100
DOALL:     	  %102 = fmul double %101, 0x3E80000000000000
DOALL:     	  %103 = fptosi double %102 to i32
DOALL:     	  %104 = sitofp i32 %103 to double
DOALL:     	  %105 = fmul double %104, 0x4160000000000000
DOALL:     	  %106 = fsub double %101, %105
DOALL:     	  %107 = fmul double %106, 0x4160000000000000
DOALL:     	  %108 = fmul double %92, %98
DOALL:     	  %109 = fadd double %107, %108
DOALL:     	  %110 = fmul double %109, 0x3D10000000000000
DOALL:     	  %111 = fptosi double %110 to i32
DOALL:     	  %112 = sitofp i32 %111 to double
DOALL:     	  %113 = fmul double %112, 0x42D0000000000000
DOALL:     	  %114 = fsub double %109, %113
DOALL:     	  store double %114, double* %4, align 8, !tbaa !33
DOALL:     External nodes: 6
DOALL:     	  br i1 %26, label %27, label %116, !prof !39
DOALL:     	  store i64 %28, i64* %20, align 8, !tbaa !33
DOALL:     	  br i1 %86, label %.._crit_edge_crit_edge, label %87, !prof !46
DOALL:     	  %90 = sitofp i32 %89 to double
DOALL:     	  %92 = fsub double %21, %91
DOALL:     	  %115 = fmul double %114, 0x3D10000000000000
DOALL:     Edges: 61
DOALL:     Loop-carried data dependences
DOALL:         store double %114, double* %4, align 8, !tbaa !33 --->   store double %114, double* %4, align 8, !tbaa !33 via memory
DOALL:         store double %114, double* %4, align 8, !tbaa !33 --->   %28 = load i64, i64* %19, align 8, !tbaa !33 via memory
DOALL:         store double %114, double* %4, align 8, !tbaa !33 --->   %93 = load double, double* %4, align 8, !tbaa !33 via memory
DOALL:         %28 = load i64, i64* %19, align 8, !tbaa !33 --->   store double %114, double* %4, align 8, !tbaa !33 via memory
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 3
DOALL:     	  store double %59, double* %60, align 8, !tbaa !33
DOALL:     	  %73 = load i64, i64* %72, align 8, !tbaa !33
DOALL:     	  %78 = load i64, i64* %77, align 8, !tbaa !33
DOALL:     External nodes: 8
DOALL:     	  br i1 %36, label %vranlc.exit, label %37, !prof !40
DOALL:     	  %59 = fmul double %58, 0x3D10000000000000
DOALL:     	  %60 = getelementptr inbounds double, double* %32, i64 %indvars.iv.i
DOALL:     	  br i1 %exitcond, label %81, label %69, !prof !42
DOALL:     	  %72 = bitcast double* %71 to i64*
DOALL:     	  store i64 %73, i64* %75, align 16, !tbaa !43
DOALL:     	  %77 = bitcast double* %76 to i64*
DOALL:     	  store i64 %78, i64* %80, align 8, !tbaa !45
DOALL:     Edges: 14
DOALL:     Loop-carried data dependences
DOALL:         store double %59, double* %60, align 8, !tbaa !33 --->   %78 = load i64, i64* %77, align 8, !tbaa !33 via memory
DOALL:         store double %59, double* %60, align 8, !tbaa !33 --->   store double %59, double* %60, align 8, !tbaa !33 via memory
DOALL:         store double %59, double* %60, align 8, !tbaa !33 --->   %73 = load i64, i64* %72, align 8, !tbaa !33 via memory
DOALL:         %73 = load i64, i64* %72, align 8, !tbaa !33 --->   store double %59, double* %60, align 8, !tbaa !33 via memory
DOALL:         %78 = load i64, i64* %77, align 8, !tbaa !33 --->   store double %59, double* %60, align 8, !tbaa !33 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 6
DOALL:     	  %.0 = phi i64 [ %indvars.iv4.lcssa, %81 ], [ 1, %vranlc.exit ]
DOALL:     	  %sext = shl i64 %.0, 32
DOALL:     	  %67 = ashr exact i64 %sext, 32
DOALL:     	  %indvars.iv4 = phi i64 [ %indvars.iv.next5, %69 ], [ %67, %66 ]
DOALL:     	  %indvars.iv.next5 = add nsw i64 %indvars.iv4, 2
DOALL:     	  %indvars.iv4.lcssa = phi i64 [ %indvars.iv4, %68 ]
DOALL:     External nodes: 4
DOALL:     	  br i1 %65, label %66, label %82, !prof !41
DOALL:     	  br i1 %exitcond, label %81, label %69, !prof !42
DOALL:     	  %70 = add nsw i64 %indvars.iv4, 1
DOALL:     	  %71 = getelementptr inbounds [524289 x double], [524289 x double]* @compute_initial_conditions.tmp, i64 0, i64 %indvars.iv4
DOALL:     Edges: 16
DOALL:     Loop-carried data dependences
DOALL:         %indvars.iv4.lcssa = phi i64 [ %indvars.iv4, %68 ] --->   %.0 = phi i64 [ %indvars.iv4.lcssa, %81 ], [ 1, %vranlc.exit ] via variable
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca [3 x i32], align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The next live-out variables are not reducable
DOALL:     Live-out ID = 5
DOALL:     Live-out ID = 6
DOALL:     Live-out ID = 7
Inliner:   Inlining in: main (425 instructions. The inlining will add 451 instructions),   call fastcc void @cffts1(i32 -1, i32* %288, [256 x [512 x %struct.dcomplex]]* %289, [256 x [512 x %struct.dcomplex]]* %56, [18 x %struct.dcomplex]* nonnull %46, [18 x %struct.dcomplex]* nonnull %57) #13
Inliner:   Inlined calls due to loop-carried data dependences
Inliner: Exit
Noelle:  Function "main"
Noelle:     Loop "  %exitcond8 = icmp eq i32 %.02, 7" (5.771826e-09%)
Noelle:     Loop "  %exitcond = icmp eq i32 %.1, 7" (5.771826e-09%)
Noelle:     Loop "  %.b4 = load i1, i1* @niter, align 4" (3.192474e+01%)
Noelle:     Loop "  %exitcond.i = icmp eq i64 %indvars.iv15.i, 3" (3.722397e-07%)
Noelle:     Loop "  %66 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 1" (1.194843e+01%)
Noelle:     Loop "  %73 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 0" (1.194843e+01%)
Noelle:     Loop "  %83 = icmp slt i64 %indvars.iv7.i, %81" (1.188707e+00%)
Noelle:     Loop "  %85 = icmp slt i64 %indvars.iv.i, %80" (1.166987e+00%)
Noelle:     Loop "  %109 = icmp sgt i32 %.0.i.i, %62" (9.280030e+00%)
Noelle:     Loop "  %127 = icmp slt i64 %indvars.iv16.i11.i.i, %124" (4.751862e+00%)
Noelle:     Loop "  %140 = icmp slt i64 %indvars.iv14.i13.i.i, %123" (4.716269e+00%)
Noelle:     Loop "  %147 = icmp slt i64 %indvars.iv12.i14.i.i, %122" (4.617102e+00%)
Noelle:     Loop "  %191 = icmp slt i64 %indvars.iv16.i.i.i, %188" (4.525583e+00%)
Noelle:     Loop "  %204 = icmp slt i64 %indvars.iv14.i.i.i, %187" (4.491685e+00%)
Noelle:     Loop "  %211 = icmp slt i64 %indvars.iv12.i.i.i, %186" (4.397240e+00%)
Noelle:     Loop "  %245 = icmp slt i64 %indvars.iv5.i.i, %243" (4.061055e-01%)
Noelle:     Loop "  %247 = icmp slt i64 %indvars.iv.i.i, %242" (3.974259e-01%)
Noelle:     Loop "  %267 = icmp slt i64 %indvars.iv11.i, %265" (1.073092e+00%)
Noelle:     Loop "  %269 = icmp slt i64 %indvars.iv9.i, %263" (1.051372e+00%)
Noelle:  Function "fft"
Noelle:  Function "cfftz"
Noelle:     Loop "  %12 = icmp sgt i32 %.0, %1" (2.552232e+01%)
Noelle:     Loop "  %77 = icmp slt i64 %indvars.iv16.i11, %29" (1.188061e+01%)
Noelle:     Loop "  %90 = icmp slt i64 %indvars.iv14.i13, %28" (1.179162e+01%)
Noelle:     Loop "  %97 = icmp slt i64 %indvars.iv12.i14, %27" (1.154368e+01%)
Noelle:     Loop "  %32 = icmp slt i64 %indvars.iv10.i4, %29" (1.187507e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv8.i6, %28" (1.179162e+00%)
Noelle:     Loop "  %52 = icmp slt i64 %indvars.iv.i8, %27" (1.154368e+00%)
Noelle:     Loop "  %188 = icmp slt i64 %indvars.iv16.i, %140" (1.131486e+01%)
Noelle:     Loop "  %201 = icmp slt i64 %indvars.iv14.i, %139" (1.123011e+01%)
Noelle:     Loop "  %208 = icmp slt i64 %indvars.iv12.i, %138" (1.099398e+01%)
Noelle:     Loop "  %143 = icmp slt i64 %indvars.iv10.i, %140" (1.130959e+00%)
Noelle:     Loop "  %155 = icmp slt i64 %indvars.iv8.i, %139" (1.123011e+00%)
Noelle:     Loop "  %163 = icmp slt i64 %indvars.iv.i, %138" (1.099398e+00%)
Noelle:     Loop "  %242 = icmp slt i64 %indvars.iv5, %240" (1.116880e+00%)
Noelle:     Loop "  %244 = icmp slt i64 %indvars.iv, %239" (1.093009e+00%)
Noelle:  Function "fftz2"
Noelle:     Loop "  %70 = icmp slt i64 %indvars.iv16, %22" (2.319534e+01%)
Noelle:     Loop "  %83 = icmp slt i64 %indvars.iv14, %21" (2.302161e+01%)
Noelle:     Loop "  %90 = icmp slt i64 %indvars.iv12, %20" (2.253757e+01%)
Noelle:     Loop "  %25 = icmp slt i64 %indvars.iv10, %22" (2.318349e+00%)
Noelle:     Loop "  %37 = icmp slt i64 %indvars.iv8, %21" (2.302096e+00%)
Noelle:     Loop "  %45 = icmp slt i64 %indvars.iv, %20" (2.253714e+00%)
Noelle:  Function "cffts3"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (9.553664e-08%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 1" (1.314426e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 0" (1.314425e+01%)
Noelle:     Loop "  %42 = icmp slt i64 %indvars.iv7, %40" (1.307673e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv, %39" (1.283779e+00%)
Noelle:     Loop "  %69 = icmp sgt i32 %.0.i, %21" (1.020872e+01%)
Noelle:     Loop "  %133 = icmp slt i64 %indvars.iv16.i11.i, %85" (4.752206e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv14.i13.i, %84" (4.716611e+00%)
Noelle:     Loop "  %153 = icmp slt i64 %indvars.iv12.i14.i, %83" (4.617437e+00%)
Noelle:     Loop "  %88 = icmp slt i64 %indvars.iv10.i4.i, %85" (4.749993e-01%)
Noelle:     Loop "  %100 = icmp slt i64 %indvars.iv8.i6.i, %84" (4.716611e-01%)
Noelle:     Loop "  %108 = icmp slt i64 %indvars.iv.i8.i, %83" (4.617437e-01%)
Noelle:     Loop "  %243 = icmp slt i64 %indvars.iv16.i.i, %195" (4.525911e+00%)
Noelle:     Loop "  %256 = icmp slt i64 %indvars.iv14.i.i, %194" (4.492011e+00%)
Noelle:     Loop "  %263 = icmp slt i64 %indvars.iv12.i.i, %193" (4.397559e+00%)
Noelle:     Loop "  %198 = icmp slt i64 %indvars.iv10.i.i, %195" (4.523803e-01%)
Noelle:     Loop "  %210 = icmp slt i64 %indvars.iv8.i.i, %194" (4.492011e-01%)
Noelle:     Loop "  %218 = icmp slt i64 %indvars.iv.i.i, %193" (4.397559e-01%)
Noelle:     Loop "  %297 = icmp slt i64 %indvars.iv5.i, %295" (4.467484e-01%)
Noelle:     Loop "  %299 = icmp slt i64 %indvars.iv.i, %294" (4.372002e-01%)
Noelle:     Loop "  %319 = icmp slt i64 %indvars.iv11, %317" (1.180487e+00%)
Noelle:     Loop "  %321 = icmp slt i64 %indvars.iv9, %315" (1.156593e+00%)
Noelle:  Function "cffts2"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (4.094550e-07%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 2" (1.314426e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 0" (1.314425e+01%)
Noelle:     Loop "  %42 = icmp slt i64 %indvars.iv7, %40" (1.307673e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv, %39" (1.283779e+00%)
Noelle:     Loop "  %69 = icmp sgt i32 %.0.i, %21" (1.020872e+01%)
Noelle:     Loop "  %133 = icmp slt i64 %indvars.iv16.i11.i, %85" (4.752206e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv14.i13.i, %84" (4.716611e+00%)
Noelle:     Loop "  %153 = icmp slt i64 %indvars.iv12.i14.i, %83" (4.617437e+00%)
Noelle:     Loop "  %88 = icmp slt i64 %indvars.iv10.i4.i, %85" (4.749993e-01%)
Noelle:     Loop "  %100 = icmp slt i64 %indvars.iv8.i6.i, %84" (4.716611e-01%)
Noelle:     Loop "  %108 = icmp slt i64 %indvars.iv.i8.i, %83" (4.617437e-01%)
Noelle:     Loop "  %243 = icmp slt i64 %indvars.iv16.i.i, %195" (4.525911e+00%)
Noelle:     Loop "  %256 = icmp slt i64 %indvars.iv14.i.i, %194" (4.492011e+00%)
Noelle:     Loop "  %263 = icmp slt i64 %indvars.iv12.i.i, %193" (4.397559e+00%)
Noelle:     Loop "  %198 = icmp slt i64 %indvars.iv10.i.i, %195" (4.523803e-01%)
Noelle:     Loop "  %210 = icmp slt i64 %indvars.iv8.i.i, %194" (4.492011e-01%)
Noelle:     Loop "  %218 = icmp slt i64 %indvars.iv.i.i, %193" (4.397559e-01%)
Noelle:     Loop "  %297 = icmp slt i64 %indvars.iv5.i, %295" (4.467484e-01%)
Noelle:     Loop "  %299 = icmp slt i64 %indvars.iv.i, %294" (4.372002e-01%)
Noelle:     Loop "  %319 = icmp slt i64 %indvars.iv11, %317" (1.180487e+00%)
Noelle:     Loop "  %321 = icmp slt i64 %indvars.iv9, %315" (1.156593e+00%)
Noelle:  Function "cffts1"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv14, 3" (4.094550e-07%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (7.493014e+00%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 1" (7.493009e+00%)
Noelle:     Loop "  %41 = icmp slt i64 %indvars.iv6, %39" (1.082595e+00%)
Noelle:     Loop "  %47 = icmp slt i64 %indvars.iv, %38" (1.081454e+00%)
Noelle:     Loop "  %69 = icmp sgt i32 %.0.i, %21" (5.104381e+00%)
Noelle:     Loop "  %133 = icmp slt i64 %indvars.iv16.i11.i, %85" (2.376112e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv14.i13.i, %84" (2.358315e+00%)
Noelle:     Loop "  %153 = icmp slt i64 %indvars.iv12.i14.i, %83" (2.308727e+00%)
Noelle:     Loop "  %88 = icmp slt i64 %indvars.iv10.i4.i, %85" (2.375005e-01%)
Noelle:     Loop "  %100 = icmp slt i64 %indvars.iv8.i6.i, %84" (2.358315e-01%)
Noelle:     Loop "  %108 = icmp slt i64 %indvars.iv.i8.i, %83" (2.308727e-01%)
Noelle:     Loop "  %243 = icmp slt i64 %indvars.iv16.i.i, %195" (2.262964e+00%)
Noelle:     Loop "  %256 = icmp slt i64 %indvars.iv14.i.i, %194" (2.246014e+00%)
Noelle:     Loop "  %263 = icmp slt i64 %indvars.iv12.i.i, %193" (2.198788e+00%)
Noelle:     Loop "  %198 = icmp slt i64 %indvars.iv10.i.i, %195" (2.261910e-01%)
Noelle:     Loop "  %210 = icmp slt i64 %indvars.iv8.i.i, %194" (2.246014e-01%)
Noelle:     Loop "  %218 = icmp slt i64 %indvars.iv.i.i, %193" (2.198788e-01%)
Noelle:     Loop "  %297 = icmp slt i64 %indvars.iv5.i, %295" (2.233751e-01%)
Noelle:     Loop "  %299 = icmp slt i64 %indvars.iv.i, %294" (2.186009e-01%)
Noelle:     Loop "  %319 = icmp slt i64 %indvars.iv10, %313" (1.082346e+00%)
Noelle:     Loop "  %323 = icmp slt i64 %indvars.iv8, %317" (1.081454e+00%)
Noelle:  Function "evolve"
Noelle:     Loop "  %16 = icmp slt i64 %indvars.iv5, %8" (1.215073e+00%)
Noelle:     Loop "  %18 = icmp slt i64 %indvars.iv3, %11" (1.215070e+00%)
Noelle:     Loop "  %20 = icmp slt i64 %indvars.iv, %14" (1.214391e+00%)
Noelle:  Function "compute_initial_conditions"
Noelle:     Loop "  %23 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (4.626560e-01%)
Noelle:     Loop "  %36 = icmp sgt i64 %indvars.iv.i, %34" (3.468711e-01%)
Noelle:     Loop "  %65 = icmp slt i64 %indvars.iv6, %63" (1.157823e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 512" (1.156692e-01%)
Noelle:  Function "vranlc"
Noelle:     Loop "  %13 = icmp sgt i64 %indvars.iv, %11" (3.468709e-01%)
Noelle:  Function "compute_indexmap"
Noelle:     Loop "  %15 = icmp slt i64 %indvars.iv10, %4" (8.129949e-02%)
Noelle:     Loop "  %23 = icmp slt i64 %indvars.iv8, %8" (8.129844e-02%)
Noelle:     Loop "  %33 = icmp slt i64 %indvars.iv6, %12" (8.100459e-02%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 1966081" (3.727075e-03%)
Noelle:  Function "checksum"
Noelle:     Loop "  %exitcond = icmp eq i32 %.0, 1025" (7.410852e-05%)
Noelle:  Function "randlc"
Noelle:  Function "fft_init"
Noelle:     Loop "  %7 = icmp sgt i32 %.01, %2" (1.347851e-06%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count" (1.325280e-06%)
Noelle:  Function "ilog2"
Noelle:     Loop "  %3 = icmp slt i32 %.01, %0" (9.541603e-07%)
Noelle:  Function "ipow46"
Noelle:     Loop "  %11 = icmp sgt i32 %.01, 1" (1.277555e-07%)
Noelle:  Function "verify"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 21" (3.988590e-08%)
Noelle:  Function "setup"
Noelle:     Loop "  %exitcond3 = icmp eq i64 %indvars.iv1, 3" (3.101280e-09%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 3" (4.651919e-09%)
Noelle:  Function "elapsed_time"
Noelle:  Function "timer_clear"
Noelle:  Function "c_print_results"
Noelle:  Function "wtime_"
Noelle:  Function "timer_stop"
Noelle:  Function "timer_start"
Noelle:  Function "timer_read"
Noelle:  Function "main"
Noelle:     Loop "  %exitcond8 = icmp eq i32 %.02, 7" (5.403796e-09%)
Noelle:     Loop "  %exitcond = icmp eq i32 %.1, 7" (5.403796e-09%)
Noelle:     Loop "  %.b4 = load i1, i1* @niter, align 4" (2.988794e+01%)
Noelle:     Loop "  %exitcond.i = icmp eq i64 %indvars.iv15.i, 3" (3.485045e-07%)
Noelle:     Loop "  %69 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 1" (1.118614e+01%)
Noelle:     Loop "  %76 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 0" (1.118613e+01%)
Noelle:     Loop "  %86 = icmp slt i64 %indvars.iv7.i, %84" (1.112869e+00%)
Noelle:     Loop "  %88 = icmp slt i64 %indvars.iv.i, %83" (1.092535e+00%)
Noelle:     Loop "  %112 = icmp sgt i32 %.0.i.i, %65" (8.687976e+00%)
Noelle:     Loop "  %130 = icmp slt i64 %indvars.iv16.i11.i.i, %127" (4.448699e+00%)
Noelle:     Loop "  %143 = icmp slt i64 %indvars.iv14.i13.i.i, %126" (4.415377e+00%)
Noelle:     Loop "  %150 = icmp slt i64 %indvars.iv12.i14.i.i, %125" (4.322537e+00%)
Noelle:     Loop "  %194 = icmp slt i64 %indvars.iv16.i.i.i, %191" (4.236856e+00%)
Noelle:     Loop "  %207 = icmp slt i64 %indvars.iv14.i.i.i, %190" (4.205121e+00%)
Noelle:     Loop "  %214 = icmp slt i64 %indvars.iv12.i.i.i, %189" (4.116701e+00%)
Noelle:     Loop "  %248 = icmp slt i64 %indvars.iv5.i.i, %246" (3.801964e-01%)
Noelle:     Loop "  %250 = icmp slt i64 %indvars.iv.i.i, %245" (3.720706e-01%)
Noelle:     Loop "  %270 = icmp slt i64 %indvars.iv11.i, %268" (1.004630e+00%)
Noelle:     Loop "  %272 = icmp slt i64 %indvars.iv9.i, %266" (9.842958e-01%)
Noelle:     Loop "  %exitcond.i1 = icmp eq i64 %indvars.iv14.i, 3" (3.485045e-07%)
Noelle:     Loop "  %308 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (6.376734e+00%)
Noelle:     Loop "  %315 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 1" (6.376730e+00%)
Noelle:     Loop "  %324 = icmp slt i64 %indvars.iv6.i, %322" (9.213156e-01%)
Noelle:     Loop "  %330 = icmp slt i64 %indvars.iv.i5, %321" (9.203445e-01%)
Noelle:     Loop "  %351 = icmp sgt i32 %.0.i.i10, %304" (4.343980e+00%)
Noelle:     Loop "  %369 = icmp slt i64 %indvars.iv16.i11.i.i15, %366" (2.224345e+00%)
Noelle:     Loop "  %382 = icmp slt i64 %indvars.iv14.i13.i.i17, %365" (2.207684e+00%)
Noelle:     Loop "  %389 = icmp slt i64 %indvars.iv12.i14.i.i18, %364" (2.161264e+00%)
Noelle:     Loop "  %433 = icmp slt i64 %indvars.iv16.i.i.i25, %430" (2.118424e+00%)
Noelle:     Loop "  %446 = icmp slt i64 %indvars.iv14.i.i.i27, %429" (2.102557e+00%)
Noelle:     Loop "  %453 = icmp slt i64 %indvars.iv12.i.i.i28, %428" (2.058347e+00%)
Noelle:     Loop "  %487 = icmp slt i64 %indvars.iv5.i.i35, %485" (1.900979e-01%)
Noelle:     Loop "  %489 = icmp slt i64 %indvars.iv.i.i37, %484" (1.860350e-01%)
Noelle:     Loop "  %509 = icmp slt i64 %indvars.iv10.i, %503" (9.211042e-01%)
Noelle:     Loop "  %513 = icmp slt i64 %indvars.iv8.i, %507" (9.203445e-01%)
Noelle:  Function "fft"
Noelle:  Function "cfftz"
Noelle:     Loop "  %12 = icmp sgt i32 %.0, %1" (2.389494e+01%)
Noelle:     Loop "  %77 = icmp slt i64 %indvars.iv16.i11, %29" (1.112306e+01%)
Noelle:     Loop "  %90 = icmp slt i64 %indvars.iv14.i13, %28" (1.103975e+01%)
Noelle:     Loop "  %97 = icmp slt i64 %indvars.iv12.i14, %27" (1.080762e+01%)
Noelle:     Loop "  %32 = icmp slt i64 %indvars.iv10.i4, %29" (1.111788e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv8.i6, %28" (1.103975e+00%)
Noelle:     Loop "  %52 = icmp slt i64 %indvars.iv.i8, %27" (1.080762e+00%)
Noelle:     Loop "  %188 = icmp slt i64 %indvars.iv16.i, %140" (1.059339e+01%)
Noelle:     Loop "  %201 = icmp slt i64 %indvars.iv14.i, %139" (1.051405e+01%)
Noelle:     Loop "  %208 = icmp slt i64 %indvars.iv12.i, %138" (1.029297e+01%)
Noelle:     Loop "  %143 = icmp slt i64 %indvars.iv10.i, %140" (1.058846e+00%)
Noelle:     Loop "  %155 = icmp slt i64 %indvars.iv8.i, %139" (1.051405e+00%)
Noelle:     Loop "  %163 = icmp slt i64 %indvars.iv.i, %138" (1.029297e+00%)
Noelle:     Loop "  %242 = icmp slt i64 %indvars.iv5, %240" (1.045664e+00%)
Noelle:     Loop "  %244 = icmp slt i64 %indvars.iv, %239" (1.023315e+00%)
Noelle:  Function "fftz2"
Noelle:     Loop "  %70 = icmp slt i64 %indvars.iv16, %22" (2.171633e+01%)
Noelle:     Loop "  %83 = icmp slt i64 %indvars.iv14, %21" (2.155369e+01%)
Noelle:     Loop "  %90 = icmp slt i64 %indvars.iv12, %20" (2.110050e+01%)
Noelle:     Loop "  %25 = icmp slt i64 %indvars.iv10, %22" (2.170524e+00%)
Noelle:     Loop "  %37 = icmp slt i64 %indvars.iv8, %21" (2.155307e+00%)
Noelle:     Loop "  %45 = icmp slt i64 %indvars.iv, %20" (2.110010e+00%)
Noelle:  Function "cffts3"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (1.487798e+09%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 1" (1.230614e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 0" (1.230613e+01%)
Noelle:     Loop "  %42 = icmp slt i64 %indvars.iv7, %40" (1.224291e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv, %39" (1.201921e+00%)
Noelle:     Loop "  %69 = icmp sgt i32 %.0.i, %21" (9.557783e+00%)
Noelle:     Loop "  %133 = icmp slt i64 %indvars.iv16.i11.i, %85" (4.449191e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv14.i13.i, %84" (4.415866e+00%)
Noelle:     Loop "  %153 = icmp slt i64 %indvars.iv12.i14.i, %83" (4.323015e+00%)
Noelle:     Loop "  %88 = icmp slt i64 %indvars.iv10.i4.i, %85" (4.447119e-01%)
Noelle:     Loop "  %100 = icmp slt i64 %indvars.iv8.i6.i, %84" (4.415866e-01%)
Noelle:     Loop "  %108 = icmp slt i64 %indvars.iv.i8.i, %83" (4.323015e-01%)
Noelle:     Loop "  %243 = icmp slt i64 %indvars.iv16.i.i, %195" (4.237325e+00%)
Noelle:     Loop "  %256 = icmp slt i64 %indvars.iv14.i.i, %194" (4.205586e+00%)
Noelle:     Loop "  %263 = icmp slt i64 %indvars.iv12.i.i, %193" (4.117157e+00%)
Noelle:     Loop "  %198 = icmp slt i64 %indvars.iv10.i.i, %195" (4.235351e-01%)
Noelle:     Loop "  %210 = icmp slt i64 %indvars.iv8.i.i, %194" (4.205586e-01%)
Noelle:     Loop "  %218 = icmp slt i64 %indvars.iv.i.i, %193" (4.117157e-01%)
Noelle:     Loop "  %297 = icmp slt i64 %indvars.iv5.i, %295" (4.182624e-01%)
Noelle:     Loop "  %299 = icmp slt i64 %indvars.iv.i, %294" (4.093230e-01%)
Noelle:     Loop "  %319 = icmp slt i64 %indvars.iv11, %317" (1.105216e+00%)
Noelle:     Loop "  %321 = icmp slt i64 %indvars.iv9, %315" (1.082845e+00%)
Noelle:  Function "cffts2"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (3.833469e-07%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 2" (1.230614e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 0" (1.230613e+01%)
Noelle:     Loop "  %42 = icmp slt i64 %indvars.iv7, %40" (1.224291e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv, %39" (1.201921e+00%)
Noelle:     Loop "  %69 = icmp sgt i32 %.0.i, %21" (9.557783e+00%)
Noelle:     Loop "  %133 = icmp slt i64 %indvars.iv16.i11.i, %85" (4.449191e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv14.i13.i, %84" (4.415866e+00%)
Noelle:     Loop "  %153 = icmp slt i64 %indvars.iv12.i14.i, %83" (4.323015e+00%)
Noelle:     Loop "  %88 = icmp slt i64 %indvars.iv10.i4.i, %85" (4.447119e-01%)
Noelle:     Loop "  %100 = icmp slt i64 %indvars.iv8.i6.i, %84" (4.415866e-01%)
Noelle:     Loop "  %108 = icmp slt i64 %indvars.iv.i8.i, %83" (4.323015e-01%)
Noelle:     Loop "  %243 = icmp slt i64 %indvars.iv16.i.i, %195" (4.237325e+00%)
Noelle:     Loop "  %256 = icmp slt i64 %indvars.iv14.i.i, %194" (4.205586e+00%)
Noelle:     Loop "  %263 = icmp slt i64 %indvars.iv12.i.i, %193" (4.117157e+00%)
Noelle:     Loop "  %198 = icmp slt i64 %indvars.iv10.i.i, %195" (4.235351e-01%)
Noelle:     Loop "  %210 = icmp slt i64 %indvars.iv8.i.i, %194" (4.205586e-01%)
Noelle:     Loop "  %218 = icmp slt i64 %indvars.iv.i.i, %193" (4.117157e-01%)
Noelle:     Loop "  %297 = icmp slt i64 %indvars.iv5.i, %295" (4.182624e-01%)
Noelle:     Loop "  %299 = icmp slt i64 %indvars.iv.i, %294" (4.093230e-01%)
Noelle:     Loop "  %319 = icmp slt i64 %indvars.iv11, %317" (1.105216e+00%)
Noelle:     Loop "  %321 = icmp slt i64 %indvars.iv9, %315" (1.082845e+00%)
Noelle:  Function "cffts1"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv14, 3" (3.833469e-07%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (7.015237e+00%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 1" (7.015232e+00%)
Noelle:     Loop "  %41 = icmp slt i64 %indvars.iv6, %39" (1.013565e+00%)
Noelle:     Loop "  %47 = icmp slt i64 %indvars.iv, %38" (1.012497e+00%)
Noelle:     Loop "  %69 = icmp sgt i32 %.0.i, %21" (4.778910e+00%)
Noelle:     Loop "  %133 = icmp slt i64 %indvars.iv16.i11.i, %85" (2.224604e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv14.i13.i, %84" (2.207941e+00%)
Noelle:     Loop "  %153 = icmp slt i64 %indvars.iv12.i14.i, %83" (2.161516e+00%)
Noelle:     Loop "  %88 = icmp slt i64 %indvars.iv10.i4.i, %85" (2.223568e-01%)
Noelle:     Loop "  %100 = icmp slt i64 %indvars.iv8.i6.i, %84" (2.207941e-01%)
Noelle:     Loop "  %108 = icmp slt i64 %indvars.iv.i8.i, %83" (2.161516e-01%)
Noelle:     Loop "  %243 = icmp slt i64 %indvars.iv16.i.i, %195" (2.118671e+00%)
Noelle:     Loop "  %256 = icmp slt i64 %indvars.iv14.i.i, %194" (2.102801e+00%)
Noelle:     Loop "  %263 = icmp slt i64 %indvars.iv12.i.i, %193" (2.058586e+00%)
Noelle:     Loop "  %198 = icmp slt i64 %indvars.iv10.i.i, %195" (2.117684e-01%)
Noelle:     Loop "  %210 = icmp slt i64 %indvars.iv8.i.i, %194" (2.102801e-01%)
Noelle:     Loop "  %218 = icmp slt i64 %indvars.iv.i.i, %193" (2.058586e-01%)
Noelle:     Loop "  %297 = icmp slt i64 %indvars.iv5.i, %295" (2.091320e-01%)
Noelle:     Loop "  %299 = icmp slt i64 %indvars.iv.i, %294" (2.046623e-01%)
Noelle:     Loop "  %319 = icmp slt i64 %indvars.iv10, %313" (1.013333e+00%)
Noelle:     Loop "  %323 = icmp slt i64 %indvars.iv8, %317" (1.012497e+00%)
Noelle:  Function "evolve"
Noelle:     Loop "  %16 = icmp slt i64 %indvars.iv5, %8" (1.137596e+00%)
Noelle:     Loop "  %18 = icmp slt i64 %indvars.iv3, %11" (1.137594e+00%)
Noelle:     Loop "  %20 = icmp slt i64 %indvars.iv, %14" (1.136958e+00%)
Noelle:  Function "compute_initial_conditions"
Noelle:     Loop "  %23 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (4.331556e-01%)
Noelle:     Loop "  %36 = icmp sgt i64 %indvars.iv.i, %34" (3.247535e-01%)
Noelle:     Loop "  %65 = icmp slt i64 %indvars.iv6, %63" (1.083997e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 512" (1.082938e-01%)
Noelle:  Function "vranlc"
Noelle:     Loop "  %13 = icmp sgt i64 %indvars.iv, %11" (3.247534e-01%)
Noelle:  Function "compute_indexmap"
Noelle:     Loop "  %15 = icmp slt i64 %indvars.iv10, %4" (7.611559e-02%)
Noelle:     Loop "  %23 = icmp slt i64 %indvars.iv8, %8" (7.611460e-02%)
Noelle:     Loop "  %33 = icmp slt i64 %indvars.iv6, %12" (7.583949e-02%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 1966081" (3.489425e-03%)
Noelle:  Function "checksum"
Noelle:     Loop "  %exitcond = icmp eq i32 %.0, 1025" (6.938313e-05%)
Noelle:  Function "randlc"
Noelle:  Function "fft_init"
Noelle:     Loop "  %7 = icmp sgt i32 %.01, %2" (1.261907e-06%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count" (1.240776e-06%)
Noelle:  Function "ilog2"
Noelle:     Loop "  %3 = icmp slt i32 %.01, %0" (8.933201e-07%)
Noelle:  Function "ipow46"
Noelle:     Loop "  %11 = icmp sgt i32 %.01, 1" (1.196094e-07%)
Noelle:  Function "verify"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 21" (3.734265e-08%)
Noelle:  Function "setup"
Noelle:     Loop "  %exitcond3 = icmp eq i64 %indvars.iv1, 3" (2.903532e-09%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 3" (4.355299e-09%)
Noelle:  Function "elapsed_time"
Noelle:  Function "timer_clear"
Noelle:  Function "c_print_results"
Noelle:  Function "wtime_"
Noelle:  Function "timer_stop"
Noelle:  Function "timer_start"
Noelle:  Function "timer_read"
NOELLE: FixedPoint:       There are 258 different instructions and 1186 different loop instructions
NOELLE: FixedPoint:       Normalize the code
noelle-norm /tmp/tmp.mEnWC8flov -o /tmp/tmp.mEnWC8flov
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.mEnWC8flov -o /tmp/tmp.mEnWC8flov
NOELLE: FixedPoint:     Invocation 5
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.1zCLAhAajz -o /tmp/tmp.mEnWC8flov
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.1zCLAhAajz -o /tmp/tmp.mEnWC8flov
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.1zCLAhAajz -o /tmp/tmp.mEnWC8flov
Inliner: Start
Inliner:   Number of program instructions = 3301
Inliner:   Profiles are available and will be used
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %273, double* %274, align 8, !tbaa !42
DOALL:     	  store double %275, double* %276, align 8, !tbaa !45
DOALL:     	  store double %281, double* %282, align 8, !tbaa !42
DOALL:     	  store double %285, double* %286, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %263, label %264, label %287, !prof !58
DOALL:     	  %273 = fadd double %266, %270
DOALL:     	  %274 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %275 = fadd double %268, %272
DOALL:     	  %276 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 1
DOALL:     	  %281 = fsub double %278, %280
DOALL:     	  %282 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %285 = fadd double %283, %284
DOALL:     	  %286 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %163, double* %164, align 8, !tbaa !42
DOALL:     	  store double %165, double* %166, align 8, !tbaa !45
DOALL:     	  store double %171, double* %172, align 8, !tbaa !42
DOALL:     	  store double %175, double* %176, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %153, label %154, label %177, !prof !58
DOALL:     	  %163 = fadd double %156, %160
DOALL:     	  %164 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %165 = fadd double %158, %162
DOALL:     	  %166 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 1
DOALL:     	  %171 = fsub double %168, %170
DOALL:     	  %172 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %175 = fadd double %173, %174
DOALL:     	  %176 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %119, double* %120, align 8, !tbaa !42
DOALL:     	  store double %121, double* %122, align 8, !tbaa !45
DOALL:     	  store double %127, double* %128, align 8, !tbaa !42
DOALL:     	  store double %131, double* %132, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %108, label %110, label %109, !prof !55
DOALL:     	  %119 = fadd double %112, %116
DOALL:     	  %120 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %121 = fadd double %114, %118
DOALL:     	  %122 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 1
DOALL:     	  %127 = fsub double %124, %126
DOALL:     	  %128 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %131 = fadd double %129, %130
DOALL:     	  %132 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %229, double* %230, align 8, !tbaa !42
DOALL:     	  store double %231, double* %232, align 8, !tbaa !45
DOALL:     	  store double %237, double* %238, align 8, !tbaa !42
DOALL:     	  store double %241, double* %242, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %218, label %220, label %219, !prof !55
DOALL:     	  %229 = fadd double %222, %226
DOALL:     	  %230 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %231 = fadd double %224, %228
DOALL:     	  %232 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 1
DOALL:     	  %237 = fsub double %234, %236
DOALL:     	  %238 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %241 = fadd double %239, %240
DOALL:     	  %242 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %119, double* %120, align 8, !tbaa !42
DOALL:     	  store double %121, double* %122, align 8, !tbaa !45
DOALL:     	  store double %127, double* %128, align 8, !tbaa !42
DOALL:     	  store double %131, double* %132, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %108, label %110, label %109, !prof !55
DOALL:     	  %119 = fadd double %112, %116
DOALL:     	  %120 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %121 = fadd double %114, %118
DOALL:     	  %122 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 1
DOALL:     	  %127 = fsub double %124, %126
DOALL:     	  %128 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %131 = fadd double %129, %130
DOALL:     	  %132 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %273, double* %274, align 8, !tbaa !42
DOALL:     	  store double %275, double* %276, align 8, !tbaa !45
DOALL:     	  store double %281, double* %282, align 8, !tbaa !42
DOALL:     	  store double %285, double* %286, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %263, label %264, label %287, !prof !58
DOALL:     	  %273 = fadd double %266, %270
DOALL:     	  %274 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %275 = fadd double %268, %272
DOALL:     	  %276 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 1
DOALL:     	  %281 = fsub double %278, %280
DOALL:     	  %282 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %285 = fadd double %283, %284
DOALL:     	  %286 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %229, double* %230, align 8, !tbaa !42
DOALL:     	  store double %231, double* %232, align 8, !tbaa !45
DOALL:     	  store double %237, double* %238, align 8, !tbaa !42
DOALL:     	  store double %241, double* %242, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %218, label %220, label %219, !prof !55
DOALL:     	  %229 = fadd double %222, %226
DOALL:     	  %230 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %231 = fadd double %224, %228
DOALL:     	  %232 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 1
DOALL:     	  %237 = fsub double %234, %236
DOALL:     	  %238 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %241 = fadd double %239, %240
DOALL:     	  %242 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %163, double* %164, align 8, !tbaa !42
DOALL:     	  store double %165, double* %166, align 8, !tbaa !45
DOALL:     	  store double %171, double* %172, align 8, !tbaa !42
DOALL:     	  store double %175, double* %176, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %153, label %154, label %177, !prof !58
DOALL:     	  %163 = fadd double %156, %160
DOALL:     	  %164 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %165 = fadd double %158, %162
DOALL:     	  %166 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 1
DOALL:     	  %171 = fsub double %168, %170
DOALL:     	  %172 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %175 = fadd double %173, %174
DOALL:     	  %176 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %273, double* %274, align 8, !tbaa !42
DOALL:     	  store double %275, double* %276, align 8, !tbaa !45
DOALL:     	  store double %281, double* %282, align 8, !tbaa !42
DOALL:     	  store double %285, double* %286, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %263, label %264, label %287, !prof !58
DOALL:     	  %273 = fadd double %266, %270
DOALL:     	  %274 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %275 = fadd double %268, %272
DOALL:     	  %276 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 1
DOALL:     	  %281 = fsub double %278, %280
DOALL:     	  %282 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %285 = fadd double %283, %284
DOALL:     	  %286 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %163, double* %164, align 8, !tbaa !42
DOALL:     	  store double %165, double* %166, align 8, !tbaa !45
DOALL:     	  store double %171, double* %172, align 8, !tbaa !42
DOALL:     	  store double %175, double* %176, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %153, label %154, label %177, !prof !58
DOALL:     	  %163 = fadd double %156, %160
DOALL:     	  %164 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %165 = fadd double %158, %162
DOALL:     	  %166 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 1
DOALL:     	  %171 = fsub double %168, %170
DOALL:     	  %172 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %175 = fadd double %173, %174
DOALL:     	  %176 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %229, double* %230, align 8, !tbaa !42
DOALL:     	  store double %231, double* %232, align 8, !tbaa !45
DOALL:     	  store double %237, double* %238, align 8, !tbaa !42
DOALL:     	  store double %241, double* %242, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %218, label %220, label %219, !prof !55
DOALL:     	  %229 = fadd double %222, %226
DOALL:     	  %230 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %231 = fadd double %224, %228
DOALL:     	  %232 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 1
DOALL:     	  %237 = fsub double %234, %236
DOALL:     	  %238 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %241 = fadd double %239, %240
DOALL:     	  %242 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %119, double* %120, align 8, !tbaa !42
DOALL:     	  store double %121, double* %122, align 8, !tbaa !45
DOALL:     	  store double %127, double* %128, align 8, !tbaa !42
DOALL:     	  store double %131, double* %132, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %108, label %110, label %109, !prof !55
DOALL:     	  %119 = fadd double %112, %116
DOALL:     	  %120 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %121 = fadd double %114, %118
DOALL:     	  %122 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 1
DOALL:     	  %127 = fsub double %124, %126
DOALL:     	  %128 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %131 = fadd double %129, %130
DOALL:     	  %132 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %163, double* %164, align 8, !tbaa !42
DOALL:     	  store double %165, double* %166, align 8, !tbaa !45
DOALL:     	  store double %171, double* %172, align 8, !tbaa !42
DOALL:     	  store double %175, double* %176, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %153, label %154, label %177, !prof !58
DOALL:     	  %163 = fadd double %156, %160
DOALL:     	  %164 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %165 = fadd double %158, %162
DOALL:     	  %166 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 1
DOALL:     	  %171 = fsub double %168, %170
DOALL:     	  %172 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %175 = fadd double %173, %174
DOALL:     	  %176 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %229, double* %230, align 8, !tbaa !42
DOALL:     	  store double %231, double* %232, align 8, !tbaa !45
DOALL:     	  store double %237, double* %238, align 8, !tbaa !42
DOALL:     	  store double %241, double* %242, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %218, label %220, label %219, !prof !55
DOALL:     	  %229 = fadd double %222, %226
DOALL:     	  %230 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %231 = fadd double %224, %228
DOALL:     	  %232 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 1
DOALL:     	  %237 = fsub double %234, %236
DOALL:     	  %238 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %241 = fadd double %239, %240
DOALL:     	  %242 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %273, double* %274, align 8, !tbaa !42
DOALL:     	  store double %275, double* %276, align 8, !tbaa !45
DOALL:     	  store double %281, double* %282, align 8, !tbaa !42
DOALL:     	  store double %285, double* %286, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %263, label %264, label %287, !prof !58
DOALL:     	  %273 = fadd double %266, %270
DOALL:     	  %274 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %275 = fadd double %268, %272
DOALL:     	  %276 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 1
DOALL:     	  %281 = fsub double %278, %280
DOALL:     	  %282 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %285 = fadd double %283, %284
DOALL:     	  %286 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %119, double* %120, align 8, !tbaa !42
DOALL:     	  store double %121, double* %122, align 8, !tbaa !45
DOALL:     	  store double %127, double* %128, align 8, !tbaa !42
DOALL:     	  store double %131, double* %132, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %108, label %110, label %109, !prof !55
DOALL:     	  %119 = fadd double %112, %116
DOALL:     	  %120 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %121 = fadd double %114, %118
DOALL:     	  %122 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 1
DOALL:     	  %127 = fsub double %124, %126
DOALL:     	  %128 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %131 = fadd double %129, %130
DOALL:     	  %132 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %163, double* %164, align 8, !tbaa !42
DOALL:     	  store double %165, double* %166, align 8, !tbaa !45
DOALL:     	  store double %171, double* %172, align 8, !tbaa !42
DOALL:     	  store double %175, double* %176, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %153, label %154, label %177, !prof !58
DOALL:     	  %163 = fadd double %156, %160
DOALL:     	  %164 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %165 = fadd double %158, %162
DOALL:     	  %166 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 1
DOALL:     	  %171 = fsub double %168, %170
DOALL:     	  %172 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %175 = fadd double %173, %174
DOALL:     	  %176 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %273, double* %274, align 8, !tbaa !42
DOALL:     	  store double %275, double* %276, align 8, !tbaa !45
DOALL:     	  store double %281, double* %282, align 8, !tbaa !42
DOALL:     	  store double %285, double* %286, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %263, label %264, label %287, !prof !58
DOALL:     	  %273 = fadd double %266, %270
DOALL:     	  %274 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %275 = fadd double %268, %272
DOALL:     	  %276 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 1
DOALL:     	  %281 = fsub double %278, %280
DOALL:     	  %282 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %285 = fadd double %283, %284
DOALL:     	  %286 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %229, double* %230, align 8, !tbaa !42
DOALL:     	  store double %231, double* %232, align 8, !tbaa !45
DOALL:     	  store double %237, double* %238, align 8, !tbaa !42
DOALL:     	  store double %241, double* %242, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %218, label %220, label %219, !prof !55
DOALL:     	  %229 = fadd double %222, %226
DOALL:     	  %230 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %231 = fadd double %224, %228
DOALL:     	  %232 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 1
DOALL:     	  %237 = fsub double %234, %236
DOALL:     	  %238 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %241 = fadd double %239, %240
DOALL:     	  %242 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %119, double* %120, align 8, !tbaa !42
DOALL:     	  store double %121, double* %122, align 8, !tbaa !45
DOALL:     	  store double %127, double* %128, align 8, !tbaa !42
DOALL:     	  store double %131, double* %132, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %108, label %110, label %109, !prof !55
DOALL:     	  %119 = fadd double %112, %116
DOALL:     	  %120 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %121 = fadd double %114, %118
DOALL:     	  %122 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 1
DOALL:     	  %127 = fsub double %124, %126
DOALL:     	  %128 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %131 = fadd double %129, %130
DOALL:     	  %132 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %163, double* %164, align 8, !tbaa !42
DOALL:     	  store double %165, double* %166, align 8, !tbaa !45
DOALL:     	  store double %171, double* %172, align 8, !tbaa !42
DOALL:     	  store double %175, double* %176, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %153, label %154, label %177, !prof !58
DOALL:     	  %163 = fadd double %156, %160
DOALL:     	  %164 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %165 = fadd double %158, %162
DOALL:     	  %166 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 1
DOALL:     	  %171 = fsub double %168, %170
DOALL:     	  %172 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %175 = fadd double %173, %174
DOALL:     	  %176 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %229, double* %230, align 8, !tbaa !42
DOALL:     	  store double %231, double* %232, align 8, !tbaa !45
DOALL:     	  store double %237, double* %238, align 8, !tbaa !42
DOALL:     	  store double %241, double* %242, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %218, label %220, label %219, !prof !55
DOALL:     	  %229 = fadd double %222, %226
DOALL:     	  %230 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %231 = fadd double %224, %228
DOALL:     	  %232 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 1
DOALL:     	  %237 = fsub double %234, %236
DOALL:     	  %238 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %241 = fadd double %239, %240
DOALL:     	  %242 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %119, double* %120, align 8, !tbaa !42
DOALL:     	  store double %121, double* %122, align 8, !tbaa !45
DOALL:     	  store double %127, double* %128, align 8, !tbaa !42
DOALL:     	  store double %131, double* %132, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %108, label %110, label %109, !prof !55
DOALL:     	  %119 = fadd double %112, %116
DOALL:     	  %120 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %121 = fadd double %114, %118
DOALL:     	  %122 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 1
DOALL:     	  %127 = fsub double %124, %126
DOALL:     	  %128 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %131 = fadd double %129, %130
DOALL:     	  %132 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %273, double* %274, align 8, !tbaa !42
DOALL:     	  store double %275, double* %276, align 8, !tbaa !45
DOALL:     	  store double %281, double* %282, align 8, !tbaa !42
DOALL:     	  store double %285, double* %286, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %263, label %264, label %287, !prof !58
DOALL:     	  %273 = fadd double %266, %270
DOALL:     	  %274 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %275 = fadd double %268, %272
DOALL:     	  %276 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 1
DOALL:     	  %281 = fsub double %278, %280
DOALL:     	  %282 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %285 = fadd double %283, %284
DOALL:     	  %286 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8
ClonableMemoryObject:   It is clonable
ClonableMemoryObject:   It requires initialization
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca double, align 8 can be cloned
MemoryCloningAnalysis:     The private copies need to be initialized with the original object.
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 3
DOALL:     	  store double %59, double* %60, align 8, !tbaa !33
DOALL:     	  %73 = load i64, i64* %72, align 8, !tbaa !33
DOALL:     	  %78 = load i64, i64* %77, align 8, !tbaa !33
DOALL:     External nodes: 8
DOALL:     	  br i1 %36, label %vranlc.exit, label %37, !prof !40
DOALL:     	  %59 = fmul double %58, 0x3D10000000000000
DOALL:     	  %60 = getelementptr inbounds double, double* %32, i64 %indvars.iv.i
DOALL:     	  br i1 %exitcond, label %81, label %69, !prof !42
DOALL:     	  %72 = bitcast double* %71 to i64*
DOALL:     	  store i64 %73, i64* %75, align 16, !tbaa !43
DOALL:     	  %77 = bitcast double* %76 to i64*
DOALL:     	  store i64 %78, i64* %80, align 8, !tbaa !45
DOALL:     Edges: 14
DOALL:     Loop-carried data dependences
DOALL:         %78 = load i64, i64* %77, align 8, !tbaa !33 --->   store double %59, double* %60, align 8, !tbaa !33 via memory
DOALL:         store double %59, double* %60, align 8, !tbaa !33 --->   %78 = load i64, i64* %77, align 8, !tbaa !33 via memory
DOALL:         store double %59, double* %60, align 8, !tbaa !33 --->   store double %59, double* %60, align 8, !tbaa !33 via memory
DOALL:         store double %59, double* %60, align 8, !tbaa !33 --->   %73 = load i64, i64* %72, align 8, !tbaa !33 via memory
DOALL:         %73 = load i64, i64* %72, align 8, !tbaa !33 --->   store double %59, double* %60, align 8, !tbaa !33 via memory
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 24
DOALL:     	  %28 = load i64, i64* %19, align 8, !tbaa !33
DOALL:     	  %93 = load double, double* %4, align 8, !tbaa !33
DOALL:     	  %94 = fmul double %93, 0x3E80000000000000
DOALL:     	  %95 = fptosi double %94 to i32
DOALL:     	  %96 = sitofp i32 %95 to double
DOALL:     	  %97 = fmul double %96, 0x4160000000000000
DOALL:     	  %98 = fsub double %93, %97
DOALL:     	  %99 = fmul double %98, %90
DOALL:     	  %100 = fmul double %92, %96
DOALL:     	  %101 = fadd double %99, %100
DOALL:     	  %102 = fmul double %101, 0x3E80000000000000
DOALL:     	  %103 = fptosi double %102 to i32
DOALL:     	  %104 = sitofp i32 %103 to double
DOALL:     	  %105 = fmul double %104, 0x4160000000000000
DOALL:     	  %106 = fsub double %101, %105
DOALL:     	  %107 = fmul double %106, 0x4160000000000000
DOALL:     	  %108 = fmul double %92, %98
DOALL:     	  %109 = fadd double %107, %108
DOALL:     	  %110 = fmul double %109, 0x3D10000000000000
DOALL:     	  %111 = fptosi double %110 to i32
DOALL:     	  %112 = sitofp i32 %111 to double
DOALL:     	  %113 = fmul double %112, 0x42D0000000000000
DOALL:     	  %114 = fsub double %109, %113
DOALL:     	  store double %114, double* %4, align 8, !tbaa !33
DOALL:     External nodes: 6
DOALL:     	  br i1 %26, label %27, label %116, !prof !39
DOALL:     	  store i64 %28, i64* %20, align 8, !tbaa !33
DOALL:     	  br i1 %86, label %.._crit_edge_crit_edge, label %87, !prof !46
DOALL:     	  %90 = sitofp i32 %89 to double
DOALL:     	  %92 = fsub double %21, %91
DOALL:     	  %115 = fmul double %114, 0x3D10000000000000
DOALL:     Edges: 61
DOALL:     Loop-carried data dependences
DOALL:         store double %114, double* %4, align 8, !tbaa !33 --->   %93 = load double, double* %4, align 8, !tbaa !33 via memory
DOALL:         store double %114, double* %4, align 8, !tbaa !33 --->   store double %114, double* %4, align 8, !tbaa !33 via memory
DOALL:         store double %114, double* %4, align 8, !tbaa !33 --->   %28 = load i64, i64* %19, align 8, !tbaa !33 via memory
DOALL:         %28 = load i64, i64* %19, align 8, !tbaa !33 --->   store double %114, double* %4, align 8, !tbaa !33 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 6
DOALL:     	  %.0 = phi i64 [ %indvars.iv4.lcssa, %81 ], [ 1, %vranlc.exit ]
DOALL:     	  %sext = shl i64 %.0, 32
DOALL:     	  %67 = ashr exact i64 %sext, 32
DOALL:     	  %indvars.iv4 = phi i64 [ %indvars.iv.next5, %69 ], [ %67, %66 ]
DOALL:     	  %indvars.iv.next5 = add nsw i64 %indvars.iv4, 2
DOALL:     	  %indvars.iv4.lcssa = phi i64 [ %indvars.iv4, %68 ]
DOALL:     External nodes: 4
DOALL:     	  br i1 %65, label %66, label %82, !prof !41
DOALL:     	  br i1 %exitcond, label %81, label %69, !prof !42
DOALL:     	  %70 = add nsw i64 %indvars.iv4, 1
DOALL:     	  %71 = getelementptr inbounds [524289 x double], [524289 x double]* @compute_initial_conditions.tmp, i64 0, i64 %indvars.iv4
DOALL:     Edges: 16
DOALL:     Loop-carried data dependences
DOALL:         %indvars.iv4.lcssa = phi i64 [ %indvars.iv4, %68 ] --->   %.0 = phi i64 [ %indvars.iv4.lcssa, %81 ], [ 1, %vranlc.exit ] via variable
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca [3 x i32], align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca [3 x i32], align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The next live-out variables are not reducable
DOALL:     Live-out ID = 8
DOALL:     Live-out ID = 9
DOALL:     Live-out ID = 10
DOALL:     Live-out ID = 11
DOALL:     Live-out ID = 12
Inliner:   Inlining in: main (740 instructions. The inlining will add 451 instructions),   call fastcc void @cffts2(i32 -1, i32* %289, [256 x [512 x %struct.dcomplex]]* %290, [256 x [512 x %struct.dcomplex]]* %290, [18 x %struct.dcomplex]* nonnull %48, [18 x %struct.dcomplex]* nonnull %60) #13
Inliner:   Inlined calls due to loop-carried data dependences
Inliner: Exit
Noelle:  Function "main"
Noelle:     Loop "  %exitcond8 = icmp eq i32 %.02, 7" (5.403796e-09%)
Noelle:     Loop "  %exitcond = icmp eq i32 %.1, 7" (5.403796e-09%)
Noelle:     Loop "  %.b4 = load i1, i1* @niter, align 4" (2.988794e+01%)
Noelle:     Loop "  %exitcond.i = icmp eq i64 %indvars.iv15.i, 3" (3.485045e-07%)
Noelle:     Loop "  %69 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 1" (1.118614e+01%)
Noelle:     Loop "  %76 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 0" (1.118613e+01%)
Noelle:     Loop "  %86 = icmp slt i64 %indvars.iv7.i, %84" (1.112869e+00%)
Noelle:     Loop "  %88 = icmp slt i64 %indvars.iv.i, %83" (1.092535e+00%)
Noelle:     Loop "  %112 = icmp sgt i32 %.0.i.i, %65" (8.687976e+00%)
Noelle:     Loop "  %130 = icmp slt i64 %indvars.iv16.i11.i.i, %127" (4.448699e+00%)
Noelle:     Loop "  %143 = icmp slt i64 %indvars.iv14.i13.i.i, %126" (4.415377e+00%)
Noelle:     Loop "  %150 = icmp slt i64 %indvars.iv12.i14.i.i, %125" (4.322537e+00%)
Noelle:     Loop "  %194 = icmp slt i64 %indvars.iv16.i.i.i, %191" (4.236856e+00%)
Noelle:     Loop "  %207 = icmp slt i64 %indvars.iv14.i.i.i, %190" (4.205121e+00%)
Noelle:     Loop "  %214 = icmp slt i64 %indvars.iv12.i.i.i, %189" (4.116701e+00%)
Noelle:     Loop "  %248 = icmp slt i64 %indvars.iv5.i.i, %246" (3.801964e-01%)
Noelle:     Loop "  %250 = icmp slt i64 %indvars.iv.i.i, %245" (3.720706e-01%)
Noelle:     Loop "  %270 = icmp slt i64 %indvars.iv11.i, %268" (1.004630e+00%)
Noelle:     Loop "  %272 = icmp slt i64 %indvars.iv9.i, %266" (9.842958e-01%)
Noelle:     Loop "  %exitcond.i1 = icmp eq i64 %indvars.iv14.i, 3" (3.485045e-07%)
Noelle:     Loop "  %308 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (6.376734e+00%)
Noelle:     Loop "  %315 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 1" (6.376730e+00%)
Noelle:     Loop "  %324 = icmp slt i64 %indvars.iv6.i, %322" (9.213156e-01%)
Noelle:     Loop "  %330 = icmp slt i64 %indvars.iv.i5, %321" (9.203445e-01%)
Noelle:     Loop "  %351 = icmp sgt i32 %.0.i.i10, %304" (4.343980e+00%)
Noelle:     Loop "  %369 = icmp slt i64 %indvars.iv16.i11.i.i15, %366" (2.224345e+00%)
Noelle:     Loop "  %382 = icmp slt i64 %indvars.iv14.i13.i.i17, %365" (2.207684e+00%)
Noelle:     Loop "  %389 = icmp slt i64 %indvars.iv12.i14.i.i18, %364" (2.161264e+00%)
Noelle:     Loop "  %433 = icmp slt i64 %indvars.iv16.i.i.i25, %430" (2.118424e+00%)
Noelle:     Loop "  %446 = icmp slt i64 %indvars.iv14.i.i.i27, %429" (2.102557e+00%)
Noelle:     Loop "  %453 = icmp slt i64 %indvars.iv12.i.i.i28, %428" (2.058347e+00%)
Noelle:     Loop "  %487 = icmp slt i64 %indvars.iv5.i.i35, %485" (1.900979e-01%)
Noelle:     Loop "  %489 = icmp slt i64 %indvars.iv.i.i37, %484" (1.860350e-01%)
Noelle:     Loop "  %509 = icmp slt i64 %indvars.iv10.i, %503" (9.211042e-01%)
Noelle:     Loop "  %513 = icmp slt i64 %indvars.iv8.i, %507" (9.203445e-01%)
Noelle:  Function "fft"
Noelle:  Function "cfftz"
Noelle:     Loop "  %12 = icmp sgt i32 %.0, %1" (2.389494e+01%)
Noelle:     Loop "  %77 = icmp slt i64 %indvars.iv16.i11, %29" (1.112306e+01%)
Noelle:     Loop "  %90 = icmp slt i64 %indvars.iv14.i13, %28" (1.103975e+01%)
Noelle:     Loop "  %97 = icmp slt i64 %indvars.iv12.i14, %27" (1.080762e+01%)
Noelle:     Loop "  %32 = icmp slt i64 %indvars.iv10.i4, %29" (1.111788e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv8.i6, %28" (1.103975e+00%)
Noelle:     Loop "  %52 = icmp slt i64 %indvars.iv.i8, %27" (1.080762e+00%)
Noelle:     Loop "  %188 = icmp slt i64 %indvars.iv16.i, %140" (1.059339e+01%)
Noelle:     Loop "  %201 = icmp slt i64 %indvars.iv14.i, %139" (1.051405e+01%)
Noelle:     Loop "  %208 = icmp slt i64 %indvars.iv12.i, %138" (1.029297e+01%)
Noelle:     Loop "  %143 = icmp slt i64 %indvars.iv10.i, %140" (1.058846e+00%)
Noelle:     Loop "  %155 = icmp slt i64 %indvars.iv8.i, %139" (1.051405e+00%)
Noelle:     Loop "  %163 = icmp slt i64 %indvars.iv.i, %138" (1.029297e+00%)
Noelle:     Loop "  %242 = icmp slt i64 %indvars.iv5, %240" (1.045664e+00%)
Noelle:     Loop "  %244 = icmp slt i64 %indvars.iv, %239" (1.023315e+00%)
Noelle:  Function "fftz2"
Noelle:     Loop "  %70 = icmp slt i64 %indvars.iv16, %22" (2.171633e+01%)
Noelle:     Loop "  %83 = icmp slt i64 %indvars.iv14, %21" (2.155369e+01%)
Noelle:     Loop "  %90 = icmp slt i64 %indvars.iv12, %20" (2.110050e+01%)
Noelle:     Loop "  %25 = icmp slt i64 %indvars.iv10, %22" (2.170524e+00%)
Noelle:     Loop "  %37 = icmp slt i64 %indvars.iv8, %21" (2.155307e+00%)
Noelle:     Loop "  %45 = icmp slt i64 %indvars.iv, %20" (2.110010e+00%)
Noelle:  Function "cffts3"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (1.487798e+09%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 1" (1.230614e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 0" (1.230613e+01%)
Noelle:     Loop "  %42 = icmp slt i64 %indvars.iv7, %40" (1.224291e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv, %39" (1.201921e+00%)
Noelle:     Loop "  %69 = icmp sgt i32 %.0.i, %21" (9.557783e+00%)
Noelle:     Loop "  %133 = icmp slt i64 %indvars.iv16.i11.i, %85" (4.449191e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv14.i13.i, %84" (4.415866e+00%)
Noelle:     Loop "  %153 = icmp slt i64 %indvars.iv12.i14.i, %83" (4.323015e+00%)
Noelle:     Loop "  %88 = icmp slt i64 %indvars.iv10.i4.i, %85" (4.447119e-01%)
Noelle:     Loop "  %100 = icmp slt i64 %indvars.iv8.i6.i, %84" (4.415866e-01%)
Noelle:     Loop "  %108 = icmp slt i64 %indvars.iv.i8.i, %83" (4.323015e-01%)
Noelle:     Loop "  %243 = icmp slt i64 %indvars.iv16.i.i, %195" (4.237325e+00%)
Noelle:     Loop "  %256 = icmp slt i64 %indvars.iv14.i.i, %194" (4.205586e+00%)
Noelle:     Loop "  %263 = icmp slt i64 %indvars.iv12.i.i, %193" (4.117157e+00%)
Noelle:     Loop "  %198 = icmp slt i64 %indvars.iv10.i.i, %195" (4.235351e-01%)
Noelle:     Loop "  %210 = icmp slt i64 %indvars.iv8.i.i, %194" (4.205586e-01%)
Noelle:     Loop "  %218 = icmp slt i64 %indvars.iv.i.i, %193" (4.117157e-01%)
Noelle:     Loop "  %297 = icmp slt i64 %indvars.iv5.i, %295" (4.182624e-01%)
Noelle:     Loop "  %299 = icmp slt i64 %indvars.iv.i, %294" (4.093230e-01%)
Noelle:     Loop "  %319 = icmp slt i64 %indvars.iv11, %317" (1.105216e+00%)
Noelle:     Loop "  %321 = icmp slt i64 %indvars.iv9, %315" (1.082845e+00%)
Noelle:  Function "cffts2"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (3.833469e-07%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 2" (1.230614e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 0" (1.230613e+01%)
Noelle:     Loop "  %42 = icmp slt i64 %indvars.iv7, %40" (1.224291e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv, %39" (1.201921e+00%)
Noelle:     Loop "  %69 = icmp sgt i32 %.0.i, %21" (9.557783e+00%)
Noelle:     Loop "  %133 = icmp slt i64 %indvars.iv16.i11.i, %85" (4.449191e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv14.i13.i, %84" (4.415866e+00%)
Noelle:     Loop "  %153 = icmp slt i64 %indvars.iv12.i14.i, %83" (4.323015e+00%)
Noelle:     Loop "  %88 = icmp slt i64 %indvars.iv10.i4.i, %85" (4.447119e-01%)
Noelle:     Loop "  %100 = icmp slt i64 %indvars.iv8.i6.i, %84" (4.415866e-01%)
Noelle:     Loop "  %108 = icmp slt i64 %indvars.iv.i8.i, %83" (4.323015e-01%)
Noelle:     Loop "  %243 = icmp slt i64 %indvars.iv16.i.i, %195" (4.237325e+00%)
Noelle:     Loop "  %256 = icmp slt i64 %indvars.iv14.i.i, %194" (4.205586e+00%)
Noelle:     Loop "  %263 = icmp slt i64 %indvars.iv12.i.i, %193" (4.117157e+00%)
Noelle:     Loop "  %198 = icmp slt i64 %indvars.iv10.i.i, %195" (4.235351e-01%)
Noelle:     Loop "  %210 = icmp slt i64 %indvars.iv8.i.i, %194" (4.205586e-01%)
Noelle:     Loop "  %218 = icmp slt i64 %indvars.iv.i.i, %193" (4.117157e-01%)
Noelle:     Loop "  %297 = icmp slt i64 %indvars.iv5.i, %295" (4.182624e-01%)
Noelle:     Loop "  %299 = icmp slt i64 %indvars.iv.i, %294" (4.093230e-01%)
Noelle:     Loop "  %319 = icmp slt i64 %indvars.iv11, %317" (1.105216e+00%)
Noelle:     Loop "  %321 = icmp slt i64 %indvars.iv9, %315" (1.082845e+00%)
Noelle:  Function "cffts1"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv14, 3" (3.833469e-07%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (7.015237e+00%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 1" (7.015232e+00%)
Noelle:     Loop "  %41 = icmp slt i64 %indvars.iv6, %39" (1.013565e+00%)
Noelle:     Loop "  %47 = icmp slt i64 %indvars.iv, %38" (1.012497e+00%)
Noelle:     Loop "  %69 = icmp sgt i32 %.0.i, %21" (4.778910e+00%)
Noelle:     Loop "  %133 = icmp slt i64 %indvars.iv16.i11.i, %85" (2.224604e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv14.i13.i, %84" (2.207941e+00%)
Noelle:     Loop "  %153 = icmp slt i64 %indvars.iv12.i14.i, %83" (2.161516e+00%)
Noelle:     Loop "  %88 = icmp slt i64 %indvars.iv10.i4.i, %85" (2.223568e-01%)
Noelle:     Loop "  %100 = icmp slt i64 %indvars.iv8.i6.i, %84" (2.207941e-01%)
Noelle:     Loop "  %108 = icmp slt i64 %indvars.iv.i8.i, %83" (2.161516e-01%)
Noelle:     Loop "  %243 = icmp slt i64 %indvars.iv16.i.i, %195" (2.118671e+00%)
Noelle:     Loop "  %256 = icmp slt i64 %indvars.iv14.i.i, %194" (2.102801e+00%)
Noelle:     Loop "  %263 = icmp slt i64 %indvars.iv12.i.i, %193" (2.058586e+00%)
Noelle:     Loop "  %198 = icmp slt i64 %indvars.iv10.i.i, %195" (2.117684e-01%)
Noelle:     Loop "  %210 = icmp slt i64 %indvars.iv8.i.i, %194" (2.102801e-01%)
Noelle:     Loop "  %218 = icmp slt i64 %indvars.iv.i.i, %193" (2.058586e-01%)
Noelle:     Loop "  %297 = icmp slt i64 %indvars.iv5.i, %295" (2.091320e-01%)
Noelle:     Loop "  %299 = icmp slt i64 %indvars.iv.i, %294" (2.046623e-01%)
Noelle:     Loop "  %319 = icmp slt i64 %indvars.iv10, %313" (1.013333e+00%)
Noelle:     Loop "  %323 = icmp slt i64 %indvars.iv8, %317" (1.012497e+00%)
Noelle:  Function "evolve"
Noelle:     Loop "  %16 = icmp slt i64 %indvars.iv5, %8" (1.137596e+00%)
Noelle:     Loop "  %18 = icmp slt i64 %indvars.iv3, %11" (1.137594e+00%)
Noelle:     Loop "  %20 = icmp slt i64 %indvars.iv, %14" (1.136958e+00%)
Noelle:  Function "compute_initial_conditions"
Noelle:     Loop "  %23 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (4.331556e-01%)
Noelle:     Loop "  %36 = icmp sgt i64 %indvars.iv.i, %34" (3.247535e-01%)
Noelle:     Loop "  %65 = icmp slt i64 %indvars.iv6, %63" (1.083997e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 512" (1.082938e-01%)
Noelle:  Function "vranlc"
Noelle:     Loop "  %13 = icmp sgt i64 %indvars.iv, %11" (3.247534e-01%)
Noelle:  Function "compute_indexmap"
Noelle:     Loop "  %15 = icmp slt i64 %indvars.iv10, %4" (7.611559e-02%)
Noelle:     Loop "  %23 = icmp slt i64 %indvars.iv8, %8" (7.611460e-02%)
Noelle:     Loop "  %33 = icmp slt i64 %indvars.iv6, %12" (7.583949e-02%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 1966081" (3.489425e-03%)
Noelle:  Function "checksum"
Noelle:     Loop "  %exitcond = icmp eq i32 %.0, 1025" (6.938313e-05%)
Noelle:  Function "randlc"
Noelle:  Function "fft_init"
Noelle:     Loop "  %7 = icmp sgt i32 %.01, %2" (1.261907e-06%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count" (1.240776e-06%)
Noelle:  Function "ilog2"
Noelle:     Loop "  %3 = icmp slt i32 %.01, %0" (8.933201e-07%)
Noelle:  Function "ipow46"
Noelle:     Loop "  %11 = icmp sgt i32 %.01, 1" (1.196094e-07%)
Noelle:  Function "verify"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 21" (3.734265e-08%)
Noelle:  Function "setup"
Noelle:     Loop "  %exitcond3 = icmp eq i64 %indvars.iv1, 3" (2.903532e-09%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 3" (4.355299e-09%)
Noelle:  Function "elapsed_time"
Noelle:  Function "timer_clear"
Noelle:  Function "c_print_results"
Noelle:  Function "wtime_"
Noelle:  Function "timer_stop"
Noelle:  Function "timer_start"
Noelle:  Function "timer_read"
Noelle:  Function "main"
Noelle:     Loop "  %exitcond8 = icmp eq i32 %.02, 7" (4.860234e-09%)
Noelle:     Loop "  %exitcond = icmp eq i32 %.1, 7" (4.860234e-09%)
Noelle:     Loop "  %.b4 = load i1, i1* @niter, align 4" (2.687837e+01%)
Noelle:     Loop "  %exitcond.i = icmp eq i64 %indvars.iv15.i, 3" (3.134488e-07%)
Noelle:     Loop "  %72 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 1" (1.006017e+01%)
Noelle:     Loop "  %79 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 0" (1.006016e+01%)
Noelle:     Loop "  %89 = icmp slt i64 %indvars.iv7.i, %87" (1.000850e+00%)
Noelle:     Loop "  %91 = icmp slt i64 %indvars.iv.i, %86" (9.825626e-01%)
Noelle:     Loop "  %115 = icmp sgt i32 %.0.i.i, %68" (7.813465e+00%)
Noelle:     Loop "  %133 = icmp slt i64 %indvars.iv16.i11.i.i, %130" (4.000903e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv14.i13.i.i, %129" (3.970936e+00%)
Noelle:     Loop "  %153 = icmp slt i64 %indvars.iv12.i14.i.i, %128" (3.887440e+00%)
Noelle:     Loop "  %197 = icmp slt i64 %indvars.iv16.i.i.i, %194" (3.810384e+00%)
Noelle:     Loop "  %210 = icmp slt i64 %indvars.iv14.i.i.i, %193" (3.781844e+00%)
Noelle:     Loop "  %217 = icmp slt i64 %indvars.iv12.i.i.i, %192" (3.702324e+00%)
Noelle:     Loop "  %251 = icmp slt i64 %indvars.iv5.i.i, %249" (3.419268e-01%)
Noelle:     Loop "  %253 = icmp slt i64 %indvars.iv.i.i, %248" (3.346189e-01%)
Noelle:     Loop "  %273 = icmp slt i64 %indvars.iv11.i, %271" (9.035065e-01%)
Noelle:     Loop "  %275 = icmp slt i64 %indvars.iv9.i, %269" (8.852190e-01%)
Noelle:     Loop "  %exitcond.i2 = icmp eq i64 %indvars.iv15.i1, 3" (3.134488e-07%)
Noelle:     Loop "  %309 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 2" (1.006013e+01%)
Noelle:     Loop "  %316 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 0" (1.006013e+01%)
Noelle:     Loop "  %326 = icmp slt i64 %indvars.iv7.i7, %324" (1.000846e+00%)
Noelle:     Loop "  %328 = icmp slt i64 %indvars.iv.i9, %323" (9.825589e-01%)
Noelle:     Loop "  %352 = icmp sgt i32 %.0.i.i15, %305" (7.813435e+00%)
Noelle:     Loop "  %370 = icmp slt i64 %indvars.iv16.i11.i.i20, %367" (4.000888e+00%)
Noelle:     Loop "  %383 = icmp slt i64 %indvars.iv14.i13.i.i22, %366" (3.970921e+00%)
Noelle:     Loop "  %390 = icmp slt i64 %indvars.iv12.i14.i.i23, %365" (3.887425e+00%)
Noelle:     Loop "  %434 = icmp slt i64 %indvars.iv16.i.i.i30, %431" (3.810370e+00%)
Noelle:     Loop "  %447 = icmp slt i64 %indvars.iv14.i.i.i32, %430" (3.781829e+00%)
Noelle:     Loop "  %454 = icmp slt i64 %indvars.iv12.i.i.i33, %429" (3.702310e+00%)
Noelle:     Loop "  %488 = icmp slt i64 %indvars.iv5.i.i40, %486" (3.419255e-01%)
Noelle:     Loop "  %490 = icmp slt i64 %indvars.iv.i.i42, %485" (3.346176e-01%)
Noelle:     Loop "  %510 = icmp slt i64 %indvars.iv11.i47, %508" (9.035031e-01%)
Noelle:     Loop "  %512 = icmp slt i64 %indvars.iv9.i49, %506" (8.852156e-01%)
Noelle:     Loop "  %exitcond.i1 = icmp eq i64 %indvars.iv14.i, 3" (3.134488e-07%)
Noelle:     Loop "  %546 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (5.734845e+00%)
Noelle:     Loop "  %553 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 1" (5.734842e+00%)
Noelle:     Loop "  %562 = icmp slt i64 %indvars.iv6.i, %560" (8.285750e-01%)
Noelle:     Loop "  %568 = icmp slt i64 %indvars.iv.i5, %559" (8.277016e-01%)
Noelle:     Loop "  %589 = icmp sgt i32 %.0.i.i10, %542" (3.906710e+00%)
Noelle:     Loop "  %607 = icmp slt i64 %indvars.iv16.i11.i.i15, %604" (2.000440e+00%)
Noelle:     Loop "  %620 = icmp slt i64 %indvars.iv14.i13.i.i17, %603" (1.985457e+00%)
Noelle:     Loop "  %627 = icmp slt i64 %indvars.iv12.i14.i.i18, %602" (1.943709e+00%)
Noelle:     Loop "  %671 = icmp slt i64 %indvars.iv16.i.i.i25, %668" (1.905181e+00%)
Noelle:     Loop "  %684 = icmp slt i64 %indvars.iv14.i.i.i27, %667" (1.890911e+00%)
Noelle:     Loop "  %691 = icmp slt i64 %indvars.iv12.i.i.i28, %666" (1.851151e+00%)
Noelle:     Loop "  %725 = icmp slt i64 %indvars.iv5.i.i35, %723" (1.709624e-01%)
Noelle:     Loop "  %727 = icmp slt i64 %indvars.iv.i.i37, %722" (1.673085e-01%)
Noelle:     Loop "  %747 = icmp slt i64 %indvars.iv10.i, %741" (8.283849e-01%)
Noelle:     Loop "  %751 = icmp slt i64 %indvars.iv8.i, %745" (8.277016e-01%)
Noelle:  Function "fft"
Noelle:  Function "cfftz"
Noelle:     Loop "  %12 = icmp sgt i32 %.0, %1" (2.149137e+01%)
Noelle:     Loop "  %77 = icmp slt i64 %indvars.iv16.i11, %29" (1.000421e+01%)
Noelle:     Loop "  %90 = icmp slt i64 %indvars.iv14.i13, %28" (9.929271e+00%)
Noelle:     Loop "  %97 = icmp slt i64 %indvars.iv12.i14, %27" (9.720492e+00%)
Noelle:     Loop "  %32 = icmp slt i64 %indvars.iv10.i4, %29" (9.999545e-01%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv8.i6, %28" (9.929271e-01%)
Noelle:     Loop "  %52 = icmp slt i64 %indvars.iv.i8, %27" (9.720492e-01%)
Noelle:     Loop "  %188 = icmp slt i64 %indvars.iv16.i, %140" (9.527815e+00%)
Noelle:     Loop "  %201 = icmp slt i64 %indvars.iv14.i, %139" (9.456449e+00%)
Noelle:     Loop "  %208 = icmp slt i64 %indvars.iv12.i, %138" (9.257611e+00%)
Noelle:     Loop "  %143 = icmp slt i64 %indvars.iv10.i, %140" (9.523376e-01%)
Noelle:     Loop "  %155 = icmp slt i64 %indvars.iv8.i, %139" (9.456449e-01%)
Noelle:     Loop "  %163 = icmp slt i64 %indvars.iv.i, %138" (9.257611e-01%)
Noelle:     Loop "  %242 = icmp slt i64 %indvars.iv5, %240" (9.404816e-01%)
Noelle:     Loop "  %244 = icmp slt i64 %indvars.iv, %239" (9.203810e-01%)
Noelle:  Function "fftz2"
Noelle:     Loop "  %70 = icmp slt i64 %indvars.iv16, %22" (1.953191e+01%)
Noelle:     Loop "  %83 = icmp slt i64 %indvars.iv14, %21" (1.938562e+01%)
Noelle:     Loop "  %90 = icmp slt i64 %indvars.iv12, %20" (1.897802e+01%)
Noelle:     Loop "  %25 = icmp slt i64 %indvars.iv10, %22" (1.952193e+00%)
Noelle:     Loop "  %37 = icmp slt i64 %indvars.iv8, %21" (1.938507e+00%)
Noelle:     Loop "  %45 = icmp slt i64 %indvars.iv, %20" (1.897766e+00%)
Noelle:  Function "cffts3"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (1.338142e+09%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 1" (1.106828e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 0" (1.106827e+01%)
Noelle:     Loop "  %42 = icmp slt i64 %indvars.iv7, %40" (1.101141e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv, %39" (1.081021e+00%)
Noelle:     Loop "  %69 = icmp sgt i32 %.0.i, %21" (8.596375e+00%)
Noelle:     Loop "  %133 = icmp slt i64 %indvars.iv16.i11.i, %85" (4.001651e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv14.i13.i, %84" (3.971678e+00%)
Noelle:     Loop "  %153 = icmp slt i64 %indvars.iv12.i14.i, %83" (3.888167e+00%)
Noelle:     Loop "  %88 = icmp slt i64 %indvars.iv10.i4.i, %85" (3.999787e-01%)
Noelle:     Loop "  %100 = icmp slt i64 %indvars.iv8.i6.i, %84" (3.971678e-01%)
Noelle:     Loop "  %108 = icmp slt i64 %indvars.iv.i8.i, %83" (3.888167e-01%)
Noelle:     Loop "  %243 = icmp slt i64 %indvars.iv16.i.i, %195" (3.811096e+00%)
Noelle:     Loop "  %256 = icmp slt i64 %indvars.iv14.i.i, %194" (3.782550e+00%)
Noelle:     Loop "  %263 = icmp slt i64 %indvars.iv12.i.i, %193" (3.703016e+00%)
Noelle:     Loop "  %198 = icmp slt i64 %indvars.iv10.i.i, %195" (3.809321e-01%)
Noelle:     Loop "  %210 = icmp slt i64 %indvars.iv8.i.i, %194" (3.782550e-01%)
Noelle:     Loop "  %218 = icmp slt i64 %indvars.iv.i.i, %193" (3.703016e-01%)
Noelle:     Loop "  %297 = icmp slt i64 %indvars.iv5.i, %295" (3.761898e-01%)
Noelle:     Loop "  %299 = icmp slt i64 %indvars.iv.i, %294" (3.681496e-01%)
Noelle:     Loop "  %319 = icmp slt i64 %indvars.iv11, %317" (9.940430e-01%)
Noelle:     Loop "  %321 = icmp slt i64 %indvars.iv9, %315" (9.739229e-01%)
Noelle:  Function "cffts2"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (3.447864e-07%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 2" (1.106828e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 0" (1.106827e+01%)
Noelle:     Loop "  %42 = icmp slt i64 %indvars.iv7, %40" (1.101141e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv, %39" (1.081021e+00%)
Noelle:     Loop "  %69 = icmp sgt i32 %.0.i, %21" (8.596375e+00%)
Noelle:     Loop "  %133 = icmp slt i64 %indvars.iv16.i11.i, %85" (4.001651e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv14.i13.i, %84" (3.971678e+00%)
Noelle:     Loop "  %153 = icmp slt i64 %indvars.iv12.i14.i, %83" (3.888167e+00%)
Noelle:     Loop "  %88 = icmp slt i64 %indvars.iv10.i4.i, %85" (3.999787e-01%)
Noelle:     Loop "  %100 = icmp slt i64 %indvars.iv8.i6.i, %84" (3.971678e-01%)
Noelle:     Loop "  %108 = icmp slt i64 %indvars.iv.i8.i, %83" (3.888167e-01%)
Noelle:     Loop "  %243 = icmp slt i64 %indvars.iv16.i.i, %195" (3.811096e+00%)
Noelle:     Loop "  %256 = icmp slt i64 %indvars.iv14.i.i, %194" (3.782550e+00%)
Noelle:     Loop "  %263 = icmp slt i64 %indvars.iv12.i.i, %193" (3.703016e+00%)
Noelle:     Loop "  %198 = icmp slt i64 %indvars.iv10.i.i, %195" (3.809321e-01%)
Noelle:     Loop "  %210 = icmp slt i64 %indvars.iv8.i.i, %194" (3.782550e-01%)
Noelle:     Loop "  %218 = icmp slt i64 %indvars.iv.i.i, %193" (3.703016e-01%)
Noelle:     Loop "  %297 = icmp slt i64 %indvars.iv5.i, %295" (3.761898e-01%)
Noelle:     Loop "  %299 = icmp slt i64 %indvars.iv.i, %294" (3.681496e-01%)
Noelle:     Loop "  %319 = icmp slt i64 %indvars.iv11, %317" (9.940430e-01%)
Noelle:     Loop "  %321 = icmp slt i64 %indvars.iv9, %315" (9.739229e-01%)
Noelle:  Function "cffts1"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv14, 3" (3.447864e-07%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (6.309581e+00%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 1" (6.309577e+00%)
Noelle:     Loop "  %41 = icmp slt i64 %indvars.iv6, %39" (9.116116e-01%)
Noelle:     Loop "  %47 = icmp slt i64 %indvars.iv, %38" (9.106507e-01%)
Noelle:     Loop "  %69 = icmp sgt i32 %.0.i, %21" (4.298204e+00%)
Noelle:     Loop "  %133 = icmp slt i64 %indvars.iv16.i11.i, %85" (2.000833e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv14.i13.i, %84" (1.985847e+00%)
Noelle:     Loop "  %153 = icmp slt i64 %indvars.iv12.i14.i, %83" (1.944091e+00%)
Noelle:     Loop "  %88 = icmp slt i64 %indvars.iv10.i4.i, %85" (1.999901e-01%)
Noelle:     Loop "  %100 = icmp slt i64 %indvars.iv8.i6.i, %84" (1.985847e-01%)
Noelle:     Loop "  %108 = icmp slt i64 %indvars.iv.i8.i, %83" (1.944091e-01%)
Noelle:     Loop "  %243 = icmp slt i64 %indvars.iv16.i.i, %195" (1.905556e+00%)
Noelle:     Loop "  %256 = icmp slt i64 %indvars.iv14.i.i, %194" (1.891282e+00%)
Noelle:     Loop "  %263 = icmp slt i64 %indvars.iv12.i.i, %193" (1.851515e+00%)
Noelle:     Loop "  %198 = icmp slt i64 %indvars.iv10.i.i, %195" (1.904668e-01%)
Noelle:     Loop "  %210 = icmp slt i64 %indvars.iv8.i.i, %194" (1.891282e-01%)
Noelle:     Loop "  %218 = icmp slt i64 %indvars.iv.i.i, %193" (1.851515e-01%)
Noelle:     Loop "  %297 = icmp slt i64 %indvars.iv5.i, %295" (1.880956e-01%)
Noelle:     Loop "  %299 = icmp slt i64 %indvars.iv.i, %294" (1.840755e-01%)
Noelle:     Loop "  %319 = icmp slt i64 %indvars.iv10, %313" (9.114024e-01%)
Noelle:     Loop "  %323 = icmp slt i64 %indvars.iv8, %317" (9.106507e-01%)
Noelle:  Function "evolve"
Noelle:     Loop "  %16 = icmp slt i64 %indvars.iv5, %8" (1.023166e+00%)
Noelle:     Loop "  %18 = icmp slt i64 %indvars.iv3, %11" (1.023164e+00%)
Noelle:     Loop "  %20 = icmp slt i64 %indvars.iv, %14" (1.022593e+00%)
Noelle:  Function "compute_initial_conditions"
Noelle:     Loop "  %23 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (3.895849e-01%)
Noelle:     Loop "  %36 = icmp sgt i64 %indvars.iv.i, %34" (2.920869e-01%)
Noelle:     Loop "  %65 = icmp slt i64 %indvars.iv6, %63" (9.749587e-02%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 512" (9.740064e-02%)
Noelle:  Function "vranlc"
Noelle:     Loop "  %13 = icmp sgt i64 %indvars.iv, %11" (2.920867e-01%)
Noelle:  Function "compute_indexmap"
Noelle:     Loop "  %15 = icmp slt i64 %indvars.iv10, %4" (6.845920e-02%)
Noelle:     Loop "  %23 = icmp slt i64 %indvars.iv8, %8" (6.845830e-02%)
Noelle:     Loop "  %33 = icmp slt i64 %indvars.iv6, %12" (6.821087e-02%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 1966081" (3.138427e-03%)
Noelle:  Function "checksum"
Noelle:     Loop "  %exitcond = icmp eq i32 %.0, 1025" (6.240395e-05%)
Noelle:  Function "randlc"
Noelle:  Function "fft_init"
Noelle:     Loop "  %7 = icmp sgt i32 %.01, %2" (1.134973e-06%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count" (1.115968e-06%)
Noelle:  Function "ilog2"
Noelle:     Loop "  %3 = icmp slt i32 %.01, %0" (8.034619e-07%)
Noelle:  Function "ipow46"
Noelle:     Loop "  %11 = icmp sgt i32 %.01, 1" (1.075780e-07%)
Noelle:  Function "verify"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 21" (3.358639e-08%)
Noelle:  Function "setup"
Noelle:     Loop "  %exitcond3 = icmp eq i64 %indvars.iv1, 3" (2.611469e-09%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 3" (3.917203e-09%)
Noelle:  Function "elapsed_time"
Noelle:  Function "timer_clear"
Noelle:  Function "c_print_results"
Noelle:  Function "wtime_"
Noelle:  Function "timer_stop"
Noelle:  Function "timer_start"
Noelle:  Function "timer_read"
NOELLE: FixedPoint:       There are 258 different instructions and 1190 different loop instructions
NOELLE: FixedPoint:       Normalize the code
noelle-norm /tmp/tmp.mEnWC8flov -o /tmp/tmp.mEnWC8flov
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.mEnWC8flov -o /tmp/tmp.mEnWC8flov
NOELLE: FixedPoint:     Invocation 6
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.1zCLAhAajz -o /tmp/tmp.mEnWC8flov
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.1zCLAhAajz -o /tmp/tmp.mEnWC8flov
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.1zCLAhAajz -o /tmp/tmp.mEnWC8flov
Inliner: Start
Inliner:   Number of program instructions = 3616
Inliner:   Profiles are available and will be used
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %273, double* %274, align 8, !tbaa !42
DOALL:     	  store double %275, double* %276, align 8, !tbaa !45
DOALL:     	  store double %281, double* %282, align 8, !tbaa !42
DOALL:     	  store double %285, double* %286, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %263, label %264, label %287, !prof !58
DOALL:     	  %273 = fadd double %266, %270
DOALL:     	  %274 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %275 = fadd double %268, %272
DOALL:     	  %276 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 1
DOALL:     	  %281 = fsub double %278, %280
DOALL:     	  %282 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %285 = fadd double %283, %284
DOALL:     	  %286 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %163, double* %164, align 8, !tbaa !42
DOALL:     	  store double %165, double* %166, align 8, !tbaa !45
DOALL:     	  store double %171, double* %172, align 8, !tbaa !42
DOALL:     	  store double %175, double* %176, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %153, label %154, label %177, !prof !58
DOALL:     	  %163 = fadd double %156, %160
DOALL:     	  %164 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %165 = fadd double %158, %162
DOALL:     	  %166 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 1
DOALL:     	  %171 = fsub double %168, %170
DOALL:     	  %172 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %175 = fadd double %173, %174
DOALL:     	  %176 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %119, double* %120, align 8, !tbaa !42
DOALL:     	  store double %121, double* %122, align 8, !tbaa !45
DOALL:     	  store double %127, double* %128, align 8, !tbaa !42
DOALL:     	  store double %131, double* %132, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %108, label %110, label %109, !prof !55
DOALL:     	  %119 = fadd double %112, %116
DOALL:     	  %120 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %121 = fadd double %114, %118
DOALL:     	  %122 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 1
DOALL:     	  %127 = fsub double %124, %126
DOALL:     	  %128 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %131 = fadd double %129, %130
DOALL:     	  %132 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %229, double* %230, align 8, !tbaa !42
DOALL:     	  store double %231, double* %232, align 8, !tbaa !45
DOALL:     	  store double %237, double* %238, align 8, !tbaa !42
DOALL:     	  store double %241, double* %242, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %218, label %220, label %219, !prof !55
DOALL:     	  %229 = fadd double %222, %226
DOALL:     	  %230 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %231 = fadd double %224, %228
DOALL:     	  %232 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 1
DOALL:     	  %237 = fsub double %234, %236
DOALL:     	  %238 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %241 = fadd double %239, %240
DOALL:     	  %242 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %163, double* %164, align 8, !tbaa !42
DOALL:     	  store double %165, double* %166, align 8, !tbaa !45
DOALL:     	  store double %171, double* %172, align 8, !tbaa !42
DOALL:     	  store double %175, double* %176, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %153, label %154, label %177, !prof !58
DOALL:     	  %163 = fadd double %156, %160
DOALL:     	  %164 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %165 = fadd double %158, %162
DOALL:     	  %166 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 1
DOALL:     	  %171 = fsub double %168, %170
DOALL:     	  %172 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %175 = fadd double %173, %174
DOALL:     	  %176 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %119, double* %120, align 8, !tbaa !42
DOALL:     	  store double %121, double* %122, align 8, !tbaa !45
DOALL:     	  store double %127, double* %128, align 8, !tbaa !42
DOALL:     	  store double %131, double* %132, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %108, label %110, label %109, !prof !55
DOALL:     	  %119 = fadd double %112, %116
DOALL:     	  %120 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %121 = fadd double %114, %118
DOALL:     	  %122 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 1
DOALL:     	  %127 = fsub double %124, %126
DOALL:     	  %128 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %131 = fadd double %129, %130
DOALL:     	  %132 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %229, double* %230, align 8, !tbaa !42
DOALL:     	  store double %231, double* %232, align 8, !tbaa !45
DOALL:     	  store double %237, double* %238, align 8, !tbaa !42
DOALL:     	  store double %241, double* %242, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %218, label %220, label %219, !prof !55
DOALL:     	  %229 = fadd double %222, %226
DOALL:     	  %230 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %231 = fadd double %224, %228
DOALL:     	  %232 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 1
DOALL:     	  %237 = fsub double %234, %236
DOALL:     	  %238 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %241 = fadd double %239, %240
DOALL:     	  %242 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %273, double* %274, align 8, !tbaa !42
DOALL:     	  store double %275, double* %276, align 8, !tbaa !45
DOALL:     	  store double %281, double* %282, align 8, !tbaa !42
DOALL:     	  store double %285, double* %286, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %263, label %264, label %287, !prof !58
DOALL:     	  %273 = fadd double %266, %270
DOALL:     	  %274 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %275 = fadd double %268, %272
DOALL:     	  %276 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 1
DOALL:     	  %281 = fsub double %278, %280
DOALL:     	  %282 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %285 = fadd double %283, %284
DOALL:     	  %286 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %273, double* %274, align 8, !tbaa !42
DOALL:     	  store double %275, double* %276, align 8, !tbaa !45
DOALL:     	  store double %281, double* %282, align 8, !tbaa !42
DOALL:     	  store double %285, double* %286, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %263, label %264, label %287, !prof !58
DOALL:     	  %273 = fadd double %266, %270
DOALL:     	  %274 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %275 = fadd double %268, %272
DOALL:     	  %276 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 1
DOALL:     	  %281 = fsub double %278, %280
DOALL:     	  %282 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %285 = fadd double %283, %284
DOALL:     	  %286 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %163, double* %164, align 8, !tbaa !42
DOALL:     	  store double %165, double* %166, align 8, !tbaa !45
DOALL:     	  store double %171, double* %172, align 8, !tbaa !42
DOALL:     	  store double %175, double* %176, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %153, label %154, label %177, !prof !58
DOALL:     	  %163 = fadd double %156, %160
DOALL:     	  %164 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %165 = fadd double %158, %162
DOALL:     	  %166 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 1
DOALL:     	  %171 = fsub double %168, %170
DOALL:     	  %172 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %175 = fadd double %173, %174
DOALL:     	  %176 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %119, double* %120, align 8, !tbaa !42
DOALL:     	  store double %121, double* %122, align 8, !tbaa !45
DOALL:     	  store double %127, double* %128, align 8, !tbaa !42
DOALL:     	  store double %131, double* %132, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %108, label %110, label %109, !prof !55
DOALL:     	  %119 = fadd double %112, %116
DOALL:     	  %120 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %121 = fadd double %114, %118
DOALL:     	  %122 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 1
DOALL:     	  %127 = fsub double %124, %126
DOALL:     	  %128 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %131 = fadd double %129, %130
DOALL:     	  %132 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %229, double* %230, align 8, !tbaa !42
DOALL:     	  store double %231, double* %232, align 8, !tbaa !45
DOALL:     	  store double %237, double* %238, align 8, !tbaa !42
DOALL:     	  store double %241, double* %242, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %218, label %220, label %219, !prof !55
DOALL:     	  %229 = fadd double %222, %226
DOALL:     	  %230 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %231 = fadd double %224, %228
DOALL:     	  %232 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 1
DOALL:     	  %237 = fsub double %234, %236
DOALL:     	  %238 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %241 = fadd double %239, %240
DOALL:     	  %242 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %163, double* %164, align 8, !tbaa !42
DOALL:     	  store double %165, double* %166, align 8, !tbaa !45
DOALL:     	  store double %171, double* %172, align 8, !tbaa !42
DOALL:     	  store double %175, double* %176, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %153, label %154, label %177, !prof !58
DOALL:     	  %163 = fadd double %156, %160
DOALL:     	  %164 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %165 = fadd double %158, %162
DOALL:     	  %166 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 1
DOALL:     	  %171 = fsub double %168, %170
DOALL:     	  %172 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %175 = fadd double %173, %174
DOALL:     	  %176 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %273, double* %274, align 8, !tbaa !42
DOALL:     	  store double %275, double* %276, align 8, !tbaa !45
DOALL:     	  store double %281, double* %282, align 8, !tbaa !42
DOALL:     	  store double %285, double* %286, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %263, label %264, label %287, !prof !58
DOALL:     	  %273 = fadd double %266, %270
DOALL:     	  %274 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %275 = fadd double %268, %272
DOALL:     	  %276 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 1
DOALL:     	  %281 = fsub double %278, %280
DOALL:     	  %282 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %285 = fadd double %283, %284
DOALL:     	  %286 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %119, double* %120, align 8, !tbaa !42
DOALL:     	  store double %121, double* %122, align 8, !tbaa !45
DOALL:     	  store double %127, double* %128, align 8, !tbaa !42
DOALL:     	  store double %131, double* %132, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %108, label %110, label %109, !prof !55
DOALL:     	  %119 = fadd double %112, %116
DOALL:     	  %120 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %121 = fadd double %114, %118
DOALL:     	  %122 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 1
DOALL:     	  %127 = fsub double %124, %126
DOALL:     	  %128 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %131 = fadd double %129, %130
DOALL:     	  %132 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %229, double* %230, align 8, !tbaa !42
DOALL:     	  store double %231, double* %232, align 8, !tbaa !45
DOALL:     	  store double %237, double* %238, align 8, !tbaa !42
DOALL:     	  store double %241, double* %242, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %218, label %220, label %219, !prof !55
DOALL:     	  %229 = fadd double %222, %226
DOALL:     	  %230 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %231 = fadd double %224, %228
DOALL:     	  %232 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 1
DOALL:     	  %237 = fsub double %234, %236
DOALL:     	  %238 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %241 = fadd double %239, %240
DOALL:     	  %242 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %273, double* %274, align 8, !tbaa !42
DOALL:     	  store double %275, double* %276, align 8, !tbaa !45
DOALL:     	  store double %281, double* %282, align 8, !tbaa !42
DOALL:     	  store double %285, double* %286, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %263, label %264, label %287, !prof !58
DOALL:     	  %273 = fadd double %266, %270
DOALL:     	  %274 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %275 = fadd double %268, %272
DOALL:     	  %276 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 1
DOALL:     	  %281 = fsub double %278, %280
DOALL:     	  %282 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %285 = fadd double %283, %284
DOALL:     	  %286 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %163, double* %164, align 8, !tbaa !42
DOALL:     	  store double %165, double* %166, align 8, !tbaa !45
DOALL:     	  store double %171, double* %172, align 8, !tbaa !42
DOALL:     	  store double %175, double* %176, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %153, label %154, label %177, !prof !58
DOALL:     	  %163 = fadd double %156, %160
DOALL:     	  %164 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %165 = fadd double %158, %162
DOALL:     	  %166 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 1
DOALL:     	  %171 = fsub double %168, %170
DOALL:     	  %172 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %175 = fadd double %173, %174
DOALL:     	  %176 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %229, double* %230, align 8, !tbaa !42
DOALL:     	  store double %231, double* %232, align 8, !tbaa !45
DOALL:     	  store double %237, double* %238, align 8, !tbaa !42
DOALL:     	  store double %241, double* %242, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %218, label %220, label %219, !prof !55
DOALL:     	  %229 = fadd double %222, %226
DOALL:     	  %230 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %231 = fadd double %224, %228
DOALL:     	  %232 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 1
DOALL:     	  %237 = fsub double %234, %236
DOALL:     	  %238 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %241 = fadd double %239, %240
DOALL:     	  %242 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %119, double* %120, align 8, !tbaa !42
DOALL:     	  store double %121, double* %122, align 8, !tbaa !45
DOALL:     	  store double %127, double* %128, align 8, !tbaa !42
DOALL:     	  store double %131, double* %132, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %108, label %110, label %109, !prof !55
DOALL:     	  %119 = fadd double %112, %116
DOALL:     	  %120 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %121 = fadd double %114, %118
DOALL:     	  %122 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 1
DOALL:     	  %127 = fsub double %124, %126
DOALL:     	  %128 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %131 = fadd double %129, %130
DOALL:     	  %132 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %273, double* %274, align 8, !tbaa !42
DOALL:     	  store double %275, double* %276, align 8, !tbaa !45
DOALL:     	  store double %281, double* %282, align 8, !tbaa !42
DOALL:     	  store double %285, double* %286, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %263, label %264, label %287, !prof !58
DOALL:     	  %273 = fadd double %266, %270
DOALL:     	  %274 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %275 = fadd double %268, %272
DOALL:     	  %276 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %260, i64 %indvars.iv12.i.i, i32 1
DOALL:     	  %281 = fsub double %278, %280
DOALL:     	  %282 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 0
DOALL:     	  %285 = fadd double %283, %284
DOALL:     	  %286 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %261, i64 %indvars.iv12.i.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %273, double* %274, align 8, !tbaa !42 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %281, double* %282, align 8, !tbaa !42 via memory
DOALL:         store double %275, double* %276, align 8, !tbaa !45 --->   store double %285, double* %286, align 8, !tbaa !45 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %281, double* %282, align 8, !tbaa !42 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %273, double* %274, align 8, !tbaa !42 via memory
DOALL:         store double %285, double* %286, align 8, !tbaa !45 --->   store double %275, double* %276, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %229, double* %230, align 8, !tbaa !42
DOALL:     	  store double %231, double* %232, align 8, !tbaa !45
DOALL:     	  store double %237, double* %238, align 8, !tbaa !42
DOALL:     	  store double %241, double* %242, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %218, label %220, label %219, !prof !55
DOALL:     	  %229 = fadd double %222, %226
DOALL:     	  %230 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %231 = fadd double %224, %228
DOALL:     	  %232 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %215, i64 %indvars.iv.i.i, i32 1
DOALL:     	  %237 = fsub double %234, %236
DOALL:     	  %238 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 0
DOALL:     	  %241 = fadd double %239, %240
DOALL:     	  %242 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %22, i64 %216, i64 %indvars.iv.i.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !42 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %241, double* %242, align 8, !tbaa !45 via memory
DOALL:         store double %231, double* %232, align 8, !tbaa !45 --->   store double %237, double* %238, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %237, double* %238, align 8, !tbaa !42 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %229, double* %230, align 8, !tbaa !42 via memory
DOALL:         store double %241, double* %242, align 8, !tbaa !45 --->   store double %231, double* %232, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %163, double* %164, align 8, !tbaa !42
DOALL:     	  store double %165, double* %166, align 8, !tbaa !45
DOALL:     	  store double %171, double* %172, align 8, !tbaa !42
DOALL:     	  store double %175, double* %176, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %153, label %154, label %177, !prof !58
DOALL:     	  %163 = fadd double %156, %160
DOALL:     	  %164 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %165 = fadd double %158, %162
DOALL:     	  %166 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %150, i64 %indvars.iv12.i14.i, i32 1
DOALL:     	  %171 = fsub double %168, %170
DOALL:     	  %172 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 0
DOALL:     	  %175 = fadd double %173, %174
DOALL:     	  %176 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %151, i64 %indvars.iv12.i14.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !42 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %175, double* %176, align 8, !tbaa !45 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !45 --->   store double %171, double* %172, align 8, !tbaa !42 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !42 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %163, double* %164, align 8, !tbaa !42 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !45 --->   store double %165, double* %166, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %119, double* %120, align 8, !tbaa !42
DOALL:     	  store double %121, double* %122, align 8, !tbaa !45
DOALL:     	  store double %127, double* %128, align 8, !tbaa !42
DOALL:     	  store double %131, double* %132, align 8, !tbaa !45
DOALL:     External nodes: 9
DOALL:     	  br i1 %108, label %110, label %109, !prof !55
DOALL:     	  %119 = fadd double %112, %116
DOALL:     	  %120 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %121 = fadd double %114, %118
DOALL:     	  %122 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %105, i64 %indvars.iv.i8.i, i32 1
DOALL:     	  %127 = fsub double %124, %126
DOALL:     	  %128 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 0
DOALL:     	  %131 = fadd double %129, %130
DOALL:     	  %132 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %23, i64 %106, i64 %indvars.iv.i8.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %119, double* %120, align 8, !tbaa !42 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %131, double* %132, align 8, !tbaa !45 via memory
DOALL:         store double %121, double* %122, align 8, !tbaa !45 --->   store double %127, double* %128, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %127, double* %128, align 8, !tbaa !42 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %119, double* %120, align 8, !tbaa !42 via memory
DOALL:         store double %131, double* %132, align 8, !tbaa !45 --->   store double %121, double* %122, align 8, !tbaa !45 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8
ClonableMemoryObject:   It is clonable
ClonableMemoryObject:   It requires initialization
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca double, align 8 can be cloned
MemoryCloningAnalysis:     The private copies need to be initialized with the original object.
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 3
DOALL:     	  store double %59, double* %60, align 8, !tbaa !33
DOALL:     	  %73 = load i64, i64* %72, align 8, !tbaa !33
DOALL:     	  %78 = load i64, i64* %77, align 8, !tbaa !33
DOALL:     External nodes: 8
DOALL:     	  br i1 %36, label %vranlc.exit, label %37, !prof !40
DOALL:     	  %59 = fmul double %58, 0x3D10000000000000
DOALL:     	  %60 = getelementptr inbounds double, double* %32, i64 %indvars.iv.i
DOALL:     	  br i1 %exitcond, label %81, label %69, !prof !42
DOALL:     	  %72 = bitcast double* %71 to i64*
DOALL:     	  store i64 %73, i64* %75, align 16, !tbaa !43
DOALL:     	  %77 = bitcast double* %76 to i64*
DOALL:     	  store i64 %78, i64* %80, align 8, !tbaa !45
DOALL:     Edges: 14
DOALL:     Loop-carried data dependences
DOALL:         store double %59, double* %60, align 8, !tbaa !33 --->   store double %59, double* %60, align 8, !tbaa !33 via memory
DOALL:         store double %59, double* %60, align 8, !tbaa !33 --->   %73 = load i64, i64* %72, align 8, !tbaa !33 via memory
DOALL:         %73 = load i64, i64* %72, align 8, !tbaa !33 --->   store double %59, double* %60, align 8, !tbaa !33 via memory
DOALL:         %78 = load i64, i64* %77, align 8, !tbaa !33 --->   store double %59, double* %60, align 8, !tbaa !33 via memory
DOALL:         store double %59, double* %60, align 8, !tbaa !33 --->   %78 = load i64, i64* %77, align 8, !tbaa !33 via memory
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 24
DOALL:     	  %28 = load i64, i64* %19, align 8, !tbaa !33
DOALL:     	  %93 = load double, double* %4, align 8, !tbaa !33
DOALL:     	  %94 = fmul double %93, 0x3E80000000000000
DOALL:     	  %95 = fptosi double %94 to i32
DOALL:     	  %96 = sitofp i32 %95 to double
DOALL:     	  %97 = fmul double %96, 0x4160000000000000
DOALL:     	  %98 = fsub double %93, %97
DOALL:     	  %99 = fmul double %98, %90
DOALL:     	  %100 = fmul double %92, %96
DOALL:     	  %101 = fadd double %99, %100
DOALL:     	  %102 = fmul double %101, 0x3E80000000000000
DOALL:     	  %103 = fptosi double %102 to i32
DOALL:     	  %104 = sitofp i32 %103 to double
DOALL:     	  %105 = fmul double %104, 0x4160000000000000
DOALL:     	  %106 = fsub double %101, %105
DOALL:     	  %107 = fmul double %106, 0x4160000000000000
DOALL:     	  %108 = fmul double %92, %98
DOALL:     	  %109 = fadd double %107, %108
DOALL:     	  %110 = fmul double %109, 0x3D10000000000000
DOALL:     	  %111 = fptosi double %110 to i32
DOALL:     	  %112 = sitofp i32 %111 to double
DOALL:     	  %113 = fmul double %112, 0x42D0000000000000
DOALL:     	  %114 = fsub double %109, %113
DOALL:     	  store double %114, double* %4, align 8, !tbaa !33
DOALL:     External nodes: 6
DOALL:     	  br i1 %26, label %27, label %116, !prof !39
DOALL:     	  store i64 %28, i64* %20, align 8, !tbaa !33
DOALL:     	  br i1 %86, label %.._crit_edge_crit_edge, label %87, !prof !46
DOALL:     	  %90 = sitofp i32 %89 to double
DOALL:     	  %92 = fsub double %21, %91
DOALL:     	  %115 = fmul double %114, 0x3D10000000000000
DOALL:     Edges: 61
DOALL:     Loop-carried data dependences
DOALL:         store double %114, double* %4, align 8, !tbaa !33 --->   %28 = load i64, i64* %19, align 8, !tbaa !33 via memory
DOALL:         store double %114, double* %4, align 8, !tbaa !33 --->   %93 = load double, double* %4, align 8, !tbaa !33 via memory
DOALL:         %28 = load i64, i64* %19, align 8, !tbaa !33 --->   store double %114, double* %4, align 8, !tbaa !33 via memory
DOALL:         store double %114, double* %4, align 8, !tbaa !33 --->   store double %114, double* %4, align 8, !tbaa !33 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca [3 x i32], align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca [3 x i32], align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca [3 x i32], align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The next live-out variables are not reducable
DOALL:     Live-out ID = 11
DOALL:     Live-out ID = 12
DOALL:     Live-out ID = 13
DOALL:     Live-out ID = 14
DOALL:     Live-out ID = 15
DOALL:     Live-out ID = 16
DOALL:     Live-out ID = 17
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The next live-out variables are not reducable
DOALL:     Live-out ID = 5
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The next live-out variables are not reducable
DOALL:     Live-out ID = 5
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The next live-out variables are not reducable
DOALL:     Live-out ID = 4
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The next live-out variables are not reducable
DOALL:     Live-out ID = 7
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The next live-out variables are not reducable
DOALL:     Live-out ID = 6
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The next live-out variables are not reducable
DOALL:     Live-out ID = 7
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   More than 1 loop exit blocks
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %637, double* %638, align 8, !tbaa !44
DOALL:     	  store double %639, double* %640, align 8, !tbaa !47
DOALL:     	  store double %645, double* %646, align 8, !tbaa !44
DOALL:     	  store double %649, double* %650, align 8, !tbaa !47
DOALL:     External nodes: 9
DOALL:     	  br i1 %627, label %628, label %651, !prof !53
DOALL:     	  %637 = fadd double %630, %634
DOALL:     	  %638 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %544, i64 %624, i64 %indvars.iv12.i14.i.i18, i32 0
DOALL:     	  %639 = fadd double %632, %636
DOALL:     	  %640 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %544, i64 %624, i64 %indvars.iv12.i14.i.i18, i32 1
DOALL:     	  %645 = fsub double %642, %644
DOALL:     	  %646 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %544, i64 %625, i64 %indvars.iv12.i14.i.i18, i32 0
DOALL:     	  %649 = fadd double %647, %648
DOALL:     	  %650 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %544, i64 %625, i64 %indvars.iv12.i14.i.i18, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %637, double* %638, align 8, !tbaa !44 --->   store double %639, double* %640, align 8, !tbaa !47 via memory
DOALL:         store double %637, double* %638, align 8, !tbaa !44 --->   store double %637, double* %638, align 8, !tbaa !44 via memory
DOALL:         store double %637, double* %638, align 8, !tbaa !44 --->   store double %645, double* %646, align 8, !tbaa !44 via memory
DOALL:         store double %637, double* %638, align 8, !tbaa !44 --->   store double %649, double* %650, align 8, !tbaa !47 via memory
DOALL:         store double %639, double* %640, align 8, !tbaa !47 --->   store double %649, double* %650, align 8, !tbaa !47 via memory
DOALL:         store double %639, double* %640, align 8, !tbaa !47 --->   store double %645, double* %646, align 8, !tbaa !44 via memory
DOALL:         store double %639, double* %640, align 8, !tbaa !47 --->   store double %637, double* %638, align 8, !tbaa !44 via memory
DOALL:         store double %639, double* %640, align 8, !tbaa !47 --->   store double %639, double* %640, align 8, !tbaa !47 via memory
DOALL:         store double %645, double* %646, align 8, !tbaa !44 --->   store double %649, double* %650, align 8, !tbaa !47 via memory
DOALL:         store double %645, double* %646, align 8, !tbaa !44 --->   store double %637, double* %638, align 8, !tbaa !44 via memory
DOALL:         store double %645, double* %646, align 8, !tbaa !44 --->   store double %645, double* %646, align 8, !tbaa !44 via memory
DOALL:         store double %645, double* %646, align 8, !tbaa !44 --->   store double %639, double* %640, align 8, !tbaa !47 via memory
DOALL:         store double %649, double* %650, align 8, !tbaa !47 --->   store double %637, double* %638, align 8, !tbaa !44 via memory
DOALL:         store double %649, double* %650, align 8, !tbaa !47 --->   store double %649, double* %650, align 8, !tbaa !47 via memory
DOALL:         store double %649, double* %650, align 8, !tbaa !47 --->   store double %645, double* %646, align 8, !tbaa !44 via memory
DOALL:         store double %649, double* %650, align 8, !tbaa !47 --->   store double %639, double* %640, align 8, !tbaa !47 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %464, double* %465, align 8, !tbaa !44
DOALL:     	  store double %466, double* %467, align 8, !tbaa !47
DOALL:     	  store double %472, double* %473, align 8, !tbaa !44
DOALL:     	  store double %476, double* %477, align 8, !tbaa !47
DOALL:     External nodes: 9
DOALL:     	  br i1 %454, label %455, label %478, !prof !53
DOALL:     	  %464 = fadd double %457, %461
DOALL:     	  %465 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %306, i64 %451, i64 %indvars.iv12.i.i.i33, i32 0
DOALL:     	  %466 = fadd double %459, %463
DOALL:     	  %467 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %306, i64 %451, i64 %indvars.iv12.i.i.i33, i32 1
DOALL:     	  %472 = fsub double %469, %471
DOALL:     	  %473 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %306, i64 %452, i64 %indvars.iv12.i.i.i33, i32 0
DOALL:     	  %476 = fadd double %474, %475
DOALL:     	  %477 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %306, i64 %452, i64 %indvars.iv12.i.i.i33, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %464, double* %465, align 8, !tbaa !44 --->   store double %476, double* %477, align 8, !tbaa !47 via memory
DOALL:         store double %464, double* %465, align 8, !tbaa !44 --->   store double %472, double* %473, align 8, !tbaa !44 via memory
DOALL:         store double %464, double* %465, align 8, !tbaa !44 --->   store double %464, double* %465, align 8, !tbaa !44 via memory
DOALL:         store double %464, double* %465, align 8, !tbaa !44 --->   store double %466, double* %467, align 8, !tbaa !47 via memory
DOALL:         store double %466, double* %467, align 8, !tbaa !47 --->   store double %472, double* %473, align 8, !tbaa !44 via memory
DOALL:         store double %466, double* %467, align 8, !tbaa !47 --->   store double %466, double* %467, align 8, !tbaa !47 via memory
DOALL:         store double %466, double* %467, align 8, !tbaa !47 --->   store double %476, double* %477, align 8, !tbaa !47 via memory
DOALL:         store double %466, double* %467, align 8, !tbaa !47 --->   store double %464, double* %465, align 8, !tbaa !44 via memory
DOALL:         store double %472, double* %473, align 8, !tbaa !44 --->   store double %476, double* %477, align 8, !tbaa !47 via memory
DOALL:         store double %472, double* %473, align 8, !tbaa !44 --->   store double %472, double* %473, align 8, !tbaa !44 via memory
DOALL:         store double %472, double* %473, align 8, !tbaa !44 --->   store double %464, double* %465, align 8, !tbaa !44 via memory
DOALL:         store double %472, double* %473, align 8, !tbaa !44 --->   store double %466, double* %467, align 8, !tbaa !47 via memory
DOALL:         store double %476, double* %477, align 8, !tbaa !47 --->   store double %464, double* %465, align 8, !tbaa !44 via memory
DOALL:         store double %476, double* %477, align 8, !tbaa !47 --->   store double %476, double* %477, align 8, !tbaa !47 via memory
DOALL:         store double %476, double* %477, align 8, !tbaa !47 --->   store double %466, double* %467, align 8, !tbaa !47 via memory
DOALL:         store double %476, double* %477, align 8, !tbaa !47 --->   store double %472, double* %473, align 8, !tbaa !44 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %163, double* %164, align 8, !tbaa !44
DOALL:     	  store double %165, double* %166, align 8, !tbaa !47
DOALL:     	  store double %171, double* %172, align 8, !tbaa !44
DOALL:     	  store double %175, double* %176, align 8, !tbaa !47
DOALL:     External nodes: 9
DOALL:     	  br i1 %153, label %154, label %177, !prof !53
DOALL:     	  %163 = fadd double %156, %160
DOALL:     	  %164 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %70, i64 %150, i64 %indvars.iv12.i14.i.i, i32 0
DOALL:     	  %165 = fadd double %158, %162
DOALL:     	  %166 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %70, i64 %150, i64 %indvars.iv12.i14.i.i, i32 1
DOALL:     	  %171 = fsub double %168, %170
DOALL:     	  %172 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %70, i64 %151, i64 %indvars.iv12.i14.i.i, i32 0
DOALL:     	  %175 = fadd double %173, %174
DOALL:     	  %176 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %70, i64 %151, i64 %indvars.iv12.i14.i.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %163, double* %164, align 8, !tbaa !44 --->   store double %175, double* %176, align 8, !tbaa !47 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !44 --->   store double %171, double* %172, align 8, !tbaa !44 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !44 --->   store double %163, double* %164, align 8, !tbaa !44 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !44 --->   store double %165, double* %166, align 8, !tbaa !47 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !47 --->   store double %175, double* %176, align 8, !tbaa !47 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !47 --->   store double %171, double* %172, align 8, !tbaa !44 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !47 --->   store double %163, double* %164, align 8, !tbaa !44 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !47 --->   store double %165, double* %166, align 8, !tbaa !47 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !44 --->   store double %163, double* %164, align 8, !tbaa !44 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !44 --->   store double %171, double* %172, align 8, !tbaa !44 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !44 --->   store double %175, double* %176, align 8, !tbaa !47 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !44 --->   store double %165, double* %166, align 8, !tbaa !47 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !47 --->   store double %175, double* %176, align 8, !tbaa !47 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !47 --->   store double %171, double* %172, align 8, !tbaa !44 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !47 --->   store double %163, double* %164, align 8, !tbaa !44 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !47 --->   store double %165, double* %166, align 8, !tbaa !47 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %400, double* %401, align 8, !tbaa !44
DOALL:     	  store double %402, double* %403, align 8, !tbaa !47
DOALL:     	  store double %408, double* %409, align 8, !tbaa !44
DOALL:     	  store double %412, double* %413, align 8, !tbaa !47
DOALL:     External nodes: 9
DOALL:     	  br i1 %390, label %391, label %414, !prof !53
DOALL:     	  %400 = fadd double %393, %397
DOALL:     	  %401 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %307, i64 %387, i64 %indvars.iv12.i14.i.i23, i32 0
DOALL:     	  %402 = fadd double %395, %399
DOALL:     	  %403 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %307, i64 %387, i64 %indvars.iv12.i14.i.i23, i32 1
DOALL:     	  %408 = fsub double %405, %407
DOALL:     	  %409 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %307, i64 %388, i64 %indvars.iv12.i14.i.i23, i32 0
DOALL:     	  %412 = fadd double %410, %411
DOALL:     	  %413 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %307, i64 %388, i64 %indvars.iv12.i14.i.i23, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %402, double* %403, align 8, !tbaa !47 --->   store double %400, double* %401, align 8, !tbaa !44 via memory
DOALL:         store double %412, double* %413, align 8, !tbaa !47 --->   store double %402, double* %403, align 8, !tbaa !47 via memory
DOALL:         store double %400, double* %401, align 8, !tbaa !44 --->   store double %408, double* %409, align 8, !tbaa !44 via memory
DOALL:         store double %400, double* %401, align 8, !tbaa !44 --->   store double %412, double* %413, align 8, !tbaa !47 via memory
DOALL:         store double %400, double* %401, align 8, !tbaa !44 --->   store double %400, double* %401, align 8, !tbaa !44 via memory
DOALL:         store double %408, double* %409, align 8, !tbaa !44 --->   store double %412, double* %413, align 8, !tbaa !47 via memory
DOALL:         store double %402, double* %403, align 8, !tbaa !47 --->   store double %412, double* %413, align 8, !tbaa !47 via memory
DOALL:         store double %408, double* %409, align 8, !tbaa !44 --->   store double %402, double* %403, align 8, !tbaa !47 via memory
DOALL:         store double %412, double* %413, align 8, !tbaa !47 --->   store double %412, double* %413, align 8, !tbaa !47 via memory
DOALL:         store double %412, double* %413, align 8, !tbaa !47 --->   store double %408, double* %409, align 8, !tbaa !44 via memory
DOALL:         store double %412, double* %413, align 8, !tbaa !47 --->   store double %400, double* %401, align 8, !tbaa !44 via memory
DOALL:         store double %400, double* %401, align 8, !tbaa !44 --->   store double %402, double* %403, align 8, !tbaa !47 via memory
DOALL:         store double %402, double* %403, align 8, !tbaa !47 --->   store double %408, double* %409, align 8, !tbaa !44 via memory
DOALL:         store double %402, double* %403, align 8, !tbaa !47 --->   store double %402, double* %403, align 8, !tbaa !47 via memory
DOALL:         store double %408, double* %409, align 8, !tbaa !44 --->   store double %408, double* %409, align 8, !tbaa !44 via memory
DOALL:         store double %408, double* %409, align 8, !tbaa !44 --->   store double %400, double* %401, align 8, !tbaa !44 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %227, double* %228, align 8, !tbaa !44
DOALL:     	  store double %229, double* %230, align 8, !tbaa !47
DOALL:     	  store double %235, double* %236, align 8, !tbaa !44
DOALL:     	  store double %239, double* %240, align 8, !tbaa !47
DOALL:     External nodes: 9
DOALL:     	  br i1 %217, label %218, label %241, !prof !53
DOALL:     	  %227 = fadd double %220, %224
DOALL:     	  %228 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %69, i64 %214, i64 %indvars.iv12.i.i.i, i32 0
DOALL:     	  %229 = fadd double %222, %226
DOALL:     	  %230 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %69, i64 %214, i64 %indvars.iv12.i.i.i, i32 1
DOALL:     	  %235 = fsub double %232, %234
DOALL:     	  %236 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %69, i64 %215, i64 %indvars.iv12.i.i.i, i32 0
DOALL:     	  %239 = fadd double %237, %238
DOALL:     	  %240 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %69, i64 %215, i64 %indvars.iv12.i.i.i, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %227, double* %228, align 8, !tbaa !44 --->   store double %229, double* %230, align 8, !tbaa !47 via memory
DOALL:         store double %227, double* %228, align 8, !tbaa !44 --->   store double %227, double* %228, align 8, !tbaa !44 via memory
DOALL:         store double %227, double* %228, align 8, !tbaa !44 --->   store double %235, double* %236, align 8, !tbaa !44 via memory
DOALL:         store double %227, double* %228, align 8, !tbaa !44 --->   store double %239, double* %240, align 8, !tbaa !47 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !47 --->   store double %239, double* %240, align 8, !tbaa !47 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !47 --->   store double %235, double* %236, align 8, !tbaa !44 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !47 --->   store double %227, double* %228, align 8, !tbaa !44 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !47 --->   store double %229, double* %230, align 8, !tbaa !47 via memory
DOALL:         store double %235, double* %236, align 8, !tbaa !44 --->   store double %239, double* %240, align 8, !tbaa !47 via memory
DOALL:         store double %235, double* %236, align 8, !tbaa !44 --->   store double %235, double* %236, align 8, !tbaa !44 via memory
DOALL:         store double %235, double* %236, align 8, !tbaa !44 --->   store double %227, double* %228, align 8, !tbaa !44 via memory
DOALL:         store double %235, double* %236, align 8, !tbaa !44 --->   store double %229, double* %230, align 8, !tbaa !47 via memory
DOALL:         store double %239, double* %240, align 8, !tbaa !47 --->   store double %239, double* %240, align 8, !tbaa !47 via memory
DOALL:         store double %239, double* %240, align 8, !tbaa !47 --->   store double %235, double* %236, align 8, !tbaa !44 via memory
DOALL:         store double %239, double* %240, align 8, !tbaa !47 --->   store double %227, double* %228, align 8, !tbaa !44 via memory
DOALL:         store double %239, double* %240, align 8, !tbaa !47 --->   store double %229, double* %230, align 8, !tbaa !47 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %701, double* %702, align 8, !tbaa !44
DOALL:     	  store double %703, double* %704, align 8, !tbaa !47
DOALL:     	  store double %709, double* %710, align 8, !tbaa !44
DOALL:     	  store double %713, double* %714, align 8, !tbaa !47
DOALL:     External nodes: 9
DOALL:     	  br i1 %691, label %692, label %715, !prof !53
DOALL:     	  %701 = fadd double %694, %698
DOALL:     	  %702 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %543, i64 %688, i64 %indvars.iv12.i.i.i28, i32 0
DOALL:     	  %703 = fadd double %696, %700
DOALL:     	  %704 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %543, i64 %688, i64 %indvars.iv12.i.i.i28, i32 1
DOALL:     	  %709 = fsub double %706, %708
DOALL:     	  %710 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %543, i64 %689, i64 %indvars.iv12.i.i.i28, i32 0
DOALL:     	  %713 = fadd double %711, %712
DOALL:     	  %714 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %543, i64 %689, i64 %indvars.iv12.i.i.i28, i32 1
DOALL:     Edges: 28
DOALL:     Loop-carried data dependences
DOALL:         store double %701, double* %702, align 8, !tbaa !44 --->   store double %703, double* %704, align 8, !tbaa !47 via memory
DOALL:         store double %701, double* %702, align 8, !tbaa !44 --->   store double %701, double* %702, align 8, !tbaa !44 via memory
DOALL:         store double %701, double* %702, align 8, !tbaa !44 --->   store double %709, double* %710, align 8, !tbaa !44 via memory
DOALL:         store double %701, double* %702, align 8, !tbaa !44 --->   store double %713, double* %714, align 8, !tbaa !47 via memory
DOALL:         store double %703, double* %704, align 8, !tbaa !47 --->   store double %713, double* %714, align 8, !tbaa !47 via memory
DOALL:         store double %703, double* %704, align 8, !tbaa !47 --->   store double %709, double* %710, align 8, !tbaa !44 via memory
DOALL:         store double %703, double* %704, align 8, !tbaa !47 --->   store double %701, double* %702, align 8, !tbaa !44 via memory
DOALL:         store double %703, double* %704, align 8, !tbaa !47 --->   store double %703, double* %704, align 8, !tbaa !47 via memory
DOALL:         store double %709, double* %710, align 8, !tbaa !44 --->   store double %713, double* %714, align 8, !tbaa !47 via memory
DOALL:         store double %709, double* %710, align 8, !tbaa !44 --->   store double %709, double* %710, align 8, !tbaa !44 via memory
DOALL:         store double %709, double* %710, align 8, !tbaa !44 --->   store double %701, double* %702, align 8, !tbaa !44 via memory
DOALL:         store double %709, double* %710, align 8, !tbaa !44 --->   store double %703, double* %704, align 8, !tbaa !47 via memory
DOALL:         store double %713, double* %714, align 8, !tbaa !47 --->   store double %713, double* %714, align 8, !tbaa !47 via memory
DOALL:         store double %713, double* %714, align 8, !tbaa !47 --->   store double %709, double* %710, align 8, !tbaa !44 via memory
DOALL:         store double %713, double* %714, align 8, !tbaa !47 --->   store double %701, double* %702, align 8, !tbaa !44 via memory
DOALL:         store double %713, double* %714, align 8, !tbaa !47 --->   store double %703, double* %704, align 8, !tbaa !47 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %637, double* %638, align 8, !tbaa !44
DOALL:     	  store double %639, double* %640, align 8, !tbaa !47
DOALL:     	  store double %645, double* %646, align 8, !tbaa !44
DOALL:     	  store double %649, double* %650, align 8, !tbaa !47
DOALL:     External nodes: 9
DOALL:     	  br i1 %627, label %628, label %651, !prof !53
DOALL:     	  %637 = fadd double %630, %634
DOALL:     	  %638 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %544, i64 %624, i64 %indvars.iv12.i14.i.i18, i32 0
DOALL:     	  %639 = fadd double %632, %636
DOALL:     	  %640 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %544, i64 %624, i64 %indvars.iv12.i14.i.i18, i32 1
DOALL:     	  %645 = fsub double %642, %644
DOALL:     	  %646 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %544, i64 %625, i64 %indvars.iv12.i14.i.i18, i32 0
DOALL:     	  %649 = fadd double %647, %648
DOALL:     	  %650 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %544, i64 %625, i64 %indvars.iv12.i14.i.i18, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %637, double* %638, align 8, !tbaa !44 --->   store double %649, double* %650, align 8, !tbaa !47 via memory
DOALL:         store double %637, double* %638, align 8, !tbaa !44 --->   store double %645, double* %646, align 8, !tbaa !44 via memory
DOALL:         store double %639, double* %640, align 8, !tbaa !47 --->   store double %649, double* %650, align 8, !tbaa !47 via memory
DOALL:         store double %639, double* %640, align 8, !tbaa !47 --->   store double %645, double* %646, align 8, !tbaa !44 via memory
DOALL:         store double %645, double* %646, align 8, !tbaa !44 --->   store double %637, double* %638, align 8, !tbaa !44 via memory
DOALL:         store double %645, double* %646, align 8, !tbaa !44 --->   store double %639, double* %640, align 8, !tbaa !47 via memory
DOALL:         store double %649, double* %650, align 8, !tbaa !47 --->   store double %637, double* %638, align 8, !tbaa !44 via memory
DOALL:         store double %649, double* %650, align 8, !tbaa !47 --->   store double %639, double* %640, align 8, !tbaa !47 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %227, double* %228, align 8, !tbaa !44
DOALL:     	  store double %229, double* %230, align 8, !tbaa !47
DOALL:     	  store double %235, double* %236, align 8, !tbaa !44
DOALL:     	  store double %239, double* %240, align 8, !tbaa !47
DOALL:     External nodes: 9
DOALL:     	  br i1 %217, label %218, label %241, !prof !53
DOALL:     	  %227 = fadd double %220, %224
DOALL:     	  %228 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %69, i64 %214, i64 %indvars.iv12.i.i.i, i32 0
DOALL:     	  %229 = fadd double %222, %226
DOALL:     	  %230 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %69, i64 %214, i64 %indvars.iv12.i.i.i, i32 1
DOALL:     	  %235 = fsub double %232, %234
DOALL:     	  %236 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %69, i64 %215, i64 %indvars.iv12.i.i.i, i32 0
DOALL:     	  %239 = fadd double %237, %238
DOALL:     	  %240 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %69, i64 %215, i64 %indvars.iv12.i.i.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %227, double* %228, align 8, !tbaa !44 --->   store double %239, double* %240, align 8, !tbaa !47 via memory
DOALL:         store double %227, double* %228, align 8, !tbaa !44 --->   store double %235, double* %236, align 8, !tbaa !44 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !47 --->   store double %235, double* %236, align 8, !tbaa !44 via memory
DOALL:         store double %229, double* %230, align 8, !tbaa !47 --->   store double %239, double* %240, align 8, !tbaa !47 via memory
DOALL:         store double %235, double* %236, align 8, !tbaa !44 --->   store double %229, double* %230, align 8, !tbaa !47 via memory
DOALL:         store double %235, double* %236, align 8, !tbaa !44 --->   store double %227, double* %228, align 8, !tbaa !44 via memory
DOALL:         store double %239, double* %240, align 8, !tbaa !47 --->   store double %227, double* %228, align 8, !tbaa !44 via memory
DOALL:         store double %239, double* %240, align 8, !tbaa !47 --->   store double %229, double* %230, align 8, !tbaa !47 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %163, double* %164, align 8, !tbaa !44
DOALL:     	  store double %165, double* %166, align 8, !tbaa !47
DOALL:     	  store double %171, double* %172, align 8, !tbaa !44
DOALL:     	  store double %175, double* %176, align 8, !tbaa !47
DOALL:     External nodes: 9
DOALL:     	  br i1 %153, label %154, label %177, !prof !53
DOALL:     	  %163 = fadd double %156, %160
DOALL:     	  %164 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %70, i64 %150, i64 %indvars.iv12.i14.i.i, i32 0
DOALL:     	  %165 = fadd double %158, %162
DOALL:     	  %166 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %70, i64 %150, i64 %indvars.iv12.i14.i.i, i32 1
DOALL:     	  %171 = fsub double %168, %170
DOALL:     	  %172 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %70, i64 %151, i64 %indvars.iv12.i14.i.i, i32 0
DOALL:     	  %175 = fadd double %173, %174
DOALL:     	  %176 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %70, i64 %151, i64 %indvars.iv12.i14.i.i, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %163, double* %164, align 8, !tbaa !44 --->   store double %175, double* %176, align 8, !tbaa !47 via memory
DOALL:         store double %163, double* %164, align 8, !tbaa !44 --->   store double %171, double* %172, align 8, !tbaa !44 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !47 --->   store double %171, double* %172, align 8, !tbaa !44 via memory
DOALL:         store double %165, double* %166, align 8, !tbaa !47 --->   store double %175, double* %176, align 8, !tbaa !47 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !44 --->   store double %163, double* %164, align 8, !tbaa !44 via memory
DOALL:         store double %171, double* %172, align 8, !tbaa !44 --->   store double %165, double* %166, align 8, !tbaa !47 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !47 --->   store double %163, double* %164, align 8, !tbaa !44 via memory
DOALL:         store double %175, double* %176, align 8, !tbaa !47 --->   store double %165, double* %166, align 8, !tbaa !47 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %400, double* %401, align 8, !tbaa !44
DOALL:     	  store double %402, double* %403, align 8, !tbaa !47
DOALL:     	  store double %408, double* %409, align 8, !tbaa !44
DOALL:     	  store double %412, double* %413, align 8, !tbaa !47
DOALL:     External nodes: 9
DOALL:     	  br i1 %390, label %391, label %414, !prof !53
DOALL:     	  %400 = fadd double %393, %397
DOALL:     	  %401 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %307, i64 %387, i64 %indvars.iv12.i14.i.i23, i32 0
DOALL:     	  %402 = fadd double %395, %399
DOALL:     	  %403 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %307, i64 %387, i64 %indvars.iv12.i14.i.i23, i32 1
DOALL:     	  %408 = fsub double %405, %407
DOALL:     	  %409 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %307, i64 %388, i64 %indvars.iv12.i14.i.i23, i32 0
DOALL:     	  %412 = fadd double %410, %411
DOALL:     	  %413 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %307, i64 %388, i64 %indvars.iv12.i14.i.i23, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %408, double* %409, align 8, !tbaa !44 --->   store double %400, double* %401, align 8, !tbaa !44 via memory
DOALL:         store double %408, double* %409, align 8, !tbaa !44 --->   store double %402, double* %403, align 8, !tbaa !47 via memory
DOALL:         store double %412, double* %413, align 8, !tbaa !47 --->   store double %402, double* %403, align 8, !tbaa !47 via memory
DOALL:         store double %412, double* %413, align 8, !tbaa !47 --->   store double %400, double* %401, align 8, !tbaa !44 via memory
DOALL:         store double %400, double* %401, align 8, !tbaa !44 --->   store double %412, double* %413, align 8, !tbaa !47 via memory
DOALL:         store double %400, double* %401, align 8, !tbaa !44 --->   store double %408, double* %409, align 8, !tbaa !44 via memory
DOALL:         store double %402, double* %403, align 8, !tbaa !47 --->   store double %408, double* %409, align 8, !tbaa !44 via memory
DOALL:         store double %402, double* %403, align 8, !tbaa !47 --->   store double %412, double* %413, align 8, !tbaa !47 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %701, double* %702, align 8, !tbaa !44
DOALL:     	  store double %703, double* %704, align 8, !tbaa !47
DOALL:     	  store double %709, double* %710, align 8, !tbaa !44
DOALL:     	  store double %713, double* %714, align 8, !tbaa !47
DOALL:     External nodes: 9
DOALL:     	  br i1 %691, label %692, label %715, !prof !53
DOALL:     	  %701 = fadd double %694, %698
DOALL:     	  %702 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %543, i64 %688, i64 %indvars.iv12.i.i.i28, i32 0
DOALL:     	  %703 = fadd double %696, %700
DOALL:     	  %704 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %543, i64 %688, i64 %indvars.iv12.i.i.i28, i32 1
DOALL:     	  %709 = fsub double %706, %708
DOALL:     	  %710 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %543, i64 %689, i64 %indvars.iv12.i.i.i28, i32 0
DOALL:     	  %713 = fadd double %711, %712
DOALL:     	  %714 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %543, i64 %689, i64 %indvars.iv12.i.i.i28, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %701, double* %702, align 8, !tbaa !44 --->   store double %713, double* %714, align 8, !tbaa !47 via memory
DOALL:         store double %701, double* %702, align 8, !tbaa !44 --->   store double %709, double* %710, align 8, !tbaa !44 via memory
DOALL:         store double %703, double* %704, align 8, !tbaa !47 --->   store double %713, double* %714, align 8, !tbaa !47 via memory
DOALL:         store double %703, double* %704, align 8, !tbaa !47 --->   store double %709, double* %710, align 8, !tbaa !44 via memory
DOALL:         store double %709, double* %710, align 8, !tbaa !44 --->   store double %701, double* %702, align 8, !tbaa !44 via memory
DOALL:         store double %709, double* %710, align 8, !tbaa !44 --->   store double %703, double* %704, align 8, !tbaa !47 via memory
DOALL:         store double %713, double* %714, align 8, !tbaa !47 --->   store double %701, double* %702, align 8, !tbaa !44 via memory
DOALL:         store double %713, double* %714, align 8, !tbaa !47 --->   store double %703, double* %704, align 8, !tbaa !47 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 4
DOALL:     	  store double %464, double* %465, align 8, !tbaa !44
DOALL:     	  store double %466, double* %467, align 8, !tbaa !47
DOALL:     	  store double %472, double* %473, align 8, !tbaa !44
DOALL:     	  store double %476, double* %477, align 8, !tbaa !47
DOALL:     External nodes: 9
DOALL:     	  br i1 %454, label %455, label %478, !prof !53
DOALL:     	  %464 = fadd double %457, %461
DOALL:     	  %465 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %306, i64 %451, i64 %indvars.iv12.i.i.i33, i32 0
DOALL:     	  %466 = fadd double %459, %463
DOALL:     	  %467 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %306, i64 %451, i64 %indvars.iv12.i.i.i33, i32 1
DOALL:     	  %472 = fsub double %469, %471
DOALL:     	  %473 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %306, i64 %452, i64 %indvars.iv12.i.i.i33, i32 0
DOALL:     	  %476 = fadd double %474, %475
DOALL:     	  %477 = getelementptr inbounds [18 x %struct.dcomplex], [18 x %struct.dcomplex]* %306, i64 %452, i64 %indvars.iv12.i.i.i33, i32 1
DOALL:     Edges: 24
DOALL:     Loop-carried data dependences
DOALL:         store double %464, double* %465, align 8, !tbaa !44 --->   store double %476, double* %477, align 8, !tbaa !47 via memory
DOALL:         store double %464, double* %465, align 8, !tbaa !44 --->   store double %472, double* %473, align 8, !tbaa !44 via memory
DOALL:         store double %466, double* %467, align 8, !tbaa !47 --->   store double %476, double* %477, align 8, !tbaa !47 via memory
DOALL:         store double %466, double* %467, align 8, !tbaa !47 --->   store double %472, double* %473, align 8, !tbaa !44 via memory
DOALL:         store double %472, double* %473, align 8, !tbaa !44 --->   store double %464, double* %465, align 8, !tbaa !44 via memory
DOALL:         store double %472, double* %473, align 8, !tbaa !44 --->   store double %466, double* %467, align 8, !tbaa !47 via memory
DOALL:         store double %476, double* %477, align 8, !tbaa !47 --->   store double %464, double* %465, align 8, !tbaa !44 via memory
DOALL:         store double %476, double* %477, align 8, !tbaa !47 --->   store double %466, double* %467, align 8, !tbaa !47 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The loop can be parallelized with DOALL
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
Inliner:   No remaining calls need to be inlined due to loop-carried data dependences
Inliner:   The code has not been modified
Inliner: Exit
Noelle:  Function "main"
Noelle:     Loop "  %exitcond8 = icmp eq i32 %.02, 7" (4.860234e-09%)
Noelle:     Loop "  %exitcond = icmp eq i32 %.1, 7" (4.860234e-09%)
Noelle:     Loop "  %.b4 = load i1, i1* @niter, align 4" (2.687837e+01%)
Noelle:     Loop "  %exitcond.i = icmp eq i64 %indvars.iv15.i, 3" (3.134488e-07%)
Noelle:     Loop "  %72 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 1" (1.006017e+01%)
Noelle:     Loop "  %79 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 0" (1.006016e+01%)
Noelle:     Loop "  %89 = icmp slt i64 %indvars.iv7.i, %87" (1.000850e+00%)
Noelle:     Loop "  %91 = icmp slt i64 %indvars.iv.i, %86" (9.825626e-01%)
Noelle:     Loop "  %115 = icmp sgt i32 %.0.i.i, %68" (7.813465e+00%)
Noelle:     Loop "  %133 = icmp slt i64 %indvars.iv16.i11.i.i, %130" (4.000903e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv14.i13.i.i, %129" (3.970936e+00%)
Noelle:     Loop "  %153 = icmp slt i64 %indvars.iv12.i14.i.i, %128" (3.887440e+00%)
Noelle:     Loop "  %197 = icmp slt i64 %indvars.iv16.i.i.i, %194" (3.810384e+00%)
Noelle:     Loop "  %210 = icmp slt i64 %indvars.iv14.i.i.i, %193" (3.781844e+00%)
Noelle:     Loop "  %217 = icmp slt i64 %indvars.iv12.i.i.i, %192" (3.702324e+00%)
Noelle:     Loop "  %251 = icmp slt i64 %indvars.iv5.i.i, %249" (3.419268e-01%)
Noelle:     Loop "  %253 = icmp slt i64 %indvars.iv.i.i, %248" (3.346189e-01%)
Noelle:     Loop "  %273 = icmp slt i64 %indvars.iv11.i, %271" (9.035065e-01%)
Noelle:     Loop "  %275 = icmp slt i64 %indvars.iv9.i, %269" (8.852190e-01%)
Noelle:     Loop "  %exitcond.i2 = icmp eq i64 %indvars.iv15.i1, 3" (3.134488e-07%)
Noelle:     Loop "  %309 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 2" (1.006013e+01%)
Noelle:     Loop "  %316 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 0" (1.006013e+01%)
Noelle:     Loop "  %326 = icmp slt i64 %indvars.iv7.i7, %324" (1.000846e+00%)
Noelle:     Loop "  %328 = icmp slt i64 %indvars.iv.i9, %323" (9.825589e-01%)
Noelle:     Loop "  %352 = icmp sgt i32 %.0.i.i15, %305" (7.813435e+00%)
Noelle:     Loop "  %370 = icmp slt i64 %indvars.iv16.i11.i.i20, %367" (4.000888e+00%)
Noelle:     Loop "  %383 = icmp slt i64 %indvars.iv14.i13.i.i22, %366" (3.970921e+00%)
Noelle:     Loop "  %390 = icmp slt i64 %indvars.iv12.i14.i.i23, %365" (3.887425e+00%)
Noelle:     Loop "  %434 = icmp slt i64 %indvars.iv16.i.i.i30, %431" (3.810370e+00%)
Noelle:     Loop "  %447 = icmp slt i64 %indvars.iv14.i.i.i32, %430" (3.781829e+00%)
Noelle:     Loop "  %454 = icmp slt i64 %indvars.iv12.i.i.i33, %429" (3.702310e+00%)
Noelle:     Loop "  %488 = icmp slt i64 %indvars.iv5.i.i40, %486" (3.419255e-01%)
Noelle:     Loop "  %490 = icmp slt i64 %indvars.iv.i.i42, %485" (3.346176e-01%)
Noelle:     Loop "  %510 = icmp slt i64 %indvars.iv11.i47, %508" (9.035031e-01%)
Noelle:     Loop "  %512 = icmp slt i64 %indvars.iv9.i49, %506" (8.852156e-01%)
Noelle:     Loop "  %exitcond.i1 = icmp eq i64 %indvars.iv14.i, 3" (3.134488e-07%)
Noelle:     Loop "  %546 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (5.734845e+00%)
Noelle:     Loop "  %553 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 1" (5.734842e+00%)
Noelle:     Loop "  %562 = icmp slt i64 %indvars.iv6.i, %560" (8.285750e-01%)
Noelle:     Loop "  %568 = icmp slt i64 %indvars.iv.i5, %559" (8.277016e-01%)
Noelle:     Loop "  %589 = icmp sgt i32 %.0.i.i10, %542" (3.906710e+00%)
Noelle:     Loop "  %607 = icmp slt i64 %indvars.iv16.i11.i.i15, %604" (2.000440e+00%)
Noelle:     Loop "  %620 = icmp slt i64 %indvars.iv14.i13.i.i17, %603" (1.985457e+00%)
Noelle:     Loop "  %627 = icmp slt i64 %indvars.iv12.i14.i.i18, %602" (1.943709e+00%)
Noelle:     Loop "  %671 = icmp slt i64 %indvars.iv16.i.i.i25, %668" (1.905181e+00%)
Noelle:     Loop "  %684 = icmp slt i64 %indvars.iv14.i.i.i27, %667" (1.890911e+00%)
Noelle:     Loop "  %691 = icmp slt i64 %indvars.iv12.i.i.i28, %666" (1.851151e+00%)
Noelle:     Loop "  %725 = icmp slt i64 %indvars.iv5.i.i35, %723" (1.709624e-01%)
Noelle:     Loop "  %727 = icmp slt i64 %indvars.iv.i.i37, %722" (1.673085e-01%)
Noelle:     Loop "  %747 = icmp slt i64 %indvars.iv10.i, %741" (8.283849e-01%)
Noelle:     Loop "  %751 = icmp slt i64 %indvars.iv8.i, %745" (8.277016e-01%)
Noelle:  Function "fft"
Noelle:  Function "cfftz"
Noelle:     Loop "  %12 = icmp sgt i32 %.0, %1" (2.149137e+01%)
Noelle:     Loop "  %77 = icmp slt i64 %indvars.iv16.i11, %29" (1.000421e+01%)
Noelle:     Loop "  %90 = icmp slt i64 %indvars.iv14.i13, %28" (9.929271e+00%)
Noelle:     Loop "  %97 = icmp slt i64 %indvars.iv12.i14, %27" (9.720492e+00%)
Noelle:     Loop "  %32 = icmp slt i64 %indvars.iv10.i4, %29" (9.999545e-01%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv8.i6, %28" (9.929271e-01%)
Noelle:     Loop "  %52 = icmp slt i64 %indvars.iv.i8, %27" (9.720492e-01%)
Noelle:     Loop "  %188 = icmp slt i64 %indvars.iv16.i, %140" (9.527815e+00%)
Noelle:     Loop "  %201 = icmp slt i64 %indvars.iv14.i, %139" (9.456449e+00%)
Noelle:     Loop "  %208 = icmp slt i64 %indvars.iv12.i, %138" (9.257611e+00%)
Noelle:     Loop "  %143 = icmp slt i64 %indvars.iv10.i, %140" (9.523376e-01%)
Noelle:     Loop "  %155 = icmp slt i64 %indvars.iv8.i, %139" (9.456449e-01%)
Noelle:     Loop "  %163 = icmp slt i64 %indvars.iv.i, %138" (9.257611e-01%)
Noelle:     Loop "  %242 = icmp slt i64 %indvars.iv5, %240" (9.404816e-01%)
Noelle:     Loop "  %244 = icmp slt i64 %indvars.iv, %239" (9.203810e-01%)
Noelle:  Function "fftz2"
Noelle:     Loop "  %70 = icmp slt i64 %indvars.iv16, %22" (1.953191e+01%)
Noelle:     Loop "  %83 = icmp slt i64 %indvars.iv14, %21" (1.938562e+01%)
Noelle:     Loop "  %90 = icmp slt i64 %indvars.iv12, %20" (1.897802e+01%)
Noelle:     Loop "  %25 = icmp slt i64 %indvars.iv10, %22" (1.952193e+00%)
Noelle:     Loop "  %37 = icmp slt i64 %indvars.iv8, %21" (1.938507e+00%)
Noelle:     Loop "  %45 = icmp slt i64 %indvars.iv, %20" (1.897766e+00%)
Noelle:  Function "cffts3"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (1.338142e+09%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 1" (1.106828e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 0" (1.106827e+01%)
Noelle:     Loop "  %42 = icmp slt i64 %indvars.iv7, %40" (1.101141e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv, %39" (1.081021e+00%)
Noelle:     Loop "  %69 = icmp sgt i32 %.0.i, %21" (8.596375e+00%)
Noelle:     Loop "  %133 = icmp slt i64 %indvars.iv16.i11.i, %85" (4.001651e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv14.i13.i, %84" (3.971678e+00%)
Noelle:     Loop "  %153 = icmp slt i64 %indvars.iv12.i14.i, %83" (3.888167e+00%)
Noelle:     Loop "  %88 = icmp slt i64 %indvars.iv10.i4.i, %85" (3.999787e-01%)
Noelle:     Loop "  %100 = icmp slt i64 %indvars.iv8.i6.i, %84" (3.971678e-01%)
Noelle:     Loop "  %108 = icmp slt i64 %indvars.iv.i8.i, %83" (3.888167e-01%)
Noelle:     Loop "  %243 = icmp slt i64 %indvars.iv16.i.i, %195" (3.811096e+00%)
Noelle:     Loop "  %256 = icmp slt i64 %indvars.iv14.i.i, %194" (3.782550e+00%)
Noelle:     Loop "  %263 = icmp slt i64 %indvars.iv12.i.i, %193" (3.703016e+00%)
Noelle:     Loop "  %198 = icmp slt i64 %indvars.iv10.i.i, %195" (3.809321e-01%)
Noelle:     Loop "  %210 = icmp slt i64 %indvars.iv8.i.i, %194" (3.782550e-01%)
Noelle:     Loop "  %218 = icmp slt i64 %indvars.iv.i.i, %193" (3.703016e-01%)
Noelle:     Loop "  %297 = icmp slt i64 %indvars.iv5.i, %295" (3.761898e-01%)
Noelle:     Loop "  %299 = icmp slt i64 %indvars.iv.i, %294" (3.681496e-01%)
Noelle:     Loop "  %319 = icmp slt i64 %indvars.iv11, %317" (9.940430e-01%)
Noelle:     Loop "  %321 = icmp slt i64 %indvars.iv9, %315" (9.739229e-01%)
Noelle:  Function "cffts2"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (3.447864e-07%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 2" (1.106828e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 0" (1.106827e+01%)
Noelle:     Loop "  %42 = icmp slt i64 %indvars.iv7, %40" (1.101141e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv, %39" (1.081021e+00%)
Noelle:     Loop "  %69 = icmp sgt i32 %.0.i, %21" (8.596375e+00%)
Noelle:     Loop "  %133 = icmp slt i64 %indvars.iv16.i11.i, %85" (4.001651e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv14.i13.i, %84" (3.971678e+00%)
Noelle:     Loop "  %153 = icmp slt i64 %indvars.iv12.i14.i, %83" (3.888167e+00%)
Noelle:     Loop "  %88 = icmp slt i64 %indvars.iv10.i4.i, %85" (3.999787e-01%)
Noelle:     Loop "  %100 = icmp slt i64 %indvars.iv8.i6.i, %84" (3.971678e-01%)
Noelle:     Loop "  %108 = icmp slt i64 %indvars.iv.i8.i, %83" (3.888167e-01%)
Noelle:     Loop "  %243 = icmp slt i64 %indvars.iv16.i.i, %195" (3.811096e+00%)
Noelle:     Loop "  %256 = icmp slt i64 %indvars.iv14.i.i, %194" (3.782550e+00%)
Noelle:     Loop "  %263 = icmp slt i64 %indvars.iv12.i.i, %193" (3.703016e+00%)
Noelle:     Loop "  %198 = icmp slt i64 %indvars.iv10.i.i, %195" (3.809321e-01%)
Noelle:     Loop "  %210 = icmp slt i64 %indvars.iv8.i.i, %194" (3.782550e-01%)
Noelle:     Loop "  %218 = icmp slt i64 %indvars.iv.i.i, %193" (3.703016e-01%)
Noelle:     Loop "  %297 = icmp slt i64 %indvars.iv5.i, %295" (3.761898e-01%)
Noelle:     Loop "  %299 = icmp slt i64 %indvars.iv.i, %294" (3.681496e-01%)
Noelle:     Loop "  %319 = icmp slt i64 %indvars.iv11, %317" (9.940430e-01%)
Noelle:     Loop "  %321 = icmp slt i64 %indvars.iv9, %315" (9.739229e-01%)
Noelle:  Function "cffts1"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv14, 3" (3.447864e-07%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (6.309581e+00%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 1" (6.309577e+00%)
Noelle:     Loop "  %41 = icmp slt i64 %indvars.iv6, %39" (9.116116e-01%)
Noelle:     Loop "  %47 = icmp slt i64 %indvars.iv, %38" (9.106507e-01%)
Noelle:     Loop "  %69 = icmp sgt i32 %.0.i, %21" (4.298204e+00%)
Noelle:     Loop "  %133 = icmp slt i64 %indvars.iv16.i11.i, %85" (2.000833e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv14.i13.i, %84" (1.985847e+00%)
Noelle:     Loop "  %153 = icmp slt i64 %indvars.iv12.i14.i, %83" (1.944091e+00%)
Noelle:     Loop "  %88 = icmp slt i64 %indvars.iv10.i4.i, %85" (1.999901e-01%)
Noelle:     Loop "  %100 = icmp slt i64 %indvars.iv8.i6.i, %84" (1.985847e-01%)
Noelle:     Loop "  %108 = icmp slt i64 %indvars.iv.i8.i, %83" (1.944091e-01%)
Noelle:     Loop "  %243 = icmp slt i64 %indvars.iv16.i.i, %195" (1.905556e+00%)
Noelle:     Loop "  %256 = icmp slt i64 %indvars.iv14.i.i, %194" (1.891282e+00%)
Noelle:     Loop "  %263 = icmp slt i64 %indvars.iv12.i.i, %193" (1.851515e+00%)
Noelle:     Loop "  %198 = icmp slt i64 %indvars.iv10.i.i, %195" (1.904668e-01%)
Noelle:     Loop "  %210 = icmp slt i64 %indvars.iv8.i.i, %194" (1.891282e-01%)
Noelle:     Loop "  %218 = icmp slt i64 %indvars.iv.i.i, %193" (1.851515e-01%)
Noelle:     Loop "  %297 = icmp slt i64 %indvars.iv5.i, %295" (1.880956e-01%)
Noelle:     Loop "  %299 = icmp slt i64 %indvars.iv.i, %294" (1.840755e-01%)
Noelle:     Loop "  %319 = icmp slt i64 %indvars.iv10, %313" (9.114024e-01%)
Noelle:     Loop "  %323 = icmp slt i64 %indvars.iv8, %317" (9.106507e-01%)
Noelle:  Function "evolve"
Noelle:     Loop "  %16 = icmp slt i64 %indvars.iv5, %8" (1.023166e+00%)
Noelle:     Loop "  %18 = icmp slt i64 %indvars.iv3, %11" (1.023164e+00%)
Noelle:     Loop "  %20 = icmp slt i64 %indvars.iv, %14" (1.022593e+00%)
Noelle:  Function "compute_initial_conditions"
Noelle:     Loop "  %23 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (3.895849e-01%)
Noelle:     Loop "  %36 = icmp sgt i64 %indvars.iv.i, %34" (2.920869e-01%)
Noelle:     Loop "  %65 = icmp slt i64 %indvars.iv6, %63" (9.749587e-02%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 512" (9.740064e-02%)
Noelle:  Function "vranlc"
Noelle:     Loop "  %13 = icmp sgt i64 %indvars.iv, %11" (2.920867e-01%)
Noelle:  Function "compute_indexmap"
Noelle:     Loop "  %15 = icmp slt i64 %indvars.iv10, %4" (6.845920e-02%)
Noelle:     Loop "  %23 = icmp slt i64 %indvars.iv8, %8" (6.845830e-02%)
Noelle:     Loop "  %33 = icmp slt i64 %indvars.iv6, %12" (6.821087e-02%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 1966081" (3.138427e-03%)
Noelle:  Function "checksum"
Noelle:     Loop "  %exitcond = icmp eq i32 %.0, 1025" (6.240395e-05%)
Noelle:  Function "randlc"
Noelle:  Function "fft_init"
Noelle:     Loop "  %7 = icmp sgt i32 %.01, %2" (1.134973e-06%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count" (1.115968e-06%)
Noelle:  Function "ilog2"
Noelle:     Loop "  %3 = icmp slt i32 %.01, %0" (8.034619e-07%)
Noelle:  Function "ipow46"
Noelle:     Loop "  %11 = icmp sgt i32 %.01, 1" (1.075780e-07%)
Noelle:  Function "verify"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 21" (3.358639e-08%)
Noelle:  Function "setup"
Noelle:     Loop "  %exitcond3 = icmp eq i64 %indvars.iv1, 3" (2.611469e-09%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 3" (3.917203e-09%)
Noelle:  Function "elapsed_time"
Noelle:  Function "timer_clear"
Noelle:  Function "c_print_results"
Noelle:  Function "wtime_"
Noelle:  Function "timer_stop"
Noelle:  Function "timer_start"
Noelle:  Function "timer_read"
Noelle:  Function "main"
Noelle:     Loop "  %exitcond8 = icmp eq i32 %.02, 7" (4.860234e-09%)
Noelle:     Loop "  %exitcond = icmp eq i32 %.1, 7" (4.860234e-09%)
Noelle:     Loop "  %.b4 = load i1, i1* @niter, align 4" (2.687837e+01%)
Noelle:     Loop "  %exitcond.i = icmp eq i64 %indvars.iv15.i, 3" (3.134488e-07%)
Noelle:     Loop "  %72 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 1" (1.006017e+01%)
Noelle:     Loop "  %79 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 0" (1.006016e+01%)
Noelle:     Loop "  %89 = icmp slt i64 %indvars.iv7.i, %87" (1.000850e+00%)
Noelle:     Loop "  %91 = icmp slt i64 %indvars.iv.i, %86" (9.825626e-01%)
Noelle:     Loop "  %115 = icmp sgt i32 %.0.i.i, %68" (7.813465e+00%)
Noelle:     Loop "  %133 = icmp slt i64 %indvars.iv16.i11.i.i, %130" (4.000903e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv14.i13.i.i, %129" (3.970936e+00%)
Noelle:     Loop "  %153 = icmp slt i64 %indvars.iv12.i14.i.i, %128" (3.887440e+00%)
Noelle:     Loop "  %197 = icmp slt i64 %indvars.iv16.i.i.i, %194" (3.810384e+00%)
Noelle:     Loop "  %210 = icmp slt i64 %indvars.iv14.i.i.i, %193" (3.781844e+00%)
Noelle:     Loop "  %217 = icmp slt i64 %indvars.iv12.i.i.i, %192" (3.702324e+00%)
Noelle:     Loop "  %251 = icmp slt i64 %indvars.iv5.i.i, %249" (3.419268e-01%)
Noelle:     Loop "  %253 = icmp slt i64 %indvars.iv.i.i, %248" (3.346189e-01%)
Noelle:     Loop "  %273 = icmp slt i64 %indvars.iv11.i, %271" (9.035065e-01%)
Noelle:     Loop "  %275 = icmp slt i64 %indvars.iv9.i, %269" (8.852190e-01%)
Noelle:     Loop "  %exitcond.i2 = icmp eq i64 %indvars.iv15.i1, 3" (3.134488e-07%)
Noelle:     Loop "  %309 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 2" (1.006013e+01%)
Noelle:     Loop "  %316 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 0" (1.006013e+01%)
Noelle:     Loop "  %326 = icmp slt i64 %indvars.iv7.i7, %324" (1.000846e+00%)
Noelle:     Loop "  %328 = icmp slt i64 %indvars.iv.i9, %323" (9.825589e-01%)
Noelle:     Loop "  %352 = icmp sgt i32 %.0.i.i15, %305" (7.813435e+00%)
Noelle:     Loop "  %370 = icmp slt i64 %indvars.iv16.i11.i.i20, %367" (4.000888e+00%)
Noelle:     Loop "  %383 = icmp slt i64 %indvars.iv14.i13.i.i22, %366" (3.970921e+00%)
Noelle:     Loop "  %390 = icmp slt i64 %indvars.iv12.i14.i.i23, %365" (3.887425e+00%)
Noelle:     Loop "  %434 = icmp slt i64 %indvars.iv16.i.i.i30, %431" (3.810370e+00%)
Noelle:     Loop "  %447 = icmp slt i64 %indvars.iv14.i.i.i32, %430" (3.781829e+00%)
Noelle:     Loop "  %454 = icmp slt i64 %indvars.iv12.i.i.i33, %429" (3.702310e+00%)
Noelle:     Loop "  %488 = icmp slt i64 %indvars.iv5.i.i40, %486" (3.419255e-01%)
Noelle:     Loop "  %490 = icmp slt i64 %indvars.iv.i.i42, %485" (3.346176e-01%)
Noelle:     Loop "  %510 = icmp slt i64 %indvars.iv11.i47, %508" (9.035031e-01%)
Noelle:     Loop "  %512 = icmp slt i64 %indvars.iv9.i49, %506" (8.852156e-01%)
Noelle:     Loop "  %exitcond.i1 = icmp eq i64 %indvars.iv14.i, 3" (3.134488e-07%)
Noelle:     Loop "  %546 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (5.734845e+00%)
Noelle:     Loop "  %553 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 1" (5.734842e+00%)
Noelle:     Loop "  %562 = icmp slt i64 %indvars.iv6.i, %560" (8.285750e-01%)
Noelle:     Loop "  %568 = icmp slt i64 %indvars.iv.i5, %559" (8.277016e-01%)
Noelle:     Loop "  %589 = icmp sgt i32 %.0.i.i10, %542" (3.906710e+00%)
Noelle:     Loop "  %607 = icmp slt i64 %indvars.iv16.i11.i.i15, %604" (2.000440e+00%)
Noelle:     Loop "  %620 = icmp slt i64 %indvars.iv14.i13.i.i17, %603" (1.985457e+00%)
Noelle:     Loop "  %627 = icmp slt i64 %indvars.iv12.i14.i.i18, %602" (1.943709e+00%)
Noelle:     Loop "  %671 = icmp slt i64 %indvars.iv16.i.i.i25, %668" (1.905181e+00%)
Noelle:     Loop "  %684 = icmp slt i64 %indvars.iv14.i.i.i27, %667" (1.890911e+00%)
Noelle:     Loop "  %691 = icmp slt i64 %indvars.iv12.i.i.i28, %666" (1.851151e+00%)
Noelle:     Loop "  %725 = icmp slt i64 %indvars.iv5.i.i35, %723" (1.709624e-01%)
Noelle:     Loop "  %727 = icmp slt i64 %indvars.iv.i.i37, %722" (1.673085e-01%)
Noelle:     Loop "  %747 = icmp slt i64 %indvars.iv10.i, %741" (8.283849e-01%)
Noelle:     Loop "  %751 = icmp slt i64 %indvars.iv8.i, %745" (8.277016e-01%)
Noelle:  Function "fft"
Noelle:  Function "cfftz"
Noelle:     Loop "  %12 = icmp sgt i32 %.0, %1" (2.149137e+01%)
Noelle:     Loop "  %77 = icmp slt i64 %indvars.iv16.i11, %29" (1.000421e+01%)
Noelle:     Loop "  %90 = icmp slt i64 %indvars.iv14.i13, %28" (9.929271e+00%)
Noelle:     Loop "  %97 = icmp slt i64 %indvars.iv12.i14, %27" (9.720492e+00%)
Noelle:     Loop "  %32 = icmp slt i64 %indvars.iv10.i4, %29" (9.999545e-01%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv8.i6, %28" (9.929271e-01%)
Noelle:     Loop "  %52 = icmp slt i64 %indvars.iv.i8, %27" (9.720492e-01%)
Noelle:     Loop "  %188 = icmp slt i64 %indvars.iv16.i, %140" (9.527815e+00%)
Noelle:     Loop "  %201 = icmp slt i64 %indvars.iv14.i, %139" (9.456449e+00%)
Noelle:     Loop "  %208 = icmp slt i64 %indvars.iv12.i, %138" (9.257611e+00%)
Noelle:     Loop "  %143 = icmp slt i64 %indvars.iv10.i, %140" (9.523376e-01%)
Noelle:     Loop "  %155 = icmp slt i64 %indvars.iv8.i, %139" (9.456449e-01%)
Noelle:     Loop "  %163 = icmp slt i64 %indvars.iv.i, %138" (9.257611e-01%)
Noelle:     Loop "  %242 = icmp slt i64 %indvars.iv5, %240" (9.404816e-01%)
Noelle:     Loop "  %244 = icmp slt i64 %indvars.iv, %239" (9.203810e-01%)
Noelle:  Function "fftz2"
Noelle:     Loop "  %70 = icmp slt i64 %indvars.iv16, %22" (1.953191e+01%)
Noelle:     Loop "  %83 = icmp slt i64 %indvars.iv14, %21" (1.938562e+01%)
Noelle:     Loop "  %90 = icmp slt i64 %indvars.iv12, %20" (1.897802e+01%)
Noelle:     Loop "  %25 = icmp slt i64 %indvars.iv10, %22" (1.952193e+00%)
Noelle:     Loop "  %37 = icmp slt i64 %indvars.iv8, %21" (1.938507e+00%)
Noelle:     Loop "  %45 = icmp slt i64 %indvars.iv, %20" (1.897766e+00%)
Noelle:  Function "cffts3"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (1.338142e+09%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 1" (1.106828e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 0" (1.106827e+01%)
Noelle:     Loop "  %42 = icmp slt i64 %indvars.iv7, %40" (1.101141e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv, %39" (1.081021e+00%)
Noelle:     Loop "  %69 = icmp sgt i32 %.0.i, %21" (8.596375e+00%)
Noelle:     Loop "  %133 = icmp slt i64 %indvars.iv16.i11.i, %85" (4.001651e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv14.i13.i, %84" (3.971678e+00%)
Noelle:     Loop "  %153 = icmp slt i64 %indvars.iv12.i14.i, %83" (3.888167e+00%)
Noelle:     Loop "  %88 = icmp slt i64 %indvars.iv10.i4.i, %85" (3.999787e-01%)
Noelle:     Loop "  %100 = icmp slt i64 %indvars.iv8.i6.i, %84" (3.971678e-01%)
Noelle:     Loop "  %108 = icmp slt i64 %indvars.iv.i8.i, %83" (3.888167e-01%)
Noelle:     Loop "  %243 = icmp slt i64 %indvars.iv16.i.i, %195" (3.811096e+00%)
Noelle:     Loop "  %256 = icmp slt i64 %indvars.iv14.i.i, %194" (3.782550e+00%)
Noelle:     Loop "  %263 = icmp slt i64 %indvars.iv12.i.i, %193" (3.703016e+00%)
Noelle:     Loop "  %198 = icmp slt i64 %indvars.iv10.i.i, %195" (3.809321e-01%)
Noelle:     Loop "  %210 = icmp slt i64 %indvars.iv8.i.i, %194" (3.782550e-01%)
Noelle:     Loop "  %218 = icmp slt i64 %indvars.iv.i.i, %193" (3.703016e-01%)
Noelle:     Loop "  %297 = icmp slt i64 %indvars.iv5.i, %295" (3.761898e-01%)
Noelle:     Loop "  %299 = icmp slt i64 %indvars.iv.i, %294" (3.681496e-01%)
Noelle:     Loop "  %319 = icmp slt i64 %indvars.iv11, %317" (9.940430e-01%)
Noelle:     Loop "  %321 = icmp slt i64 %indvars.iv9, %315" (9.739229e-01%)
Noelle:  Function "cffts2"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (3.447864e-07%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 2" (1.106828e+01%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 0" (1.106827e+01%)
Noelle:     Loop "  %42 = icmp slt i64 %indvars.iv7, %40" (1.101141e+00%)
Noelle:     Loop "  %44 = icmp slt i64 %indvars.iv, %39" (1.081021e+00%)
Noelle:     Loop "  %69 = icmp sgt i32 %.0.i, %21" (8.596375e+00%)
Noelle:     Loop "  %133 = icmp slt i64 %indvars.iv16.i11.i, %85" (4.001651e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv14.i13.i, %84" (3.971678e+00%)
Noelle:     Loop "  %153 = icmp slt i64 %indvars.iv12.i14.i, %83" (3.888167e+00%)
Noelle:     Loop "  %88 = icmp slt i64 %indvars.iv10.i4.i, %85" (3.999787e-01%)
Noelle:     Loop "  %100 = icmp slt i64 %indvars.iv8.i6.i, %84" (3.971678e-01%)
Noelle:     Loop "  %108 = icmp slt i64 %indvars.iv.i8.i, %83" (3.888167e-01%)
Noelle:     Loop "  %243 = icmp slt i64 %indvars.iv16.i.i, %195" (3.811096e+00%)
Noelle:     Loop "  %256 = icmp slt i64 %indvars.iv14.i.i, %194" (3.782550e+00%)
Noelle:     Loop "  %263 = icmp slt i64 %indvars.iv12.i.i, %193" (3.703016e+00%)
Noelle:     Loop "  %198 = icmp slt i64 %indvars.iv10.i.i, %195" (3.809321e-01%)
Noelle:     Loop "  %210 = icmp slt i64 %indvars.iv8.i.i, %194" (3.782550e-01%)
Noelle:     Loop "  %218 = icmp slt i64 %indvars.iv.i.i, %193" (3.703016e-01%)
Noelle:     Loop "  %297 = icmp slt i64 %indvars.iv5.i, %295" (3.761898e-01%)
Noelle:     Loop "  %299 = icmp slt i64 %indvars.iv.i, %294" (3.681496e-01%)
Noelle:     Loop "  %319 = icmp slt i64 %indvars.iv11, %317" (9.940430e-01%)
Noelle:     Loop "  %321 = icmp slt i64 %indvars.iv9, %315" (9.739229e-01%)
Noelle:  Function "cffts1"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv14, 3" (3.447864e-07%)
Noelle:     Loop "  %25 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (6.309581e+00%)
Noelle:     Loop "  %32 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 1" (6.309577e+00%)
Noelle:     Loop "  %41 = icmp slt i64 %indvars.iv6, %39" (9.116116e-01%)
Noelle:     Loop "  %47 = icmp slt i64 %indvars.iv, %38" (9.106507e-01%)
Noelle:     Loop "  %69 = icmp sgt i32 %.0.i, %21" (4.298204e+00%)
Noelle:     Loop "  %133 = icmp slt i64 %indvars.iv16.i11.i, %85" (2.000833e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv14.i13.i, %84" (1.985847e+00%)
Noelle:     Loop "  %153 = icmp slt i64 %indvars.iv12.i14.i, %83" (1.944091e+00%)
Noelle:     Loop "  %88 = icmp slt i64 %indvars.iv10.i4.i, %85" (1.999901e-01%)
Noelle:     Loop "  %100 = icmp slt i64 %indvars.iv8.i6.i, %84" (1.985847e-01%)
Noelle:     Loop "  %108 = icmp slt i64 %indvars.iv.i8.i, %83" (1.944091e-01%)
Noelle:     Loop "  %243 = icmp slt i64 %indvars.iv16.i.i, %195" (1.905556e+00%)
Noelle:     Loop "  %256 = icmp slt i64 %indvars.iv14.i.i, %194" (1.891282e+00%)
Noelle:     Loop "  %263 = icmp slt i64 %indvars.iv12.i.i, %193" (1.851515e+00%)
Noelle:     Loop "  %198 = icmp slt i64 %indvars.iv10.i.i, %195" (1.904668e-01%)
Noelle:     Loop "  %210 = icmp slt i64 %indvars.iv8.i.i, %194" (1.891282e-01%)
Noelle:     Loop "  %218 = icmp slt i64 %indvars.iv.i.i, %193" (1.851515e-01%)
Noelle:     Loop "  %297 = icmp slt i64 %indvars.iv5.i, %295" (1.880956e-01%)
Noelle:     Loop "  %299 = icmp slt i64 %indvars.iv.i, %294" (1.840755e-01%)
Noelle:     Loop "  %319 = icmp slt i64 %indvars.iv10, %313" (9.114024e-01%)
Noelle:     Loop "  %323 = icmp slt i64 %indvars.iv8, %317" (9.106507e-01%)
Noelle:  Function "evolve"
Noelle:     Loop "  %16 = icmp slt i64 %indvars.iv5, %8" (1.023166e+00%)
Noelle:     Loop "  %18 = icmp slt i64 %indvars.iv3, %11" (1.023164e+00%)
Noelle:     Loop "  %20 = icmp slt i64 %indvars.iv, %14" (1.022593e+00%)
Noelle:  Function "compute_initial_conditions"
Noelle:     Loop "  %23 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2" (3.895849e-01%)
Noelle:     Loop "  %36 = icmp sgt i64 %indvars.iv.i, %34" (2.920869e-01%)
Noelle:     Loop "  %65 = icmp slt i64 %indvars.iv6, %63" (9.749587e-02%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 512" (9.740064e-02%)
Noelle:  Function "vranlc"
Noelle:     Loop "  %13 = icmp sgt i64 %indvars.iv, %11" (2.920867e-01%)
Noelle:  Function "compute_indexmap"
Noelle:     Loop "  %15 = icmp slt i64 %indvars.iv10, %4" (6.845920e-02%)
Noelle:     Loop "  %23 = icmp slt i64 %indvars.iv8, %8" (6.845830e-02%)
Noelle:     Loop "  %33 = icmp slt i64 %indvars.iv6, %12" (6.821087e-02%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 1966081" (3.138427e-03%)
Noelle:  Function "checksum"
Noelle:     Loop "  %exitcond = icmp eq i32 %.0, 1025" (6.240395e-05%)
Noelle:  Function "randlc"
Noelle:  Function "fft_init"
Noelle:     Loop "  %7 = icmp sgt i32 %.01, %2" (1.134973e-06%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count" (1.115968e-06%)
Noelle:  Function "ilog2"
Noelle:     Loop "  %3 = icmp slt i32 %.01, %0" (8.034619e-07%)
Noelle:  Function "ipow46"
Noelle:     Loop "  %11 = icmp sgt i32 %.01, 1" (1.075780e-07%)
Noelle:  Function "verify"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 21" (3.358639e-08%)
Noelle:  Function "setup"
Noelle:     Loop "  %exitcond3 = icmp eq i64 %indvars.iv1, 3" (2.611469e-09%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 3" (3.917203e-09%)
Noelle:  Function "elapsed_time"
Noelle:  Function "timer_clear"
Noelle:  Function "c_print_results"
Noelle:  Function "wtime_"
Noelle:  Function "timer_stop"
Noelle:  Function "timer_start"
Noelle:  Function "timer_read"
NOELLE: FixedPoint: Exit
NOELLE: Inliner: Exit
noelle-simplification baseline_pre.bc -o baseline_pre.bc
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -tbaa -early-cse-memssa -licm -simplifycfg -simplifycfg-sink-common=false -instcombine -tailcallelim -loop-simplify -lcssa -licm -loop-unswitch -globalopt -instcombine -ipsccp -dce -gvn -dse -adce -loop-simplify -lcssa -indvars -loop-deletion -instcombine -indvars -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa --functionattrs --rpo-functionattrs baseline_pre.bc -o baseline_pre.bc
noelle-deadcode baseline_pre.bc baseline_pre.bc
NOELLE: DeadFunctions: Start
noelle-fixedpoint baseline_pre.bc baseline_pre.bc "noelle-load" -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DeadFunction.so -noelle-dfe
NOELLE: FixedPoint: Start
NOELLE: FixedPoint:   Loader: noelle-load
NOELLE: FixedPoint:   Options: -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DeadFunction.so -noelle-dfe
NOELLE: FixedPoint:   Input: baseline_pre.bc
NOELLE: FixedPoint:   Output: baseline_pre.bc
NOELLE: FixedPoint:   Temporary input: /tmp/tmp.qrLYlyzuHI (.ll version is /tmp/tmp.PFP4uWGet2)
NOELLE: FixedPoint:   Temporary output: /tmp/tmp.irDlDEMLbV (.ll version is /tmp/tmp.kf8eh2Hndb)
NOELLE: FixedPoint:   Normalize the code
noelle-norm /tmp/tmp.qrLYlyzuHI -o /tmp/tmp.irDlDEMLbV
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.qrLYlyzuHI -o /tmp/tmp.irDlDEMLbV
NOELLE: FixedPoint:   Run until a fixed point is reached
NOELLE: FixedPoint:     Invocation 0
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DeadFunction.so -noelle-dfe /tmp/tmp.qrLYlyzuHI -o /tmp/tmp.irDlDEMLbV
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DeadFunction.so -noelle-dfe /tmp/tmp.qrLYlyzuHI -o /tmp/tmp.irDlDEMLbV
DeadFunctionEliminator: Start
DeadFunctionEliminator:   Inline functions that are invoked only by one call instruction and that do not escape into memory
DeadFunctionEliminator:   Get the islands
DeadFunctionEliminator:   Identify the islands reachable from the entry points
DeadFunctionEliminator:     Island
DeadFunctionEliminator:       llvm.lifetime.start.p0i8
DeadFunctionEliminator:       main
DeadFunctionEliminator:       setup
DeadFunctionEliminator:       compute_indexmap
DeadFunctionEliminator:       compute_initial_conditions
DeadFunctionEliminator:       fft_init
DeadFunctionEliminator:       fft
DeadFunctionEliminator:       evolve
DeadFunctionEliminator:       checksum
DeadFunctionEliminator:       verify
DeadFunctionEliminator:       elapsed_time
DeadFunctionEliminator:       llvm.lifetime.end.p0i8
DeadFunctionEliminator:       llvm.fabs.f64
DeadFunctionEliminator:       printf
DeadFunctionEliminator:       cffts1
DeadFunctionEliminator:       cffts2
DeadFunctionEliminator:       cffts3
DeadFunctionEliminator:       ilog2
DeadFunctionEliminator:       exit
DeadFunctionEliminator:       cos
DeadFunctionEliminator:       sin
DeadFunctionEliminator:       ipow46
DeadFunctionEliminator:       randlc
DeadFunctionEliminator:       c_print_results
DeadFunctionEliminator:       timer_clear
DeadFunctionEliminator:       timer_start
DeadFunctionEliminator:       timer_stop
DeadFunctionEliminator:       timer_read
DeadFunctionEliminator:       wtime_
DeadFunctionEliminator:       gettimeofday
DeadFunctionEliminator:       puts
DeadFunctionEliminator:   Identify the functions that can be deleted
DeadFunctionEliminator: Exit
Noelle:  Function "main"
Noelle:     Loop "  %exitcond8 = icmp eq i32 %.02, 7" (8.669093e-09%)
Noelle:     Loop "  %exitcond = icmp eq i32 %.1, 7" (8.669093e-09%)
Noelle:     Loop "  %.b4 = load i1, i1* @niter, align 4" (4.793898e+01%)
Noelle:     Loop "  %exitcond.i = icmp eq i64 %indvars.iv15.i, 3" (5.590918e-07%)
Noelle:     Loop "  %88 = icmp slt i64 %indvars.iv13.i, %69" (1.794275e+01%)
Noelle:     Loop "  %90 = icmp sgt i64 %indvars.iv, %86" (1.794274e+01%)
Noelle:     Loop "  %92 = icmp slt i64 %indvars.iv7.i, %76" (1.785195e+00%)
Noelle:     Loop "  %93 = icmp slt i64 %indvars.iv.i, %75" (1.752575e+00%)
Noelle:     Loop "  %111 = icmp slt i32 %66, %.0.i.i" (1.393584e+01%)
Noelle:     Loop "  %124 = icmp slt i64 %indvars.iv16.i11.i.i, %122" (7.136324e+00%)
Noelle:     Loop "  %137 = icmp slt i64 %indvars.iv14.i13.i.i, %121" (7.082871e+00%)
Noelle:     Loop "  %144 = icmp slt i64 %indvars.iv12.i14.i.i, %75" (6.933942e+00%)
Noelle:     Loop "  %183 = icmp slt i64 %indvars.iv16.i.i.i, %181" (6.796499e+00%)
Noelle:     Loop "  %196 = icmp slt i64 %indvars.iv14.i.i.i, %180" (6.745592e+00%)
Noelle:     Loop "  %203 = icmp slt i64 %indvars.iv12.i.i.i, %75" (6.603754e+00%)
Noelle:     Loop "  %231 = icmp slt i64 %indvars.iv5.i.i, %76" (6.098873e-01%)
Noelle:     Loop "  %232 = icmp slt i64 %indvars.iv.i.i, %75" (5.968524e-01%)
Noelle:     Loop "  %246 = icmp slt i64 %indvars.iv11.i, %76" (1.611565e+00%)
Noelle:     Loop "  %247 = icmp slt i64 %indvars.iv9.i, %75" (1.578946e+00%)
Noelle:     Loop "  %exitcond.i2 = icmp eq i64 %indvars.iv15.i1, 3" (5.590918e-07%)
Noelle:     Loop "  %288 = icmp slt i64 %indvars.iv13.i4, %273" (1.794268e+01%)
Noelle:     Loop "  %290 = icmp sgt i64 %indvars.iv60, %286" (1.794268e+01%)
Noelle:     Loop "  %292 = icmp slt i64 %indvars.iv7.i7, %279" (1.785188e+00%)
Noelle:     Loop "  %293 = icmp slt i64 %indvars.iv.i9, %75" (1.752569e+00%)
Noelle:     Loop "  %311 = icmp slt i32 %270, %.0.i.i15" (1.393578e+01%)
Noelle:     Loop "  %324 = icmp slt i64 %indvars.iv16.i11.i.i20, %322" (7.136297e+00%)
Noelle:     Loop "  %337 = icmp slt i64 %indvars.iv14.i13.i.i22, %321" (7.082844e+00%)
Noelle:     Loop "  %344 = icmp slt i64 %indvars.iv12.i14.i.i23, %75" (6.933916e+00%)
Noelle:     Loop "  %383 = icmp slt i64 %indvars.iv16.i.i.i30, %381" (6.796473e+00%)
Noelle:     Loop "  %396 = icmp slt i64 %indvars.iv14.i.i.i32, %380" (6.745566e+00%)
Noelle:     Loop "  %403 = icmp slt i64 %indvars.iv12.i.i.i33, %75" (6.603729e+00%)
Noelle:     Loop "  %431 = icmp slt i64 %indvars.iv5.i.i40, %279" (6.098850e-01%)
Noelle:     Loop "  %432 = icmp slt i64 %indvars.iv.i.i42, %75" (5.968501e-01%)
Noelle:     Loop "  %446 = icmp slt i64 %indvars.iv11.i47, %279" (1.611559e+00%)
Noelle:     Loop "  %447 = icmp slt i64 %indvars.iv9.i49, %75" (1.578940e+00%)
Noelle:     Loop "  %exitcond.i1 = icmp eq i64 %indvars.iv14.i, 3" (5.590918e-07%)
Noelle:     Loop "  %488 = icmp slt i64 %indvars.iv12.i, %473" (1.022844e+01%)
Noelle:     Loop "  %490 = icmp sgt i64 %indvars.iv62, %486" (1.022843e+01%)
Noelle:     Loop "  %491 = icmp slt i64 %indvars.iv6.i, %75" (1.477911e+00%)
Noelle:     Loop "  %496 = icmp slt i64 %indvars.iv.i5, %479" (1.476353e+00%)
Noelle:     Loop "  %512 = icmp slt i32 %470, %.0.i.i10" (6.967879e+00%)
Noelle:     Loop "  %525 = icmp slt i64 %indvars.iv16.i11.i.i15, %523" (3.568142e+00%)
Noelle:     Loop "  %538 = icmp slt i64 %indvars.iv14.i13.i.i17, %522" (3.541415e+00%)
Noelle:     Loop "  %545 = icmp slt i64 %indvars.iv12.i14.i.i18, %75" (3.466951e+00%)
Noelle:     Loop "  %584 = icmp slt i64 %indvars.iv16.i.i.i25, %582" (3.398230e+00%)
Noelle:     Loop "  %597 = icmp slt i64 %indvars.iv14.i.i.i27, %581" (3.372777e+00%)
Noelle:     Loop "  %604 = icmp slt i64 %indvars.iv12.i.i.i28, %75" (3.301858e+00%)
Noelle:     Loop "  %632 = icmp slt i64 %indvars.iv5.i.i35, %479" (3.049419e-01%)
Noelle:     Loop "  %633 = icmp slt i64 %indvars.iv.i.i37, %75" (2.984245e-01%)
Noelle:     Loop "  %647 = icmp slt i64 %indvars.iv10.i, %75" (1.477572e+00%)
Noelle:     Loop "  %651 = icmp slt i64 %indvars.iv8.i, %479" (1.476353e+00%)
Noelle:  Function "fft"
Noelle:  Function "cffts3"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (2.386814e+09%)
Noelle:     Loop "  %36 = icmp slt i64 %indvars.iv13, %24" (1.973377e+01%)
Noelle:     Loop "  %40 = sub nsw i32 %26, %.pre" (1.973376e+01%)
Noelle:     Loop "  %45 = icmp slt i64 %indvars.iv7, %29" (1.964082e+00%)
Noelle:     Loop "  %46 = icmp slt i64 %indvars.iv, %38" (1.928194e+00%)
Noelle:     Loop "  %68 = icmp slt i32 %21, %.0.i" (1.532515e+01%)
Noelle:     Loop "  %80 = icmp slt i64 %indvars.iv10.i4.i, %78" (7.847770e+00%)
Noelle:     Loop "  %92 = icmp slt i64 %indvars.iv8.i6.i, %77" (7.792618e+00%)
Noelle:     Loop "  %100 = icmp slt i64 %indvars.iv.i8.i, %38" (7.628766e+00%)
Noelle:     Loop "  %137 = icmp slt i64 %indvars.iv10.i.i, %135" (7.474067e+00%)
Noelle:     Loop "  %149 = icmp slt i64 %indvars.iv8.i.i, %134" (7.421541e+00%)
Noelle:     Loop "  %157 = icmp slt i64 %indvars.iv.i.i, %38" (7.265491e+00%)
Noelle:     Loop "  %185 = icmp slt i64 %indvars.iv5.i, %29" (6.710017e-01%)
Noelle:     Loop "  %186 = icmp slt i64 %indvars.iv.i, %38" (6.566606e-01%)
Noelle:     Loop "  %200 = icmp slt i64 %indvars.iv11, %29" (1.773054e+00%)
Noelle:     Loop "  %201 = icmp slt i64 %indvars.iv9, %38" (1.737166e+00%)
Noelle:  Function "cffts2"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (6.149880e-07%)
Noelle:     Loop "  %43 = icmp slt i64 %indvars.iv13, %24" (1.973366e+01%)
Noelle:     Loop "  %45 = icmp sgt i64 %indvars.iv14, %41" (1.973365e+01%)
Noelle:     Loop "  %47 = icmp slt i64 %indvars.iv7, %31" (1.964090e+00%)
Noelle:     Loop "  %48 = icmp slt i64 %indvars.iv, %30" (1.928202e+00%)
Noelle:     Loop "  %65 = icmp slt i32 %21, %.0.i" (1.532521e+01%)
Noelle:     Loop "  %77 = icmp slt i64 %indvars.iv10.i4.i, %75" (7.847800e+00%)
Noelle:     Loop "  %89 = icmp slt i64 %indvars.iv8.i6.i, %74" (7.792648e+00%)
Noelle:     Loop "  %97 = icmp slt i64 %indvars.iv.i8.i, %30" (7.628795e+00%)
Noelle:     Loop "  %134 = icmp slt i64 %indvars.iv10.i.i, %132" (7.474095e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv8.i.i, %131" (7.421570e+00%)
Noelle:     Loop "  %154 = icmp slt i64 %indvars.iv.i.i, %30" (7.265519e+00%)
Noelle:     Loop "  %181 = icmp slt i64 %indvars.iv5.i, %31" (6.710043e-01%)
Noelle:     Loop "  %182 = icmp slt i64 %indvars.iv.i, %30" (6.566631e-01%)
Noelle:     Loop "  %196 = icmp slt i64 %indvars.iv11, %31" (1.773060e+00%)
Noelle:     Loop "  %197 = icmp slt i64 %indvars.iv9, %30" (1.737172e+00%)
Noelle:  Function "cffts1"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv14, 3" (6.149880e-07%)
Noelle:     Loop "  %36 = icmp slt i64 %indvars.iv12, %24" (1.125000e+01%)
Noelle:     Loop "  %42 = icmp sgt i64 %indvars.iv11, %40" (1.124999e+01%)
Noelle:     Loop "  %43 = icmp slt i64 %indvars.iv6, %39" (1.626022e+00%)
Noelle:     Loop "  %48 = icmp slt i64 %indvars.iv, %29" (1.624308e+00%)
Noelle:     Loop "  %68 = icmp slt i32 %21, %.0.i" (7.662604e+00%)
Noelle:     Loop "  %80 = icmp slt i64 %indvars.iv10.i4.i, %78" (3.923899e+00%)
Noelle:     Loop "  %92 = icmp slt i64 %indvars.iv8.i6.i, %77" (3.896323e+00%)
Noelle:     Loop "  %100 = icmp slt i64 %indvars.iv.i8.i, %39" (3.814396e+00%)
Noelle:     Loop "  %137 = icmp slt i64 %indvars.iv10.i.i, %135" (3.737047e+00%)
Noelle:     Loop "  %149 = icmp slt i64 %indvars.iv8.i.i, %134" (3.710784e+00%)
Noelle:     Loop "  %157 = icmp slt i64 %indvars.iv.i.i, %39" (3.632759e+00%)
Noelle:     Loop "  %185 = icmp slt i64 %indvars.iv5.i, %29" (3.355021e-01%)
Noelle:     Loop "  %186 = icmp slt i64 %indvars.iv.i, %39" (3.283315e-01%)
Noelle:     Loop "  %200 = icmp slt i64 %indvars.iv10, %39" (1.625649e+00%)
Noelle:     Loop "  %204 = icmp slt i64 %indvars.iv8, %29" (1.624308e+00%)
Noelle:  Function "evolve"
Noelle:     Loop "  %16 = icmp slt i64 %indvars.iv5, %8" (1.825000e+00%)
Noelle:     Loop "  %17 = icmp slt i64 %indvars.iv3, %11" (1.824996e+00%)
Noelle:     Loop "  %18 = icmp slt i64 %indvars.iv, %14" (1.823976e+00%)
Noelle:  Function "compute_initial_conditions"
Noelle:     Loop "  %34 = icmp slt i64 %indvars.iv8, %20" (6.948924e-01%)
Noelle:     Loop "  %37 = icmp sgt i64 %indvars.iv.i, %24" (5.209890e-01%)
Noelle:     Loop "  %63 = icmp slt i64 %indvars.iv6, %25" (1.739012e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 512" (1.737314e-01%)
Noelle:  Function "vranlc"
Noelle:     Loop "  %13 = icmp sgt i64 %indvars.iv, %11" (5.209887e-01%)
Noelle:  Function "compute_indexmap"
Noelle:     Loop "  %15 = icmp slt i64 %indvars.iv10, %4" (1.221092e-01%)
Noelle:     Loop "  %23 = icmp slt i64 %indvars.iv8, %8" (1.221076e-01%)
Noelle:     Loop "  %33 = icmp slt i64 %indvars.iv6, %12" (1.216662e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 1966081" (5.597944e-03%)
Noelle:  Function "checksum"
Noelle:     Loop "  %exitcond = icmp eq i32 %.0, 1025" (1.113086e-04%)
Noelle:  Function "randlc"
Noelle:  Function "fft_init"
Noelle:     Loop "  %7 = icmp sgt i32 %.01, %2" (2.024427e-06%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count" (1.990527e-06%)
Noelle:  Function "ilog2"
Noelle:     Loop "  %3 = icmp slt i32 %.01, %0" (1.433117e-06%)
Noelle:  Function "ipow46"
Noelle:     Loop "  %11 = icmp sgt i32 %.01, 1" (1.918845e-07%)
Noelle:  Function "verify"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 21" (5.990731e-08%)
Noelle:  Function "setup"
Noelle:     Loop "  %exitcond3 = icmp eq i64 %indvars.iv1, 3" (4.658020e-09%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 3" (6.987030e-09%)
Noelle:  Function "elapsed_time"
Noelle:  Function "timer_clear"
Noelle:  Function "c_print_results"
Noelle:  Function "wtime_"
Noelle:  Function "timer_stop"
Noelle:  Function "timer_start"
Noelle:  Function "timer_read"
Noelle:  Function "main"
Noelle:     Loop "  %exitcond8 = icmp eq i32 %.02, 7" (8.669093e-09%)
Noelle:     Loop "  %exitcond = icmp eq i32 %.1, 7" (8.669093e-09%)
Noelle:     Loop "  %.b4 = load i1, i1* @niter, align 4" (4.793898e+01%)
Noelle:     Loop "  %exitcond.i = icmp eq i64 %indvars.iv15.i, 3" (5.590918e-07%)
Noelle:     Loop "  %88 = icmp slt i64 %indvars.iv13.i, %69" (1.794275e+01%)
Noelle:     Loop "  %90 = icmp sgt i64 %indvars.iv, %86" (1.794274e+01%)
Noelle:     Loop "  %92 = icmp slt i64 %indvars.iv7.i, %76" (1.785195e+00%)
Noelle:     Loop "  %93 = icmp slt i64 %indvars.iv.i, %75" (1.752575e+00%)
Noelle:     Loop "  %111 = icmp slt i32 %66, %.0.i.i" (1.393584e+01%)
Noelle:     Loop "  %124 = icmp slt i64 %indvars.iv16.i11.i.i, %122" (7.136324e+00%)
Noelle:     Loop "  %137 = icmp slt i64 %indvars.iv14.i13.i.i, %121" (7.082871e+00%)
Noelle:     Loop "  %144 = icmp slt i64 %indvars.iv12.i14.i.i, %75" (6.933942e+00%)
Noelle:     Loop "  %183 = icmp slt i64 %indvars.iv16.i.i.i, %181" (6.796499e+00%)
Noelle:     Loop "  %196 = icmp slt i64 %indvars.iv14.i.i.i, %180" (6.745592e+00%)
Noelle:     Loop "  %203 = icmp slt i64 %indvars.iv12.i.i.i, %75" (6.603754e+00%)
Noelle:     Loop "  %231 = icmp slt i64 %indvars.iv5.i.i, %76" (6.098873e-01%)
Noelle:     Loop "  %232 = icmp slt i64 %indvars.iv.i.i, %75" (5.968524e-01%)
Noelle:     Loop "  %246 = icmp slt i64 %indvars.iv11.i, %76" (1.611565e+00%)
Noelle:     Loop "  %247 = icmp slt i64 %indvars.iv9.i, %75" (1.578946e+00%)
Noelle:     Loop "  %exitcond.i2 = icmp eq i64 %indvars.iv15.i1, 3" (5.590918e-07%)
Noelle:     Loop "  %288 = icmp slt i64 %indvars.iv13.i4, %273" (1.794268e+01%)
Noelle:     Loop "  %290 = icmp sgt i64 %indvars.iv60, %286" (1.794268e+01%)
Noelle:     Loop "  %292 = icmp slt i64 %indvars.iv7.i7, %279" (1.785188e+00%)
Noelle:     Loop "  %293 = icmp slt i64 %indvars.iv.i9, %75" (1.752569e+00%)
Noelle:     Loop "  %311 = icmp slt i32 %270, %.0.i.i15" (1.393578e+01%)
Noelle:     Loop "  %324 = icmp slt i64 %indvars.iv16.i11.i.i20, %322" (7.136297e+00%)
Noelle:     Loop "  %337 = icmp slt i64 %indvars.iv14.i13.i.i22, %321" (7.082844e+00%)
Noelle:     Loop "  %344 = icmp slt i64 %indvars.iv12.i14.i.i23, %75" (6.933916e+00%)
Noelle:     Loop "  %383 = icmp slt i64 %indvars.iv16.i.i.i30, %381" (6.796473e+00%)
Noelle:     Loop "  %396 = icmp slt i64 %indvars.iv14.i.i.i32, %380" (6.745566e+00%)
Noelle:     Loop "  %403 = icmp slt i64 %indvars.iv12.i.i.i33, %75" (6.603729e+00%)
Noelle:     Loop "  %431 = icmp slt i64 %indvars.iv5.i.i40, %279" (6.098850e-01%)
Noelle:     Loop "  %432 = icmp slt i64 %indvars.iv.i.i42, %75" (5.968501e-01%)
Noelle:     Loop "  %446 = icmp slt i64 %indvars.iv11.i47, %279" (1.611559e+00%)
Noelle:     Loop "  %447 = icmp slt i64 %indvars.iv9.i49, %75" (1.578940e+00%)
Noelle:     Loop "  %exitcond.i1 = icmp eq i64 %indvars.iv14.i, 3" (5.590918e-07%)
Noelle:     Loop "  %488 = icmp slt i64 %indvars.iv12.i, %473" (1.022844e+01%)
Noelle:     Loop "  %490 = icmp sgt i64 %indvars.iv62, %486" (1.022843e+01%)
Noelle:     Loop "  %491 = icmp slt i64 %indvars.iv6.i, %75" (1.477911e+00%)
Noelle:     Loop "  %496 = icmp slt i64 %indvars.iv.i5, %479" (1.476353e+00%)
Noelle:     Loop "  %512 = icmp slt i32 %470, %.0.i.i10" (6.967879e+00%)
Noelle:     Loop "  %525 = icmp slt i64 %indvars.iv16.i11.i.i15, %523" (3.568142e+00%)
Noelle:     Loop "  %538 = icmp slt i64 %indvars.iv14.i13.i.i17, %522" (3.541415e+00%)
Noelle:     Loop "  %545 = icmp slt i64 %indvars.iv12.i14.i.i18, %75" (3.466951e+00%)
Noelle:     Loop "  %584 = icmp slt i64 %indvars.iv16.i.i.i25, %582" (3.398230e+00%)
Noelle:     Loop "  %597 = icmp slt i64 %indvars.iv14.i.i.i27, %581" (3.372777e+00%)
Noelle:     Loop "  %604 = icmp slt i64 %indvars.iv12.i.i.i28, %75" (3.301858e+00%)
Noelle:     Loop "  %632 = icmp slt i64 %indvars.iv5.i.i35, %479" (3.049419e-01%)
Noelle:     Loop "  %633 = icmp slt i64 %indvars.iv.i.i37, %75" (2.984245e-01%)
Noelle:     Loop "  %647 = icmp slt i64 %indvars.iv10.i, %75" (1.477572e+00%)
Noelle:     Loop "  %651 = icmp slt i64 %indvars.iv8.i, %479" (1.476353e+00%)
Noelle:  Function "fft"
Noelle:  Function "cffts3"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (2.386814e+09%)
Noelle:     Loop "  %36 = icmp slt i64 %indvars.iv13, %24" (1.973377e+01%)
Noelle:     Loop "  %40 = sub nsw i32 %26, %.pre" (1.973376e+01%)
Noelle:     Loop "  %45 = icmp slt i64 %indvars.iv7, %29" (1.964082e+00%)
Noelle:     Loop "  %46 = icmp slt i64 %indvars.iv, %38" (1.928194e+00%)
Noelle:     Loop "  %68 = icmp slt i32 %21, %.0.i" (1.532515e+01%)
Noelle:     Loop "  %80 = icmp slt i64 %indvars.iv10.i4.i, %78" (7.847770e+00%)
Noelle:     Loop "  %92 = icmp slt i64 %indvars.iv8.i6.i, %77" (7.792618e+00%)
Noelle:     Loop "  %100 = icmp slt i64 %indvars.iv.i8.i, %38" (7.628766e+00%)
Noelle:     Loop "  %137 = icmp slt i64 %indvars.iv10.i.i, %135" (7.474067e+00%)
Noelle:     Loop "  %149 = icmp slt i64 %indvars.iv8.i.i, %134" (7.421541e+00%)
Noelle:     Loop "  %157 = icmp slt i64 %indvars.iv.i.i, %38" (7.265491e+00%)
Noelle:     Loop "  %185 = icmp slt i64 %indvars.iv5.i, %29" (6.710017e-01%)
Noelle:     Loop "  %186 = icmp slt i64 %indvars.iv.i, %38" (6.566606e-01%)
Noelle:     Loop "  %200 = icmp slt i64 %indvars.iv11, %29" (1.773054e+00%)
Noelle:     Loop "  %201 = icmp slt i64 %indvars.iv9, %38" (1.737166e+00%)
Noelle:  Function "cffts2"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (6.149880e-07%)
Noelle:     Loop "  %43 = icmp slt i64 %indvars.iv13, %24" (1.973366e+01%)
Noelle:     Loop "  %45 = icmp sgt i64 %indvars.iv14, %41" (1.973365e+01%)
Noelle:     Loop "  %47 = icmp slt i64 %indvars.iv7, %31" (1.964090e+00%)
Noelle:     Loop "  %48 = icmp slt i64 %indvars.iv, %30" (1.928202e+00%)
Noelle:     Loop "  %65 = icmp slt i32 %21, %.0.i" (1.532521e+01%)
Noelle:     Loop "  %77 = icmp slt i64 %indvars.iv10.i4.i, %75" (7.847800e+00%)
Noelle:     Loop "  %89 = icmp slt i64 %indvars.iv8.i6.i, %74" (7.792648e+00%)
Noelle:     Loop "  %97 = icmp slt i64 %indvars.iv.i8.i, %30" (7.628795e+00%)
Noelle:     Loop "  %134 = icmp slt i64 %indvars.iv10.i.i, %132" (7.474095e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv8.i.i, %131" (7.421570e+00%)
Noelle:     Loop "  %154 = icmp slt i64 %indvars.iv.i.i, %30" (7.265519e+00%)
Noelle:     Loop "  %181 = icmp slt i64 %indvars.iv5.i, %31" (6.710043e-01%)
Noelle:     Loop "  %182 = icmp slt i64 %indvars.iv.i, %30" (6.566631e-01%)
Noelle:     Loop "  %196 = icmp slt i64 %indvars.iv11, %31" (1.773060e+00%)
Noelle:     Loop "  %197 = icmp slt i64 %indvars.iv9, %30" (1.737172e+00%)
Noelle:  Function "cffts1"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv14, 3" (6.149880e-07%)
Noelle:     Loop "  %36 = icmp slt i64 %indvars.iv12, %24" (1.125000e+01%)
Noelle:     Loop "  %42 = icmp sgt i64 %indvars.iv11, %40" (1.124999e+01%)
Noelle:     Loop "  %43 = icmp slt i64 %indvars.iv6, %39" (1.626022e+00%)
Noelle:     Loop "  %48 = icmp slt i64 %indvars.iv, %29" (1.624308e+00%)
Noelle:     Loop "  %68 = icmp slt i32 %21, %.0.i" (7.662604e+00%)
Noelle:     Loop "  %80 = icmp slt i64 %indvars.iv10.i4.i, %78" (3.923899e+00%)
Noelle:     Loop "  %92 = icmp slt i64 %indvars.iv8.i6.i, %77" (3.896323e+00%)
Noelle:     Loop "  %100 = icmp slt i64 %indvars.iv.i8.i, %39" (3.814396e+00%)
Noelle:     Loop "  %137 = icmp slt i64 %indvars.iv10.i.i, %135" (3.737047e+00%)
Noelle:     Loop "  %149 = icmp slt i64 %indvars.iv8.i.i, %134" (3.710784e+00%)
Noelle:     Loop "  %157 = icmp slt i64 %indvars.iv.i.i, %39" (3.632759e+00%)
Noelle:     Loop "  %185 = icmp slt i64 %indvars.iv5.i, %29" (3.355021e-01%)
Noelle:     Loop "  %186 = icmp slt i64 %indvars.iv.i, %39" (3.283315e-01%)
Noelle:     Loop "  %200 = icmp slt i64 %indvars.iv10, %39" (1.625649e+00%)
Noelle:     Loop "  %204 = icmp slt i64 %indvars.iv8, %29" (1.624308e+00%)
Noelle:  Function "evolve"
Noelle:     Loop "  %16 = icmp slt i64 %indvars.iv5, %8" (1.825000e+00%)
Noelle:     Loop "  %17 = icmp slt i64 %indvars.iv3, %11" (1.824996e+00%)
Noelle:     Loop "  %18 = icmp slt i64 %indvars.iv, %14" (1.823976e+00%)
Noelle:  Function "compute_initial_conditions"
Noelle:     Loop "  %34 = icmp slt i64 %indvars.iv8, %20" (6.948924e-01%)
Noelle:     Loop "  %37 = icmp sgt i64 %indvars.iv.i, %24" (5.209890e-01%)
Noelle:     Loop "  %63 = icmp slt i64 %indvars.iv6, %25" (1.739012e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 512" (1.737314e-01%)
Noelle:  Function "vranlc"
Noelle:     Loop "  %13 = icmp sgt i64 %indvars.iv, %11" (5.209887e-01%)
Noelle:  Function "compute_indexmap"
Noelle:     Loop "  %15 = icmp slt i64 %indvars.iv10, %4" (1.221092e-01%)
Noelle:     Loop "  %23 = icmp slt i64 %indvars.iv8, %8" (1.221076e-01%)
Noelle:     Loop "  %33 = icmp slt i64 %indvars.iv6, %12" (1.216662e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 1966081" (5.597944e-03%)
Noelle:  Function "checksum"
Noelle:     Loop "  %exitcond = icmp eq i32 %.0, 1025" (1.113086e-04%)
Noelle:  Function "randlc"
Noelle:  Function "fft_init"
Noelle:     Loop "  %7 = icmp sgt i32 %.01, %2" (2.024427e-06%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count" (1.990527e-06%)
Noelle:  Function "ilog2"
Noelle:     Loop "  %3 = icmp slt i32 %.01, %0" (1.433117e-06%)
Noelle:  Function "ipow46"
Noelle:     Loop "  %11 = icmp sgt i32 %.01, 1" (1.918845e-07%)
Noelle:  Function "verify"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 21" (5.990731e-08%)
Noelle:  Function "setup"
Noelle:     Loop "  %exitcond3 = icmp eq i64 %indvars.iv1, 3" (4.658020e-09%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 3" (6.987030e-09%)
Noelle:  Function "elapsed_time"
Noelle:  Function "timer_clear"
Noelle:  Function "c_print_results"
Noelle:  Function "wtime_"
Noelle:  Function "timer_stop"
Noelle:  Function "timer_start"
Noelle:  Function "timer_read"
NOELLE: FixedPoint: Exit
NOELLE: DeadFunctions: Exit
noelle-simplification baseline_pre.bc -o baseline_pre.bc
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -tbaa -early-cse-memssa -licm -simplifycfg -simplifycfg-sink-common=false -instcombine -tailcallelim -loop-simplify -lcssa -licm -loop-unswitch -globalopt -instcombine -ipsccp -dce -gvn -dse -adce -loop-simplify -lcssa -indvars -loop-deletion -instcombine -indvars -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa --functionattrs --rpo-functionattrs baseline_pre.bc -o baseline_pre.bc
noelle-enable baseline_pre.bc baseline_pre.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier
NOELLE: Enablers: Start
noelle-fixedpoint baseline_pre.bc baseline_pre.bc "noelle-parallel-load" -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier
NOELLE: FixedPoint: Start
NOELLE: FixedPoint:   Loader: noelle-parallel-load
NOELLE: FixedPoint:   Options: -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier
NOELLE: FixedPoint:   Input: baseline_pre.bc
NOELLE: FixedPoint:   Output: baseline_pre.bc
NOELLE: FixedPoint:   Temporary input: /tmp/tmp.gjuMhYkPPD (.ll version is /tmp/tmp.pkY16Cx1fo)
NOELLE: FixedPoint:   Temporary output: /tmp/tmp.9OghPd0qQO (.ll version is /tmp/tmp.nVCTHhxsow)
NOELLE: FixedPoint:   Normalize the code
noelle-norm /tmp/tmp.gjuMhYkPPD -o /tmp/tmp.9OghPd0qQO
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.gjuMhYkPPD -o /tmp/tmp.9OghPd0qQO
NOELLE: FixedPoint:   Run until a fixed point is reached
NOELLE: FixedPoint:     Invocation 0
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.gjuMhYkPPD -o /tmp/tmp.9OghPd0qQO
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.gjuMhYkPPD -o /tmp/tmp.9OghPd0qQO
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.gjuMhYkPPD -o /tmp/tmp.9OghPd0qQO
EnablersManager: Start
Noelle: Filter out cold code
Noelle:  Function "main"
Noelle:     Loop "  %exitcond8 = icmp eq i32 %.02, 7" (8.669107e-09%)
Noelle:  Disable loop "0" as cold code
Noelle:     Loop "  %exitcond = icmp eq i32 %.1, 7" (8.669107e-09%)
Noelle:  Disable loop "1" as cold code
Noelle:     Loop "  %.b4 = load i1, i1* @niter, align 4" (4.793906e+01%)
Noelle:     Loop "  %exitcond.i = icmp eq i64 %indvars.iv15.i, 3" (5.590927e-07%)
Noelle:  Disable loop "3" as cold code
Noelle:     Loop "  %88 = icmp slt i64 %indvars.iv13.i, %69" (1.794278e+01%)
Noelle:     Loop "  %89 = icmp sgt i64 %indvars.iv, %86" (1.794277e+01%)
Noelle:     Loop "  %90 = icmp slt i64 %indvars.iv7.i, %76" (1.785198e+00%)
Noelle:     Loop "  %91 = icmp slt i64 %indvars.iv.i, %75" (1.752578e+00%)
Noelle:     Loop "  %109 = icmp slt i32 %66, %.0.i.i" (1.393586e+01%)
Noelle:     Loop "  %122 = icmp slt i64 %indvars.iv16.i11.i.i, %120" (7.136336e+00%)
Noelle:     Loop "  %135 = icmp slt i64 %indvars.iv14.i13.i.i, %119" (7.082883e+00%)
Noelle:     Loop "  %142 = icmp slt i64 %indvars.iv12.i14.i.i, %75" (6.933954e+00%)
Noelle:     Loop "  %181 = icmp slt i64 %indvars.iv16.i.i.i, %179" (6.796510e+00%)
Noelle:     Loop "  %194 = icmp slt i64 %indvars.iv14.i.i.i, %178" (6.745603e+00%)
Noelle:     Loop "  %201 = icmp slt i64 %indvars.iv12.i.i.i, %75" (6.603765e+00%)
Noelle:     Loop "  %228 = icmp slt i64 %indvars.iv5.i.i, %76" (6.098883e-01%)
Noelle:     Loop "  %229 = icmp slt i64 %indvars.iv.i.i, %75" (5.968533e-01%)
Noelle:     Loop "  %243 = icmp slt i64 %indvars.iv11.i, %76" (1.611568e+00%)
Noelle:     Loop "  %244 = icmp slt i64 %indvars.iv9.i, %75" (1.578948e+00%)
Noelle:     Loop "  %exitcond.i2 = icmp eq i64 %indvars.iv15.i1, 3" (5.590927e-07%)
Noelle:  Disable loop "19" as cold code
Noelle:     Loop "  %285 = icmp slt i64 %indvars.iv13.i4, %270" (1.794271e+01%)
Noelle:     Loop "  %286 = icmp sgt i64 %indvars.iv60, %283" (1.794271e+01%)
Noelle:     Loop "  %287 = icmp slt i64 %indvars.iv7.i7, %276" (1.785191e+00%)
Noelle:     Loop "  %288 = icmp slt i64 %indvars.iv.i9, %75" (1.752572e+00%)
Noelle:     Loop "  %306 = icmp slt i32 %267, %.0.i.i15" (1.393581e+01%)
Noelle:     Loop "  %319 = icmp slt i64 %indvars.iv16.i11.i.i20, %317" (7.136309e+00%)
Noelle:     Loop "  %332 = icmp slt i64 %indvars.iv14.i13.i.i22, %316" (7.082856e+00%)
Noelle:     Loop "  %339 = icmp slt i64 %indvars.iv12.i14.i.i23, %75" (6.933927e+00%)
Noelle:     Loop "  %378 = icmp slt i64 %indvars.iv16.i.i.i30, %376" (6.796484e+00%)
Noelle:     Loop "  %391 = icmp slt i64 %indvars.iv14.i.i.i32, %375" (6.745577e+00%)
Noelle:     Loop "  %398 = icmp slt i64 %indvars.iv12.i.i.i33, %75" (6.603740e+00%)
Noelle:     Loop "  %425 = icmp slt i64 %indvars.iv5.i.i40, %276" (6.098860e-01%)
Noelle:     Loop "  %426 = icmp slt i64 %indvars.iv.i.i42, %75" (5.968511e-01%)
Noelle:     Loop "  %440 = icmp slt i64 %indvars.iv11.i47, %276" (1.611561e+00%)
Noelle:     Loop "  %441 = icmp slt i64 %indvars.iv9.i49, %75" (1.578942e+00%)
Noelle:     Loop "  %exitcond.i1 = icmp eq i64 %indvars.iv14.i, 3" (5.590927e-07%)
Noelle:  Disable loop "35" as cold code
Noelle:     Loop "  %482 = icmp slt i64 %indvars.iv12.i, %467" (1.022846e+01%)
Noelle:     Loop "  %483 = icmp sgt i64 %indvars.iv62, %480" (1.022845e+01%)
Noelle:     Loop "  %484 = icmp slt i64 %indvars.iv6.i, %75" (1.477914e+00%)
Noelle:     Loop "  %489 = icmp slt i64 %indvars.iv.i5, %473" (1.476356e+00%)
Noelle:     Loop "  %505 = icmp slt i32 %464, %.0.i.i10" (6.967890e+00%)
Noelle:     Loop "  %518 = icmp slt i64 %indvars.iv16.i11.i.i15, %516" (3.568147e+00%)
Noelle:     Loop "  %531 = icmp slt i64 %indvars.iv14.i13.i.i17, %515" (3.541421e+00%)
Noelle:     Loop "  %538 = icmp slt i64 %indvars.iv12.i14.i.i18, %75" (3.466957e+00%)
Noelle:     Loop "  %577 = icmp slt i64 %indvars.iv16.i.i.i25, %575" (3.398236e+00%)
Noelle:     Loop "  %590 = icmp slt i64 %indvars.iv14.i.i.i27, %574" (3.372782e+00%)
Noelle:     Loop "  %597 = icmp slt i64 %indvars.iv12.i.i.i28, %75" (3.301864e+00%)
Noelle:     Loop "  %624 = icmp slt i64 %indvars.iv5.i.i35, %473" (3.049424e-01%)
Noelle:     Loop "  %625 = icmp slt i64 %indvars.iv.i.i37, %75" (2.984250e-01%)
Noelle:     Loop "  %639 = icmp slt i64 %indvars.iv10.i, %75" (1.477574e+00%)
Noelle:     Loop "  %643 = icmp slt i64 %indvars.iv8.i, %473" (1.476356e+00%)
Noelle:  Function "fft"
Noelle:  Function "cffts2"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (6.149890e-07%)
Noelle:  Disable loop "51" as cold code
Noelle:     Loop "  %43 = icmp slt i64 %indvars.iv13, %24" (1.973369e+01%)
Noelle:     Loop "  %44 = icmp sgt i64 %indvars.iv14, %41" (1.973368e+01%)
Noelle:     Loop "  %45 = icmp slt i64 %indvars.iv7, %31" (1.964093e+00%)
Noelle:     Loop "  %46 = icmp slt i64 %indvars.iv, %30" (1.928205e+00%)
Noelle:     Loop "  %63 = icmp slt i32 %21, %.0.i" (1.532524e+01%)
Noelle:     Loop "  %75 = icmp slt i64 %indvars.iv10.i4.i, %73" (7.847813e+00%)
Noelle:     Loop "  %87 = icmp slt i64 %indvars.iv8.i6.i, %72" (7.792661e+00%)
Noelle:     Loop "  %95 = icmp slt i64 %indvars.iv.i8.i, %30" (7.628807e+00%)
Noelle:     Loop "  %132 = icmp slt i64 %indvars.iv10.i.i, %130" (7.474108e+00%)
Noelle:     Loop "  %144 = icmp slt i64 %indvars.iv8.i.i, %129" (7.421582e+00%)
Noelle:     Loop "  %152 = icmp slt i64 %indvars.iv.i.i, %30" (7.265531e+00%)
Noelle:     Loop "  %178 = icmp slt i64 %indvars.iv5.i, %31" (6.710054e-01%)
Noelle:     Loop "  %179 = icmp slt i64 %indvars.iv.i, %30" (6.566642e-01%)
Noelle:     Loop "  %193 = icmp slt i64 %indvars.iv11, %31" (1.773063e+00%)
Noelle:     Loop "  %194 = icmp slt i64 %indvars.iv9, %30" (1.737175e+00%)
Noelle:  Function "cffts3"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (2.386818e+09%)
Noelle:     Loop "  %43 = icmp slt i64 %indvars.iv13, %24" (1.973369e+01%)
Noelle:     Loop "  %45 = icmp sgt i64 %indvars.iv12, %37" (1.973368e+01%)
Noelle:     Loop "  %47 = icmp slt i64 %indvars.iv7, %29" (1.964093e+00%)
Noelle:     Loop "  %48 = icmp slt i64 %indvars.iv, %35" (1.928205e+00%)
Noelle:     Loop "  %65 = icmp slt i32 %21, %.0.i" (1.532524e+01%)
Noelle:     Loop "  %77 = icmp slt i64 %indvars.iv10.i4.i, %75" (7.847813e+00%)
Noelle:     Loop "  %89 = icmp slt i64 %indvars.iv8.i6.i, %74" (7.792661e+00%)
Noelle:     Loop "  %97 = icmp slt i64 %indvars.iv.i8.i, %35" (7.628807e+00%)
Noelle:     Loop "  %134 = icmp slt i64 %indvars.iv10.i.i, %132" (7.474108e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv8.i.i, %131" (7.421582e+00%)
Noelle:     Loop "  %154 = icmp slt i64 %indvars.iv.i.i, %35" (7.265531e+00%)
Noelle:     Loop "  %181 = icmp slt i64 %indvars.iv5.i, %29" (6.710054e-01%)
Noelle:     Loop "  %182 = icmp slt i64 %indvars.iv.i, %35" (6.566642e-01%)
Noelle:     Loop "  %196 = icmp slt i64 %indvars.iv11, %29" (1.773063e+00%)
Noelle:     Loop "  %197 = icmp slt i64 %indvars.iv9, %35" (1.737175e+00%)
Noelle:  Function "cffts1"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv14, 3" (6.149890e-07%)
Noelle:  Disable loop "83" as cold code
Noelle:     Loop "  %43 = icmp slt i64 %indvars.iv12, %24" (1.124997e+01%)
Noelle:     Loop "  %45 = icmp sgt i64 %indvars.iv11, %37" (1.124996e+01%)
Noelle:     Loop "  %46 = icmp slt i64 %indvars.iv6, %36" (1.626028e+00%)
Noelle:     Loop "  %51 = icmp slt i64 %indvars.iv, %29" (1.624314e+00%)
Noelle:     Loop "  %66 = icmp slt i32 %21, %.0.i" (7.662631e+00%)
Noelle:     Loop "  %78 = icmp slt i64 %indvars.iv10.i4.i, %76" (3.923913e+00%)
Noelle:     Loop "  %90 = icmp slt i64 %indvars.iv8.i6.i, %75" (3.896337e+00%)
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv.i8.i, %36" (3.814410e+00%)
Noelle:     Loop "  %135 = icmp slt i64 %indvars.iv10.i.i, %133" (3.737060e+00%)
Noelle:     Loop "  %147 = icmp slt i64 %indvars.iv8.i.i, %132" (3.710797e+00%)
Noelle:     Loop "  %155 = icmp slt i64 %indvars.iv.i.i, %36" (3.632771e+00%)
Noelle:     Loop "  %182 = icmp slt i64 %indvars.iv5.i, %29" (3.355033e-01%)
Noelle:     Loop "  %183 = icmp slt i64 %indvars.iv.i, %36" (3.283327e-01%)
Noelle:     Loop "  %197 = icmp slt i64 %indvars.iv10, %36" (1.625655e+00%)
Noelle:     Loop "  %201 = icmp slt i64 %indvars.iv8, %29" (1.624314e+00%)
Noelle:  Function "evolve"
Noelle:     Loop "  %16 = icmp slt i64 %indvars.iv5, %8" (1.825003e+00%)
Noelle:     Loop "  %17 = icmp slt i64 %indvars.iv3, %11" (1.824999e+00%)
Noelle:     Loop "  %18 = icmp slt i64 %indvars.iv, %14" (1.823979e+00%)
Noelle:  Function "compute_initial_conditions"
Noelle:     Loop "  %34 = icmp slt i64 %indvars.iv8, %20" (6.948935e-01%)
Noelle:     Loop "  %36 = icmp sgt i64 %indvars.iv.i, %24" (5.209898e-01%)
Noelle:     Loop "  %61 = icmp slt i64 %indvars.iv6, %25" (1.739015e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 512" (1.737317e-01%)
Noelle:  Function "compute_indexmap"
Noelle:     Loop "  %15 = icmp slt i64 %indvars.iv10, %4" (1.221094e-01%)
Noelle:     Loop "  %23 = icmp slt i64 %indvars.iv8, %8" (1.221078e-01%)
Noelle:     Loop "  %33 = icmp slt i64 %indvars.iv6, %12" (1.216664e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 1966081" (5.597954e-03%)
Noelle:  Disable loop "109" as cold code
Noelle:  Function "checksum"
Noelle:  Disable "checksum" as cold function
Noelle:  Function "randlc"
Noelle:  Disable "randlc" as cold function
Noelle:  Function "fft_init"
Noelle:  Disable "fft_init" as cold function
Noelle:  Function "ilog2"
Noelle:  Disable "ilog2" as cold function
Noelle:  Function "ipow46"
Noelle:  Disable "ipow46" as cold function
Noelle:  Function "verify"
Noelle:  Disable "verify" as cold function
Noelle:  Function "setup"
Noelle:  Disable "setup" as cold function
Noelle:  Function "elapsed_time"
Noelle:  Disable "elapsed_time" as cold function
Noelle:  Function "timer_clear"
Noelle:  Disable "timer_clear" as cold function
Noelle:  Function "c_print_results"
Noelle:  Disable "c_print_results" as cold function
Noelle:  Function "wtime_"
Noelle:  Disable "wtime_" as cold function
Noelle:  Function "timer_stop"
Noelle:  Disable "timer_stop" as cold function
Noelle:  Function "timer_start"
Noelle:  Disable "timer_start" as cold function
Noelle:  Function "timer_read"
Noelle:  Disable "timer_read" as cold function
EnablersManager:   Try to improve all 102 loops, one at a time
EnablersManager:   Loop:
EnablersManager:     Function = "cffts3"
EnablersManager:     Entry instruction =   %exitcond = icmp eq i64 %indvars.iv15, 3
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond, label %17, label %12, !prof !33
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %538 = icmp slt i64 %indvars.iv12.i14.i.i18, %75
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %538 = icmp slt i64 %indvars.iv12.i14.i.i18, %75"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %538, label %539, label %562, !prof !53
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %531 = icmp slt i64 %indvars.iv14.i13.i.i17, %515
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %531 = icmp slt i64 %indvars.iv14.i13.i.i17, %515"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %531, label %532, label %563, !prof !52
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %518 = icmp slt i64 %indvars.iv16.i11.i.i15, %516
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %518 = icmp slt i64 %indvars.iv16.i11.i.i15, %516"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %518, label %519, label %.us-lcssa.us.loopexit1.i19.i.i22, !prof !51
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %597 = icmp slt i64 %indvars.iv12.i.i.i28, %75
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %597 = icmp slt i64 %indvars.iv12.i.i.i28, %75"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %597, label %598, label %621, !prof !53
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %590 = icmp slt i64 %indvars.iv14.i.i.i27, %574
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %590 = icmp slt i64 %indvars.iv14.i.i.i27, %574"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %590, label %591, label %622, !prof !52
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %577 = icmp slt i64 %indvars.iv16.i.i.i25, %575
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %577 = icmp slt i64 %indvars.iv16.i.i.i25, %575"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %577, label %578, label %.us-lcssa.us.loopexit1.i.i.i32, !prof !51
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %505 = icmp slt i32 %464, %.0.i.i10
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %505 = icmp slt i32 %464, %.0.i.i10"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %505, label %.preheader.i.i11..loopexit.i.i33_crit_edge, label %506, !prof !49
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %489 = icmp slt i64 %indvars.iv.i5, %473
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %489 = icmp slt i64 %indvars.iv.i5, %473"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %489, label %490, label %501, !prof !59
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %484 = icmp slt i64 %indvars.iv6.i, %75
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %484 = icmp slt i64 %indvars.iv6.i, %75"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %484, label %485, label %502, !prof !58
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %643 = icmp slt i64 %indvars.iv8.i, %473
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %643 = icmp slt i64 %indvars.iv8.i, %473"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %643, label %644, label %655, !prof !59
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %639 = icmp slt i64 %indvars.iv10.i, %75
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %639 = icmp slt i64 %indvars.iv10.i, %75"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %639, label %640, label %656, !prof !58
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %625 = icmp slt i64 %indvars.iv.i.i37, %75
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %625 = icmp slt i64 %indvars.iv.i.i37, %75"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %625, label %626, label %637, !prof !43
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %624 = icmp slt i64 %indvars.iv5.i.i35, %473
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %624 = icmp slt i64 %indvars.iv5.i.i35, %473"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %624, label %.preheader1.i.i36.preheader, label %cfftz.exit.i41.loopexit, !prof !56
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %483 = icmp sgt i64 %indvars.iv62, %480
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %483 = icmp sgt i64 %indvars.iv62, %480"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %483, label %657, label %.preheader.i4.preheader, !prof !57
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %482 = icmp slt i64 %indvars.iv12.i, %467
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %482 = icmp slt i64 %indvars.iv12.i, %467"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %482, label %.preheader17.preheader, label %cffts1.exit, !prof !40
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %142 = icmp slt i64 %indvars.iv12.i14.i.i, %75
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %142 = icmp slt i64 %indvars.iv12.i14.i.i, %75"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %142, label %143, label %166, !prof !53
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %135 = icmp slt i64 %indvars.iv14.i13.i.i, %119
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %135 = icmp slt i64 %indvars.iv14.i13.i.i, %119"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %135, label %136, label %167, !prof !52
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %122 = icmp slt i64 %indvars.iv16.i11.i.i, %120
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %122 = icmp slt i64 %indvars.iv16.i11.i.i, %120"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %122, label %123, label %.us-lcssa.us.loopexit1.i19.i.i, !prof !51
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %201 = icmp slt i64 %indvars.iv12.i.i.i, %75
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %201 = icmp slt i64 %indvars.iv12.i.i.i, %75"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %201, label %202, label %225, !prof !53
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %194 = icmp slt i64 %indvars.iv14.i.i.i, %178
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %194 = icmp slt i64 %indvars.iv14.i.i.i, %178"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %194, label %195, label %226, !prof !52
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %181 = icmp slt i64 %indvars.iv16.i.i.i, %179
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %181 = icmp slt i64 %indvars.iv16.i.i.i, %179"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %181, label %182, label %.us-lcssa.us.loopexit1.i.i.i, !prof !51
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %109 = icmp slt i32 %66, %.0.i.i
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %109 = icmp slt i32 %66, %.0.i.i"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %109, label %.preheader.i.i..loopexit.i.i_crit_edge, label %110, !prof !49
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %229 = icmp slt i64 %indvars.iv.i.i, %75
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %229 = icmp slt i64 %indvars.iv.i.i, %75"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %229, label %230, label %241, !prof !43
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %228 = icmp slt i64 %indvars.iv5.i.i, %76
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %228 = icmp slt i64 %indvars.iv5.i.i, %76"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %228, label %.preheader1.i.i.preheader, label %cfftz.exit.i.loopexit, !prof !56
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %244 = icmp slt i64 %indvars.iv9.i, %75
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %244 = icmp slt i64 %indvars.iv9.i, %75"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %244, label %245, label %257, !prof !43
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %243 = icmp slt i64 %indvars.iv11.i, %76
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %243 = icmp slt i64 %indvars.iv11.i, %76"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %243, label %.preheader.i.preheader, label %258, !prof !42
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %91 = icmp slt i64 %indvars.iv.i, %75
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %91 = icmp slt i64 %indvars.iv.i, %75"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %91, label %92, label %105, !prof !43
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %90 = icmp slt i64 %indvars.iv7.i, %76
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %90 = icmp slt i64 %indvars.iv7.i, %76"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %90, label %.preheader1.i.preheader, label %106, !prof !42
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %89 = icmp sgt i64 %indvars.iv, %86
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %89 = icmp sgt i64 %indvars.iv, %86"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %89, label %259, label %.preheader16.preheader, !prof !41
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %88 = icmp slt i64 %indvars.iv13.i, %69
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %88 = icmp slt i64 %indvars.iv13.i, %69"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %88, label %.preheader19.preheader, label %cffts3.exit, !prof !40
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %441 = icmp slt i64 %indvars.iv9.i49, %75
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %441 = icmp slt i64 %indvars.iv9.i49, %75"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %441, label %442, label %454, !prof !43
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %440 = icmp slt i64 %indvars.iv11.i47, %276
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %440 = icmp slt i64 %indvars.iv11.i47, %276"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %440, label %.preheader.i48.preheader, label %455, !prof !42
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %398 = icmp slt i64 %indvars.iv12.i.i.i33, %75
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %398 = icmp slt i64 %indvars.iv12.i.i.i33, %75"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %398, label %399, label %422, !prof !53
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %391 = icmp slt i64 %indvars.iv14.i.i.i32, %375
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %391 = icmp slt i64 %indvars.iv14.i.i.i32, %375"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %391, label %392, label %423, !prof !52
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %378 = icmp slt i64 %indvars.iv16.i.i.i30, %376
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %378 = icmp slt i64 %indvars.iv16.i.i.i30, %376"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %378, label %379, label %.us-lcssa.us.loopexit1.i.i.i37, !prof !51
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %339 = icmp slt i64 %indvars.iv12.i14.i.i23, %75
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %339 = icmp slt i64 %indvars.iv12.i14.i.i23, %75"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %339, label %340, label %363, !prof !53
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %332 = icmp slt i64 %indvars.iv14.i13.i.i22, %316
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %332 = icmp slt i64 %indvars.iv14.i13.i.i22, %316"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %332, label %333, label %364, !prof !52
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %319 = icmp slt i64 %indvars.iv16.i11.i.i20, %317
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %319 = icmp slt i64 %indvars.iv16.i11.i.i20, %317"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %319, label %320, label %.us-lcssa.us.loopexit1.i19.i.i27, !prof !51
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %306 = icmp slt i32 %267, %.0.i.i15
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %306 = icmp slt i32 %267, %.0.i.i15"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %306, label %.preheader.i.i16..loopexit.i.i38_crit_edge, label %307, !prof !49
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %288 = icmp slt i64 %indvars.iv.i9, %75
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %288 = icmp slt i64 %indvars.iv.i9, %75"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %288, label %289, label %302, !prof !43
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %287 = icmp slt i64 %indvars.iv7.i7, %276
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %287 = icmp slt i64 %indvars.iv7.i7, %276"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %287, label %.preheader1.i8.preheader, label %303, !prof !42
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %426 = icmp slt i64 %indvars.iv.i.i42, %75
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %426 = icmp slt i64 %indvars.iv.i.i42, %75"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %426, label %427, label %438, !prof !43
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %425 = icmp slt i64 %indvars.iv5.i.i40, %276
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %425 = icmp slt i64 %indvars.iv5.i.i40, %276"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %425, label %.preheader1.i.i41.preheader, label %cfftz.exit.i46.loopexit, !prof !56
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %286 = icmp sgt i64 %indvars.iv60, %283
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %286 = icmp sgt i64 %indvars.iv60, %283"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %286, label %456, label %.preheader14.preheader, !prof !41
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %285 = icmp slt i64 %indvars.iv13.i4, %270
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %285 = icmp slt i64 %indvars.iv13.i4, %270"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %285, label %.preheader18.preheader, label %cffts2.exit, !prof !40
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %.b4 = load i1, i1* @niter, align 4
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca [3 x i32], align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca [3 x i32], align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca [3 x i32], align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %.b4 = load i1, i1* @niter, align 4"
LICM:     Invariant = "  %55 = getelementptr [256 x [256 x [512 x %struct.dcomplex]]], [256 x [256 x [512 x %struct.dcomplex]]]* @main.u0, i64 0, i64 0
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %56 = getelementptr [256 x [256 x [512 x %struct.dcomplex]]], [256 x [256 x [512 x %struct.dcomplex]]]* @main.u1, i64 0, i64 0
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %57 = getelementptr [256 x [256 x [512 x i32]]], [256 x [256 x [512 x i32]]]* @main.indexmap, i64 0, i64 0
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %58 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 0
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %464 = load i32, i32* %50, align 4
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %465 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %466 = load i32, i32* %465, align 8, !tbaa !33
LICM:       Checking dependences
LICM:         Dependent instruction = "  %465 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %465 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 2
LICM:     Invariant = "  %467 = sext i32 %466 to i64
LICM:       Checking dependences
LICM:         Dependent instruction = "  %466 = load i32, i32* %465, align 8, !tbaa !33
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %466 = load i32, i32* %465, align 8, !tbaa !33
LICM:     Invariant = "  %468 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 1
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %469 = load i32, i32* %468, align 4
LICM:       Checking dependences
LICM:         Dependent instruction = "  %468 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 1
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %468 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 1
LICM:     Invariant = "  %470 = sub nsw i32 %469, %.pre.i
LICM:       Checking dependences
LICM:         Dependent instruction = "  %469 = load i32, i32* %468, align 4
LICM:         Dependent instruction = "  %.pre.i = load i32, i32* @fftblock, align 4
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %.pre.i = load i32, i32* @fftblock, align 4
LICM:         %469 = load i32, i32* %468, align 4
LICM:     Invariant = "  %471 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 0
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %472 = load i32, i32* %471, align 16
LICM:       Checking dependences
LICM:         Dependent instruction = "  %471 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 0
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %471 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 0
LICM:     Invariant = "  %473 = sext i32 %472 to i64
LICM:       Checking dependences
LICM:         Dependent instruction = "  %472 = load i32, i32* %471, align 16
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %472 = load i32, i32* %471, align 16
LICM:     Invariant = "  %474 = icmp slt i32 %464, 1
LICM:       Checking dependences
LICM:         Dependent instruction = "  %464 = load i32, i32* %50, align 4
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %464 = load i32, i32* %50, align 4
LICM:     Invariant = "  %475 = icmp sgt i32 %464, %79
LICM:       Checking dependences
LICM:         Dependent instruction = "  %79 = fptosi double %78 to i32
LICM:         Dependent instruction = "  %464 = load i32, i32* %50, align 4
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %79 = fptosi double %78 to i32
LICM:         %464 = load i32, i32* %50, align 4
LICM:     Invariant = "  %or.cond.i.i7 = or i1 %474, %475
LICM:       Checking dependences
LICM:         Dependent instruction = "  %474 = icmp slt i32 %464, 1
LICM:         Dependent instruction = "  %475 = icmp sgt i32 %464, %79
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %474 = icmp slt i32 %464, 1
LICM:         %475 = icmp sgt i32 %464, %79
LICM:     Invariant = "  %476 = sdiv i32 %472, 2
LICM:       Checking dependences
LICM:         Dependent instruction = "  %472 = load i32, i32* %471, align 16
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %472 = load i32, i32* %471, align 16
LICM:     Invariant = "  %477 = sext i32 %476 to i64
LICM:       Checking dependences
LICM:         Dependent instruction = "  %476 = sdiv i32 %472, 2
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %476 = sdiv i32 %472, 2
LICM:     Invariant = "  %478 = srem i32 %464, 2
LICM:       Checking dependences
LICM:         Dependent instruction = "  %464 = load i32, i32* %50, align 4
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %464 = load i32, i32* %50, align 4
LICM:     Invariant = "  %479 = icmp eq i32 %478, 1
LICM:       Checking dependences
LICM:         Dependent instruction = "  %478 = srem i32 %464, 2
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %478 = srem i32 %464, 2
LICM:     Invariant = "  %480 = sext i32 %470 to i64
LICM:       Checking dependences
LICM:         Dependent instruction = "  %470 = sub nsw i32 %469, %.pre.i
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %470 = sub nsw i32 %469, %.pre.i
LICM:     Invariant = "  %66 = load i32, i32* %42, align 4
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %67 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 1
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %68 = load i32, i32* %67, align 4, !tbaa !33
LICM:       Checking dependences
LICM:         Dependent instruction = "  %67 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 1
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %67 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 1
LICM:     Invariant = "  %69 = sext i32 %68 to i64
LICM:       Checking dependences
LICM:         Dependent instruction = "  %68 = load i32, i32* %67, align 4, !tbaa !33
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %68 = load i32, i32* %67, align 4, !tbaa !33
LICM:     Invariant = "  %.pre.i = load i32, i32* @fftblock, align 4
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %70 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 0
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %71 = load i32, i32* %70, align 8
LICM:       Checking dependences
LICM:         Dependent instruction = "  %70 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 0
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %70 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 0
LICM:     Invariant = "  %72 = sub nsw i32 %71, %.pre.i
LICM:       Checking dependences
LICM:         Dependent instruction = "  %.pre.i = load i32, i32* @fftblock, align 4
LICM:         Dependent instruction = "  %71 = load i32, i32* %70, align 8
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %.pre.i = load i32, i32* @fftblock, align 4
LICM:         %71 = load i32, i32* %70, align 8
LICM:     Invariant = "  %73 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 2
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %74 = load i32, i32* %73, align 8
LICM:       Checking dependences
LICM:         Dependent instruction = "  %73 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 2
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %73 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 2, i64 2
LICM:     Invariant = "  %75 = sext i32 %.pre.i to i64
LICM:       Checking dependences
LICM:         Dependent instruction = "  %.pre.i = load i32, i32* @fftblock, align 4
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %.pre.i = load i32, i32* @fftblock, align 4
LICM:     Invariant = "  %76 = sext i32 %74 to i64
LICM:       Checking dependences
LICM:         Dependent instruction = "  %74 = load i32, i32* %73, align 8
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %74 = load i32, i32* %73, align 8
LICM:     Invariant = "  %77 = getelementptr [512 x %struct.dcomplex], [512 x %struct.dcomplex]* @u, i64 0, i64 0, i32 0
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %78 = load double, double* %77, align 16
LICM:       Checking dependences
LICM:         Dependent instruction = "  %77 = getelementptr [512 x %struct.dcomplex], [512 x %struct.dcomplex]* @u, i64 0, i64 0, i32 0
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %77 = getelementptr [512 x %struct.dcomplex], [512 x %struct.dcomplex]* @u, i64 0, i64 0, i32 0
LICM:     Invariant = "  %79 = fptosi double %78 to i32
LICM:       Checking dependences
LICM:         Dependent instruction = "  %78 = load double, double* %77, align 16
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %78 = load double, double* %77, align 16
LICM:     Invariant = "  %80 = icmp slt i32 %66, 1
LICM:       Checking dependences
LICM:         Dependent instruction = "  %66 = load i32, i32* %42, align 4
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %66 = load i32, i32* %42, align 4
LICM:     Invariant = "  %81 = icmp sgt i32 %66, %79
LICM:       Checking dependences
LICM:         Dependent instruction = "  %66 = load i32, i32* %42, align 4
LICM:         Dependent instruction = "  %79 = fptosi double %78 to i32
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %66 = load i32, i32* %42, align 4
LICM:         %79 = fptosi double %78 to i32
LICM:     Invariant = "  %or.cond.i.i = or i1 %80, %81
LICM:       Checking dependences
LICM:         Dependent instruction = "  %81 = icmp sgt i32 %66, %79
LICM:         Dependent instruction = "  %80 = icmp slt i32 %66, 1
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %80 = icmp slt i32 %66, 1
LICM:         %81 = icmp sgt i32 %66, %79
LICM:     Invariant = "  %82 = sdiv i32 %74, 2
LICM:       Checking dependences
LICM:         Dependent instruction = "  %74 = load i32, i32* %73, align 8
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %74 = load i32, i32* %73, align 8
LICM:     Invariant = "  %83 = sext i32 %82 to i64
LICM:       Checking dependences
LICM:         Dependent instruction = "  %82 = sdiv i32 %74, 2
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %82 = sdiv i32 %74, 2
LICM:     Invariant = "  %84 = srem i32 %66, 2
LICM:       Checking dependences
LICM:         Dependent instruction = "  %66 = load i32, i32* %42, align 4
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %66 = load i32, i32* %42, align 4
LICM:     Invariant = "  %85 = icmp eq i32 %84, 1
LICM:       Checking dependences
LICM:         Dependent instruction = "  %84 = srem i32 %66, 2
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %84 = srem i32 %66, 2
LICM:     Invariant = "  %86 = sext i32 %72 to i64
LICM:       Checking dependences
LICM:         Dependent instruction = "  %72 = sub nsw i32 %71, %.pre.i
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %72 = sub nsw i32 %71, %.pre.i
LICM:     Invariant = "  %.b4 = load i1, i1* @niter, align 4
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %52 = select i1 %.b4, i32 20, i32 0, !prof !37
LICM:       Checking dependences
LICM:         Dependent instruction = "  %.b4 = load i1, i1* @niter, align 4
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %.b4 = load i1, i1* @niter, align 4
LICM:     Invariant = "  %658 = getelementptr [256 x [256 x [512 x %struct.dcomplex]]], [256 x [256 x [512 x %struct.dcomplex]]]* @main.u2, i64 0, i64 0
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %659 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 0, i64 0
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %267 = load i32, i32* %46, align 4
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %268 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 2
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %269 = load i32, i32* %268, align 4, !tbaa !33
LICM:       Checking dependences
LICM:         Dependent instruction = "  %268 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 2
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %268 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 2
LICM:     Invariant = "  %270 = sext i32 %269 to i64
LICM:       Checking dependences
LICM:         Dependent instruction = "  %269 = load i32, i32* %268, align 4, !tbaa !33
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %269 = load i32, i32* %268, align 4, !tbaa !33
LICM:     Invariant = "  %271 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 0
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %272 = load i32, i32* %271, align 4
LICM:       Checking dependences
LICM:         Dependent instruction = "  %271 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 0
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %271 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 0
LICM:     Invariant = "  %273 = sub nsw i32 %272, %.pre.i
LICM:       Checking dependences
LICM:         Dependent instruction = "  %272 = load i32, i32* %271, align 4
LICM:         Dependent instruction = "  %.pre.i = load i32, i32* @fftblock, align 4
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %.pre.i = load i32, i32* @fftblock, align 4
LICM:         %272 = load i32, i32* %271, align 4
LICM:     Invariant = "  %274 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 1
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %275 = load i32, i32* %274, align 4
LICM:       Checking dependences
LICM:         Dependent instruction = "  %274 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 1
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %274 = getelementptr [3 x [3 x i32]], [3 x [3 x i32]]* @dims, i64 0, i64 1, i64 1
LICM:     Invariant = "  %276 = sext i32 %275 to i64
LICM:       Checking dependences
LICM:         Dependent instruction = "  %275 = load i32, i32* %274, align 4
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %275 = load i32, i32* %274, align 4
LICM:     Invariant = "  %277 = icmp slt i32 %267, 1
LICM:       Checking dependences
LICM:         Dependent instruction = "  %267 = load i32, i32* %46, align 4
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %267 = load i32, i32* %46, align 4
LICM:     Invariant = "  %278 = icmp sgt i32 %267, %79
LICM:       Checking dependences
LICM:         Dependent instruction = "  %267 = load i32, i32* %46, align 4
LICM:         Dependent instruction = "  %79 = fptosi double %78 to i32
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %79 = fptosi double %78 to i32
LICM:         %267 = load i32, i32* %46, align 4
LICM:     Invariant = "  %or.cond.i.i12 = or i1 %277, %278
LICM:       Checking dependences
LICM:         Dependent instruction = "  %278 = icmp sgt i32 %267, %79
LICM:         Dependent instruction = "  %277 = icmp slt i32 %267, 1
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %277 = icmp slt i32 %267, 1
LICM:         %278 = icmp sgt i32 %267, %79
LICM:     Invariant = "  %279 = sdiv i32 %275, 2
LICM:       Checking dependences
LICM:         Dependent instruction = "  %275 = load i32, i32* %274, align 4
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %275 = load i32, i32* %274, align 4
LICM:     Invariant = "  %280 = sext i32 %279 to i64
LICM:       Checking dependences
LICM:         Dependent instruction = "  %279 = sdiv i32 %275, 2
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %279 = sdiv i32 %275, 2
LICM:     Invariant = "  %281 = srem i32 %267, 2
LICM:       Checking dependences
LICM:         Dependent instruction = "  %267 = load i32, i32* %46, align 4
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %267 = load i32, i32* %46, align 4
LICM:     Invariant = "  %282 = icmp eq i32 %281, 1
LICM:       Checking dependences
LICM:         Dependent instruction = "  %281 = srem i32 %267, 2
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %281 = srem i32 %267, 2
LICM:     Invariant = "  %283 = sext i32 %273 to i64
LICM:       Checking dependences
LICM:         Dependent instruction = "  %273 = sub nsw i32 %272, %.pre.i
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %273 = sub nsw i32 %272, %.pre.i
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:         Invariant   %52 = select i1 %.b4, i32 20, i32 0, !prof !37
LICM:           It can be hoisted
LICM:         Invariant   %68 = load i32, i32* %67, align 4, !tbaa !33
LICM:           It can be hoisted
LICM:         Invariant   %69 = sext i32 %68 to i64
LICM:           It can be hoisted
LICM:         Invariant   %71 = load i32, i32* %70, align 8
LICM:           It can be hoisted
LICM:         Invariant   %72 = sub nsw i32 %71, %.pre.i
LICM:           It can be hoisted
LICM:         Invariant   %74 = load i32, i32* %73, align 8
LICM:           It can be hoisted
LICM:         Invariant   %75 = sext i32 %.pre.i to i64
LICM:           It can be hoisted
LICM:         Invariant   %76 = sext i32 %74 to i64
LICM:           It can be hoisted
LICM:         Invariant   %78 = load double, double* %77, align 16
LICM:           It can be hoisted
LICM:         Invariant   %79 = fptosi double %78 to i32
LICM:           It can be hoisted
LICM:         Invariant   %80 = icmp slt i32 %66, 1
LICM:           It can be hoisted
LICM:         Invariant   %81 = icmp sgt i32 %66, %79
LICM:           It can be hoisted
LICM:         Invariant   %or.cond.i.i = or i1 %80, %81
LICM:           It can be hoisted
LICM:         Invariant   %82 = sdiv i32 %74, 2
LICM:           It can be hoisted
LICM:         Invariant   %83 = sext i32 %82 to i64
LICM:           It can be hoisted
LICM:         Invariant   %84 = srem i32 %66, 2
LICM:           It can be hoisted
LICM:         Invariant   %85 = icmp eq i32 %84, 1
LICM:           It can be hoisted
LICM:         Invariant   %86 = sext i32 %72 to i64
LICM:           It can be hoisted
LICM:         Invariant   %269 = load i32, i32* %268, align 4, !tbaa !33
LICM:           It can be hoisted
LICM:         Invariant   %270 = sext i32 %269 to i64
LICM:           It can be hoisted
LICM:         Invariant   %272 = load i32, i32* %271, align 4
LICM:           It can be hoisted
LICM:         Invariant   %273 = sub nsw i32 %272, %.pre.i
LICM:           It can be hoisted
LICM:         Invariant   %275 = load i32, i32* %274, align 4
LICM:           It can be hoisted
LICM:         Invariant   %276 = sext i32 %275 to i64
LICM:           It can be hoisted
LICM:         Invariant   %277 = icmp slt i32 %267, 1
LICM:           It can be hoisted
LICM:         Invariant   %278 = icmp sgt i32 %267, %79
LICM:           It can be hoisted
LICM:         Invariant   %or.cond.i.i12 = or i1 %277, %278
LICM:           It can be hoisted
LICM:         Invariant   %279 = sdiv i32 %275, 2
LICM:           It can be hoisted
LICM:         Invariant   %280 = sext i32 %279 to i64
LICM:           It can be hoisted
LICM:         Invariant   %281 = srem i32 %267, 2
LICM:           It can be hoisted
LICM:         Invariant   %282 = icmp eq i32 %281, 1
LICM:           It can be hoisted
LICM:         Invariant   %283 = sext i32 %273 to i64
LICM:           It can be hoisted
LICM:         Invariant   %466 = load i32, i32* %465, align 8, !tbaa !33
LICM:           It can be hoisted
LICM:         Invariant   %467 = sext i32 %466 to i64
LICM:           It can be hoisted
LICM:         Invariant   %469 = load i32, i32* %468, align 4
LICM:           It can be hoisted
LICM:         Invariant   %470 = sub nsw i32 %469, %.pre.i
LICM:           It can be hoisted
LICM:         Invariant   %472 = load i32, i32* %471, align 16
LICM:           It can be hoisted
LICM:         Invariant   %473 = sext i32 %472 to i64
LICM:           It can be hoisted
LICM:         Invariant   %474 = icmp slt i32 %464, 1
LICM:           It can be hoisted
LICM:         Invariant   %475 = icmp sgt i32 %464, %79
LICM:           It can be hoisted
LICM:         Invariant   %or.cond.i.i7 = or i1 %474, %475
LICM:           It can be hoisted
LICM:         Invariant   %476 = sdiv i32 %472, 2
LICM:           It can be hoisted
LICM:         Invariant   %477 = sext i32 %476 to i64
LICM:           It can be hoisted
LICM:         Invariant   %478 = srem i32 %464, 2
LICM:           It can be hoisted
LICM:         Invariant   %479 = icmp eq i32 %478, 1
LICM:           It can be hoisted
LICM:         Invariant   %480 = sext i32 %470 to i64
LICM:           It can be hoisted
LICM:   The loop has been modified
LICM: Exit
EnablersManager:       Loop invariants have been extracted
EnablersManager:   Loop:
EnablersManager:     Function = "cffts2"
EnablersManager:     Entry instruction =   %95 = icmp slt i64 %indvars.iv.i8.i, %30
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %95 = icmp slt i64 %indvars.iv.i8.i, %30"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %95, label %97, label %96, !prof !51
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts2"
EnablersManager:     Entry instruction =   %87 = icmp slt i64 %indvars.iv8.i6.i, %72
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %87 = icmp slt i64 %indvars.iv8.i6.i, %72"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %87, label %89, label %88, !prof !50
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts2"
EnablersManager:     Entry instruction =   %75 = icmp slt i64 %indvars.iv10.i4.i, %73
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %75 = icmp slt i64 %indvars.iv10.i4.i, %73"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %75, label %76, label %fftz2.exit20.i.loopexit, !prof !49
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts2"
EnablersManager:     Entry instruction =   %152 = icmp slt i64 %indvars.iv.i.i, %30
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %152 = icmp slt i64 %indvars.iv.i.i, %30"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %152, label %154, label %153, !prof !51
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts2"
EnablersManager:     Entry instruction =   %144 = icmp slt i64 %indvars.iv8.i.i, %129
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %144 = icmp slt i64 %indvars.iv8.i.i, %129"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %144, label %146, label %145, !prof !50
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts2"
EnablersManager:     Entry instruction =   %132 = icmp slt i64 %indvars.iv10.i.i, %130
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %132 = icmp slt i64 %indvars.iv10.i.i, %130"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %132, label %133, label %fftz2.exit.i.loopexit, !prof !49
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts2"
EnablersManager:     Entry instruction =   %63 = icmp slt i32 %21, %.0.i
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %63 = icmp slt i32 %21, %.0.i"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %63, label %.preheader.i..loopexit.i_crit_edge, label %.split.us.i5.i.preheader, !prof !47
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts2"
EnablersManager:     Entry instruction =   %194 = icmp slt i64 %indvars.iv9, %30
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %194 = icmp slt i64 %indvars.iv9, %30"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %194, label %195, label %207, !prof !41
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts2"
EnablersManager:     Entry instruction =   %193 = icmp slt i64 %indvars.iv11, %31
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %193 = icmp slt i64 %indvars.iv11, %31"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %193, label %.preheader.preheader, label %208, !prof !40
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts2"
EnablersManager:     Entry instruction =   %179 = icmp slt i64 %indvars.iv.i, %30
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %179 = icmp slt i64 %indvars.iv.i, %30"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %179, label %180, label %191, !prof !41
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts2"
EnablersManager:     Entry instruction =   %178 = icmp slt i64 %indvars.iv5.i, %31
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %178 = icmp slt i64 %indvars.iv5.i, %31"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %178, label %.preheader1.i.preheader, label %cfftz.exit.loopexit, !prof !54
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts2"
EnablersManager:     Entry instruction =   %46 = icmp slt i64 %indvars.iv, %30
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %46 = icmp slt i64 %indvars.iv, %30"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %46, label %47, label %60, !prof !41
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts2"
EnablersManager:     Entry instruction =   %45 = icmp slt i64 %indvars.iv7, %31
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %45 = icmp slt i64 %indvars.iv7, %31"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %45, label %.preheader1.preheader, label %LeafBlock7.i, !prof !40
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts2"
EnablersManager:     Entry instruction =   %44 = icmp sgt i64 %indvars.iv14, %41
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %44 = icmp sgt i64 %indvars.iv14, %41"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %44, label %209, label %.preheader7.preheader, !prof !39
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts2"
EnablersManager:     Entry instruction =   %43 = icmp slt i64 %indvars.iv13, %24
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %43 = icmp slt i64 %indvars.iv13, %24"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %43, label %.preheader8.preheader, label %210, !prof !38
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts3"
EnablersManager:     Entry instruction =   %97 = icmp slt i64 %indvars.iv.i8.i, %35
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %97 = icmp slt i64 %indvars.iv.i8.i, %35"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %97, label %99, label %98, !prof !51
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts3"
EnablersManager:     Entry instruction =   %89 = icmp slt i64 %indvars.iv8.i6.i, %74
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %89 = icmp slt i64 %indvars.iv8.i6.i, %74"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %89, label %91, label %90, !prof !50
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts3"
EnablersManager:     Entry instruction =   %77 = icmp slt i64 %indvars.iv10.i4.i, %75
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %77 = icmp slt i64 %indvars.iv10.i4.i, %75"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %77, label %78, label %fftz2.exit20.i.loopexit, !prof !49
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts3"
EnablersManager:     Entry instruction =   %154 = icmp slt i64 %indvars.iv.i.i, %35
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %154 = icmp slt i64 %indvars.iv.i.i, %35"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %154, label %156, label %155, !prof !51
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts3"
EnablersManager:     Entry instruction =   %146 = icmp slt i64 %indvars.iv8.i.i, %131
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %146 = icmp slt i64 %indvars.iv8.i.i, %131"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %146, label %148, label %147, !prof !50
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts3"
EnablersManager:     Entry instruction =   %134 = icmp slt i64 %indvars.iv10.i.i, %132
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %134 = icmp slt i64 %indvars.iv10.i.i, %132"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %134, label %135, label %fftz2.exit.i.loopexit, !prof !49
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts3"
EnablersManager:     Entry instruction =   %65 = icmp slt i32 %21, %.0.i
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %65 = icmp slt i32 %21, %.0.i"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %65, label %.preheader.i..loopexit.i_crit_edge, label %.split.us.i5.i.preheader, !prof !47
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts3"
EnablersManager:     Entry instruction =   %182 = icmp slt i64 %indvars.iv.i, %35
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %182 = icmp slt i64 %indvars.iv.i, %35"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %182, label %183, label %194, !prof !41
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts3"
EnablersManager:     Entry instruction =   %181 = icmp slt i64 %indvars.iv5.i, %29
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %181 = icmp slt i64 %indvars.iv5.i, %29"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %181, label %.preheader1.i.preheader, label %cfftz.exit.loopexit, !prof !54
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts3"
EnablersManager:     Entry instruction =   %197 = icmp slt i64 %indvars.iv9, %35
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %197 = icmp slt i64 %indvars.iv9, %35"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %197, label %198, label %210, !prof !41
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts3"
EnablersManager:     Entry instruction =   %196 = icmp slt i64 %indvars.iv11, %29
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %196 = icmp slt i64 %indvars.iv11, %29"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %196, label %.preheader.preheader, label %211, !prof !40
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts3"
EnablersManager:     Entry instruction =   %48 = icmp slt i64 %indvars.iv, %35
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %48 = icmp slt i64 %indvars.iv, %35"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %48, label %49, label %62, !prof !41
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts3"
EnablersManager:     Entry instruction =   %47 = icmp slt i64 %indvars.iv7, %29
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %47 = icmp slt i64 %indvars.iv7, %29"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %47, label %.preheader1.preheader, label %LeafBlock7._crit_edge.i, !prof !40
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts3"
EnablersManager:     Entry instruction =   %45 = icmp sgt i64 %indvars.iv12, %37
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %45 = icmp sgt i64 %indvars.iv12, %37"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %45, label %212, label %.preheader3, !prof !39
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts3"
EnablersManager:     Entry instruction =   %43 = icmp slt i64 %indvars.iv13, %24
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %43 = icmp slt i64 %indvars.iv13, %24"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %43, label %.preheader4, label %213, !prof !38
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts1"
EnablersManager:     Entry instruction =   %51 = icmp slt i64 %indvars.iv, %29
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %51 = icmp slt i64 %indvars.iv, %29"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %51, label %52, label %63, !prof !41
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts1"
EnablersManager:     Entry instruction =   %46 = icmp slt i64 %indvars.iv6, %36
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %46 = icmp slt i64 %indvars.iv6, %36"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %46, label %47, label %LeafBlock7._crit_edge.i, !prof !40
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts1"
EnablersManager:     Entry instruction =   %201 = icmp slt i64 %indvars.iv8, %29
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %201 = icmp slt i64 %indvars.iv8, %29"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %201, label %202, label %213, !prof !41
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts1"
EnablersManager:     Entry instruction =   %197 = icmp slt i64 %indvars.iv10, %36
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %197 = icmp slt i64 %indvars.iv10, %36"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %197, label %198, label %214, !prof !40
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts1"
EnablersManager:     Entry instruction =   %98 = icmp slt i64 %indvars.iv.i8.i, %36
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %98 = icmp slt i64 %indvars.iv.i8.i, %36"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %98, label %100, label %99, !prof !51
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts1"
EnablersManager:     Entry instruction =   %90 = icmp slt i64 %indvars.iv8.i6.i, %75
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %90 = icmp slt i64 %indvars.iv8.i6.i, %75"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %90, label %92, label %91, !prof !50
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts1"
EnablersManager:     Entry instruction =   %78 = icmp slt i64 %indvars.iv10.i4.i, %76
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %78 = icmp slt i64 %indvars.iv10.i4.i, %76"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %78, label %79, label %fftz2.exit20.i.loopexit, !prof !49
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts1"
EnablersManager:     Entry instruction =   %155 = icmp slt i64 %indvars.iv.i.i, %36
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %155 = icmp slt i64 %indvars.iv.i.i, %36"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %155, label %157, label %156, !prof !51
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts1"
EnablersManager:     Entry instruction =   %147 = icmp slt i64 %indvars.iv8.i.i, %132
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %147 = icmp slt i64 %indvars.iv8.i.i, %132"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %147, label %149, label %148, !prof !50
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts1"
EnablersManager:     Entry instruction =   %135 = icmp slt i64 %indvars.iv10.i.i, %133
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %135 = icmp slt i64 %indvars.iv10.i.i, %133"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %135, label %136, label %fftz2.exit.i.loopexit, !prof !49
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts1"
EnablersManager:     Entry instruction =   %66 = icmp slt i32 %21, %.0.i
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %66 = icmp slt i32 %21, %.0.i"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %66, label %.preheader.i..loopexit.i_crit_edge, label %.split.us.i5.i.preheader, !prof !47
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts1"
EnablersManager:     Entry instruction =   %183 = icmp slt i64 %indvars.iv.i, %36
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %183 = icmp slt i64 %indvars.iv.i, %36"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %183, label %184, label %195, !prof !55
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts1"
EnablersManager:     Entry instruction =   %182 = icmp slt i64 %indvars.iv5.i, %29
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %182 = icmp slt i64 %indvars.iv5.i, %29"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %182, label %.preheader1.i.preheader, label %cfftz.exit.loopexit, !prof !54
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts1"
EnablersManager:     Entry instruction =   %45 = icmp sgt i64 %indvars.iv11, %37
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %45 = icmp sgt i64 %indvars.iv11, %37"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %45, label %215, label %.preheader.preheader, !prof !39
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts1"
EnablersManager:     Entry instruction =   %43 = icmp slt i64 %indvars.iv12, %24
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %43 = icmp slt i64 %indvars.iv12, %24"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %43, label %.preheader3, label %216, !prof !38
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "evolve"
EnablersManager:     Entry instruction =   %18 = icmp slt i64 %indvars.iv, %14
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %18 = icmp slt i64 %indvars.iv, %14"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %18, label %19, label %34, !prof !39
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "evolve"
EnablersManager:     Entry instruction =   %17 = icmp slt i64 %indvars.iv3, %11
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %17 = icmp slt i64 %indvars.iv3, %11"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %17, label %.preheader.preheader, label %35, !prof !38
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "evolve"
EnablersManager:     Entry instruction =   %16 = icmp slt i64 %indvars.iv5, %8
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %16 = icmp slt i64 %indvars.iv5, %8"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %16, label %.preheader1.preheader, label %36, !prof !37
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "compute_initial_conditions"
EnablersManager:     Entry instruction =   %36 = icmp sgt i64 %indvars.iv.i, %24
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %36 = icmp sgt i64 %indvars.iv.i, %24"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %36, label %vranlc.exit.preheader, label %37, !prof !40
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "compute_initial_conditions"
EnablersManager:     Entry instruction =   %exitcond = icmp eq i64 %indvars.iv, 512
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond = icmp eq i64 %indvars.iv, 512"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond, label %77, label %65, !prof !42
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "compute_initial_conditions"
EnablersManager:     Entry instruction =   %61 = icmp slt i64 %indvars.iv6, %25
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %61 = icmp slt i64 %indvars.iv6, %25"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %61, label %62, label %78, !prof !41
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "compute_initial_conditions"
EnablersManager:     Entry instruction =   %34 = icmp slt i64 %indvars.iv8, %20
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %34 = icmp slt i64 %indvars.iv8, %20"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %34, label %.preheader, label %103, !prof !39
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "compute_indexmap"
EnablersManager:     Entry instruction =   %33 = icmp slt i64 %indvars.iv6, %12
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %33 = icmp slt i64 %indvars.iv6, %12"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %33, label %34, label %.loopexit.loopexit, !prof !39
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "compute_indexmap"
EnablersManager:     Entry instruction =   %23 = icmp slt i64 %indvars.iv8, %8
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %23 = icmp slt i64 %indvars.iv8, %8"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %23, label %24, label %.loopexit3.loopexit, !prof !38
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "compute_indexmap"
EnablersManager:     Entry instruction =   %15 = icmp slt i64 %indvars.iv10, %4
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %15 = icmp slt i64 %indvars.iv10, %4"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %15, label %16, label %43, !prof !37
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager: Exit
Noelle:  Function "main"
Noelle:     Loop "  %exitcond8 = icmp eq i32 %.02, 7" (8.669107e-09%)
Noelle:     Loop "  %exitcond = icmp eq i32 %.1, 7" (8.669107e-09%)
Noelle:     Loop "  %.b4 = load i1, i1* @niter, align 4" (4.793906e+01%)
Noelle:     Loop "  %exitcond.i = icmp eq i64 %indvars.iv15.i, 3" (5.590927e-07%)
Noelle:     Loop "  %88 = icmp slt i64 %indvars.iv13.i, %69" (1.794278e+01%)
Noelle:     Loop "  %89 = icmp sgt i64 %indvars.iv, %86" (1.794277e+01%)
Noelle:     Loop "  %90 = icmp slt i64 %indvars.iv7.i, %76" (1.785198e+00%)
Noelle:     Loop "  %91 = icmp slt i64 %indvars.iv.i, %75" (1.752578e+00%)
Noelle:     Loop "  %109 = icmp slt i32 %66, %.0.i.i" (1.393586e+01%)
Noelle:     Loop "  %122 = icmp slt i64 %indvars.iv16.i11.i.i, %120" (7.136336e+00%)
Noelle:     Loop "  %135 = icmp slt i64 %indvars.iv14.i13.i.i, %119" (7.082883e+00%)
Noelle:     Loop "  %142 = icmp slt i64 %indvars.iv12.i14.i.i, %75" (6.933954e+00%)
Noelle:     Loop "  %181 = icmp slt i64 %indvars.iv16.i.i.i, %179" (6.796510e+00%)
Noelle:     Loop "  %194 = icmp slt i64 %indvars.iv14.i.i.i, %178" (6.745603e+00%)
Noelle:     Loop "  %201 = icmp slt i64 %indvars.iv12.i.i.i, %75" (6.603765e+00%)
Noelle:     Loop "  %228 = icmp slt i64 %indvars.iv5.i.i, %76" (6.098883e-01%)
Noelle:     Loop "  %229 = icmp slt i64 %indvars.iv.i.i, %75" (5.968533e-01%)
Noelle:     Loop "  %243 = icmp slt i64 %indvars.iv11.i, %76" (1.611568e+00%)
Noelle:     Loop "  %244 = icmp slt i64 %indvars.iv9.i, %75" (1.578948e+00%)
Noelle:     Loop "  %exitcond.i2 = icmp eq i64 %indvars.iv15.i1, 3" (5.590927e-07%)
Noelle:     Loop "  %285 = icmp slt i64 %indvars.iv13.i4, %270" (1.794271e+01%)
Noelle:     Loop "  %286 = icmp sgt i64 %indvars.iv60, %283" (1.794271e+01%)
Noelle:     Loop "  %287 = icmp slt i64 %indvars.iv7.i7, %276" (1.785191e+00%)
Noelle:     Loop "  %288 = icmp slt i64 %indvars.iv.i9, %75" (1.752572e+00%)
Noelle:     Loop "  %306 = icmp slt i32 %267, %.0.i.i15" (1.393581e+01%)
Noelle:     Loop "  %319 = icmp slt i64 %indvars.iv16.i11.i.i20, %317" (7.136309e+00%)
Noelle:     Loop "  %332 = icmp slt i64 %indvars.iv14.i13.i.i22, %316" (7.082856e+00%)
Noelle:     Loop "  %339 = icmp slt i64 %indvars.iv12.i14.i.i23, %75" (6.933927e+00%)
Noelle:     Loop "  %378 = icmp slt i64 %indvars.iv16.i.i.i30, %376" (6.796484e+00%)
Noelle:     Loop "  %391 = icmp slt i64 %indvars.iv14.i.i.i32, %375" (6.745577e+00%)
Noelle:     Loop "  %398 = icmp slt i64 %indvars.iv12.i.i.i33, %75" (6.603740e+00%)
Noelle:     Loop "  %425 = icmp slt i64 %indvars.iv5.i.i40, %276" (6.098860e-01%)
Noelle:     Loop "  %426 = icmp slt i64 %indvars.iv.i.i42, %75" (5.968511e-01%)
Noelle:     Loop "  %440 = icmp slt i64 %indvars.iv11.i47, %276" (1.611561e+00%)
Noelle:     Loop "  %441 = icmp slt i64 %indvars.iv9.i49, %75" (1.578942e+00%)
Noelle:     Loop "  %exitcond.i1 = icmp eq i64 %indvars.iv14.i, 3" (5.590927e-07%)
Noelle:     Loop "  %482 = icmp slt i64 %indvars.iv12.i, %467" (1.022846e+01%)
Noelle:     Loop "  %483 = icmp sgt i64 %indvars.iv62, %480" (1.022845e+01%)
Noelle:     Loop "  %484 = icmp slt i64 %indvars.iv6.i, %75" (1.477914e+00%)
Noelle:     Loop "  %489 = icmp slt i64 %indvars.iv.i5, %473" (1.476356e+00%)
Noelle:     Loop "  %505 = icmp slt i32 %464, %.0.i.i10" (6.967890e+00%)
Noelle:     Loop "  %518 = icmp slt i64 %indvars.iv16.i11.i.i15, %516" (3.568147e+00%)
Noelle:     Loop "  %531 = icmp slt i64 %indvars.iv14.i13.i.i17, %515" (3.541421e+00%)
Noelle:     Loop "  %538 = icmp slt i64 %indvars.iv12.i14.i.i18, %75" (3.466957e+00%)
Noelle:     Loop "  %577 = icmp slt i64 %indvars.iv16.i.i.i25, %575" (3.398236e+00%)
Noelle:     Loop "  %590 = icmp slt i64 %indvars.iv14.i.i.i27, %574" (3.372782e+00%)
Noelle:     Loop "  %597 = icmp slt i64 %indvars.iv12.i.i.i28, %75" (3.301864e+00%)
Noelle:     Loop "  %624 = icmp slt i64 %indvars.iv5.i.i35, %473" (3.049424e-01%)
Noelle:     Loop "  %625 = icmp slt i64 %indvars.iv.i.i37, %75" (2.984250e-01%)
Noelle:     Loop "  %639 = icmp slt i64 %indvars.iv10.i, %75" (1.477574e+00%)
Noelle:     Loop "  %643 = icmp slt i64 %indvars.iv8.i, %473" (1.476356e+00%)
Noelle:  Function "fft"
Noelle:  Function "cffts3"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (2.386818e+09%)
Noelle:     Loop "  %43 = icmp slt i64 %indvars.iv13, %24" (1.973369e+01%)
Noelle:     Loop "  %45 = icmp sgt i64 %indvars.iv12, %37" (1.973368e+01%)
Noelle:     Loop "  %47 = icmp slt i64 %indvars.iv7, %29" (1.964093e+00%)
Noelle:     Loop "  %48 = icmp slt i64 %indvars.iv, %35" (1.928205e+00%)
Noelle:     Loop "  %65 = icmp slt i32 %21, %.0.i" (1.532524e+01%)
Noelle:     Loop "  %77 = icmp slt i64 %indvars.iv10.i4.i, %75" (7.847813e+00%)
Noelle:     Loop "  %89 = icmp slt i64 %indvars.iv8.i6.i, %74" (7.792661e+00%)
Noelle:     Loop "  %97 = icmp slt i64 %indvars.iv.i8.i, %35" (7.628807e+00%)
Noelle:     Loop "  %134 = icmp slt i64 %indvars.iv10.i.i, %132" (7.474108e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv8.i.i, %131" (7.421582e+00%)
Noelle:     Loop "  %154 = icmp slt i64 %indvars.iv.i.i, %35" (7.265531e+00%)
Noelle:     Loop "  %181 = icmp slt i64 %indvars.iv5.i, %29" (6.710054e-01%)
Noelle:     Loop "  %182 = icmp slt i64 %indvars.iv.i, %35" (6.566642e-01%)
Noelle:     Loop "  %196 = icmp slt i64 %indvars.iv11, %29" (1.773063e+00%)
Noelle:     Loop "  %197 = icmp slt i64 %indvars.iv9, %35" (1.737175e+00%)
Noelle:  Function "cffts2"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (6.149890e-07%)
Noelle:     Loop "  %43 = icmp slt i64 %indvars.iv13, %24" (1.973369e+01%)
Noelle:     Loop "  %44 = icmp sgt i64 %indvars.iv14, %41" (1.973368e+01%)
Noelle:     Loop "  %45 = icmp slt i64 %indvars.iv7, %31" (1.964093e+00%)
Noelle:     Loop "  %46 = icmp slt i64 %indvars.iv, %30" (1.928205e+00%)
Noelle:     Loop "  %63 = icmp slt i32 %21, %.0.i" (1.532524e+01%)
Noelle:     Loop "  %75 = icmp slt i64 %indvars.iv10.i4.i, %73" (7.847813e+00%)
Noelle:     Loop "  %87 = icmp slt i64 %indvars.iv8.i6.i, %72" (7.792661e+00%)
Noelle:     Loop "  %95 = icmp slt i64 %indvars.iv.i8.i, %30" (7.628807e+00%)
Noelle:     Loop "  %132 = icmp slt i64 %indvars.iv10.i.i, %130" (7.474108e+00%)
Noelle:     Loop "  %144 = icmp slt i64 %indvars.iv8.i.i, %129" (7.421582e+00%)
Noelle:     Loop "  %152 = icmp slt i64 %indvars.iv.i.i, %30" (7.265531e+00%)
Noelle:     Loop "  %178 = icmp slt i64 %indvars.iv5.i, %31" (6.710054e-01%)
Noelle:     Loop "  %179 = icmp slt i64 %indvars.iv.i, %30" (6.566642e-01%)
Noelle:     Loop "  %193 = icmp slt i64 %indvars.iv11, %31" (1.773063e+00%)
Noelle:     Loop "  %194 = icmp slt i64 %indvars.iv9, %30" (1.737175e+00%)
Noelle:  Function "cffts1"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv14, 3" (6.149890e-07%)
Noelle:     Loop "  %43 = icmp slt i64 %indvars.iv12, %24" (1.124997e+01%)
Noelle:     Loop "  %45 = icmp sgt i64 %indvars.iv11, %37" (1.124996e+01%)
Noelle:     Loop "  %46 = icmp slt i64 %indvars.iv6, %36" (1.626028e+00%)
Noelle:     Loop "  %51 = icmp slt i64 %indvars.iv, %29" (1.624314e+00%)
Noelle:     Loop "  %66 = icmp slt i32 %21, %.0.i" (7.662631e+00%)
Noelle:     Loop "  %78 = icmp slt i64 %indvars.iv10.i4.i, %76" (3.923913e+00%)
Noelle:     Loop "  %90 = icmp slt i64 %indvars.iv8.i6.i, %75" (3.896337e+00%)
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv.i8.i, %36" (3.814410e+00%)
Noelle:     Loop "  %135 = icmp slt i64 %indvars.iv10.i.i, %133" (3.737060e+00%)
Noelle:     Loop "  %147 = icmp slt i64 %indvars.iv8.i.i, %132" (3.710797e+00%)
Noelle:     Loop "  %155 = icmp slt i64 %indvars.iv.i.i, %36" (3.632771e+00%)
Noelle:     Loop "  %182 = icmp slt i64 %indvars.iv5.i, %29" (3.355033e-01%)
Noelle:     Loop "  %183 = icmp slt i64 %indvars.iv.i, %36" (3.283327e-01%)
Noelle:     Loop "  %197 = icmp slt i64 %indvars.iv10, %36" (1.625655e+00%)
Noelle:     Loop "  %201 = icmp slt i64 %indvars.iv8, %29" (1.624314e+00%)
Noelle:  Function "evolve"
Noelle:     Loop "  %16 = icmp slt i64 %indvars.iv5, %8" (1.825003e+00%)
Noelle:     Loop "  %17 = icmp slt i64 %indvars.iv3, %11" (1.824999e+00%)
Noelle:     Loop "  %18 = icmp slt i64 %indvars.iv, %14" (1.823979e+00%)
Noelle:  Function "compute_initial_conditions"
Noelle:     Loop "  %34 = icmp slt i64 %indvars.iv8, %20" (6.948935e-01%)
Noelle:     Loop "  %36 = icmp sgt i64 %indvars.iv.i, %24" (5.209898e-01%)
Noelle:     Loop "  %61 = icmp slt i64 %indvars.iv6, %25" (1.739015e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 512" (1.737317e-01%)
Noelle:  Function "vranlc"
Noelle:     Loop "  %13 = icmp sgt i64 %indvars.iv, %11" (5.209896e-01%)
Noelle:  Function "compute_indexmap"
Noelle:     Loop "  %15 = icmp slt i64 %indvars.iv10, %4" (1.221094e-01%)
Noelle:     Loop "  %23 = icmp slt i64 %indvars.iv8, %8" (1.221078e-01%)
Noelle:     Loop "  %33 = icmp slt i64 %indvars.iv6, %12" (1.216664e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 1966081" (5.597954e-03%)
Noelle:  Function "checksum"
Noelle:     Loop "  %exitcond = icmp eq i32 %.0, 1025" (1.113087e-04%)
Noelle:  Function "randlc"
Noelle:  Function "fft_init"
Noelle:     Loop "  %7 = icmp sgt i32 %.01, %2" (2.024431e-06%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count" (1.990530e-06%)
Noelle:  Function "ilog2"
Noelle:     Loop "  %3 = icmp slt i32 %.01, %0" (1.433120e-06%)
Noelle:  Function "ipow46"
Noelle:     Loop "  %11 = icmp sgt i32 %.01, 1" (1.918849e-07%)
Noelle:  Function "verify"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 21" (5.990741e-08%)
Noelle:  Function "setup"
Noelle:     Loop "  %exitcond3 = icmp eq i64 %indvars.iv1, 3" (4.658028e-09%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 3" (6.987041e-09%)
Noelle:  Function "elapsed_time"
Noelle:  Function "timer_clear"
Noelle:  Function "c_print_results"
Noelle:  Function "wtime_"
Noelle:  Function "timer_stop"
Noelle:  Function "timer_start"
Noelle:  Function "timer_read"
Noelle:  Function "main"
Noelle:     Loop "  %exitcond8 = icmp eq i32 %.02, 7" (8.669107e-09%)
Noelle:     Loop "  %exitcond = icmp eq i32 %.1, 7" (8.669107e-09%)
Noelle:     Loop "  %119 = icmp ugt i32 %.01, %52" (4.793906e+01%)
Noelle:     Loop "  %exitcond.i = icmp eq i64 %indvars.iv15.i, 3" (5.590927e-07%)
Noelle:     Loop "  %129 = icmp slt i64 %indvars.iv13.i, %60" (1.794278e+01%)
Noelle:     Loop "  %130 = icmp sgt i64 %indvars.iv, %79" (1.794277e+01%)
Noelle:     Loop "  %131 = icmp slt i64 %indvars.iv7.i, %68" (1.785198e+00%)
Noelle:     Loop "  %132 = icmp slt i64 %indvars.iv.i, %67" (1.752578e+00%)
Noelle:     Loop "  %150 = icmp slt i32 %57, %.0.i.i" (1.393586e+01%)
Noelle:     Loop "  %163 = icmp slt i64 %indvars.iv16.i11.i.i, %161" (7.136336e+00%)
Noelle:     Loop "  %176 = icmp slt i64 %indvars.iv14.i13.i.i, %160" (7.082883e+00%)
Noelle:     Loop "  %183 = icmp slt i64 %indvars.iv12.i14.i.i, %67" (6.933954e+00%)
Noelle:     Loop "  %222 = icmp slt i64 %indvars.iv16.i.i.i, %220" (6.796510e+00%)
Noelle:     Loop "  %235 = icmp slt i64 %indvars.iv14.i.i.i, %219" (6.745603e+00%)
Noelle:     Loop "  %242 = icmp slt i64 %indvars.iv12.i.i.i, %67" (6.603765e+00%)
Noelle:     Loop "  %269 = icmp slt i64 %indvars.iv5.i.i, %68" (6.098883e-01%)
Noelle:     Loop "  %270 = icmp slt i64 %indvars.iv.i.i, %67" (5.968533e-01%)
Noelle:     Loop "  %284 = icmp slt i64 %indvars.iv11.i, %68" (1.611568e+00%)
Noelle:     Loop "  %285 = icmp slt i64 %indvars.iv9.i, %67" (1.578948e+00%)
Noelle:     Loop "  %exitcond.i2 = icmp eq i64 %indvars.iv15.i1, 3" (5.590927e-07%)
Noelle:     Loop "  %309 = icmp slt i64 %indvars.iv13.i4, %83" (1.794271e+01%)
Noelle:     Loop "  %310 = icmp sgt i64 %indvars.iv60, %97" (1.794271e+01%)
Noelle:     Loop "  %311 = icmp slt i64 %indvars.iv7.i7, %89" (1.785191e+00%)
Noelle:     Loop "  %312 = icmp slt i64 %indvars.iv.i9, %67" (1.752572e+00%)
Noelle:     Loop "  %330 = icmp slt i32 %80, %.0.i.i15" (1.393581e+01%)
Noelle:     Loop "  %343 = icmp slt i64 %indvars.iv16.i11.i.i20, %341" (7.136309e+00%)
Noelle:     Loop "  %356 = icmp slt i64 %indvars.iv14.i13.i.i22, %340" (7.082856e+00%)
Noelle:     Loop "  %363 = icmp slt i64 %indvars.iv12.i14.i.i23, %67" (6.933927e+00%)
Noelle:     Loop "  %402 = icmp slt i64 %indvars.iv16.i.i.i30, %400" (6.796484e+00%)
Noelle:     Loop "  %415 = icmp slt i64 %indvars.iv14.i.i.i32, %399" (6.745577e+00%)
Noelle:     Loop "  %422 = icmp slt i64 %indvars.iv12.i.i.i33, %67" (6.603740e+00%)
Noelle:     Loop "  %449 = icmp slt i64 %indvars.iv5.i.i40, %89" (6.098860e-01%)
Noelle:     Loop "  %450 = icmp slt i64 %indvars.iv.i.i42, %67" (5.968511e-01%)
Noelle:     Loop "  %464 = icmp slt i64 %indvars.iv11.i47, %89" (1.611561e+00%)
Noelle:     Loop "  %465 = icmp slt i64 %indvars.iv9.i49, %67" (1.578942e+00%)
Noelle:     Loop "  %exitcond.i1 = icmp eq i64 %indvars.iv14.i, 3" (5.590927e-07%)
Noelle:     Loop "  %489 = icmp slt i64 %indvars.iv12.i, %101" (1.022846e+01%)
Noelle:     Loop "  %490 = icmp sgt i64 %indvars.iv62, %115" (1.022845e+01%)
Noelle:     Loop "  %491 = icmp slt i64 %indvars.iv6.i, %67" (1.477914e+00%)
Noelle:     Loop "  %496 = icmp slt i64 %indvars.iv.i5, %107" (1.476356e+00%)
Noelle:     Loop "  %512 = icmp slt i32 %98, %.0.i.i10" (6.967890e+00%)
Noelle:     Loop "  %525 = icmp slt i64 %indvars.iv16.i11.i.i15, %523" (3.568147e+00%)
Noelle:     Loop "  %538 = icmp slt i64 %indvars.iv14.i13.i.i17, %522" (3.541421e+00%)
Noelle:     Loop "  %545 = icmp slt i64 %indvars.iv12.i14.i.i18, %67" (3.466957e+00%)
Noelle:     Loop "  %584 = icmp slt i64 %indvars.iv16.i.i.i25, %582" (3.398236e+00%)
Noelle:     Loop "  %597 = icmp slt i64 %indvars.iv14.i.i.i27, %581" (3.372782e+00%)
Noelle:     Loop "  %604 = icmp slt i64 %indvars.iv12.i.i.i28, %67" (3.301864e+00%)
Noelle:     Loop "  %631 = icmp slt i64 %indvars.iv5.i.i35, %107" (3.049424e-01%)
Noelle:     Loop "  %632 = icmp slt i64 %indvars.iv.i.i37, %67" (2.984250e-01%)
Noelle:     Loop "  %646 = icmp slt i64 %indvars.iv10.i, %67" (1.477574e+00%)
Noelle:     Loop "  %650 = icmp slt i64 %indvars.iv8.i, %107" (1.476356e+00%)
Noelle:  Function "fft"
Noelle:  Function "cffts3"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (2.386818e+09%)
Noelle:     Loop "  %43 = icmp slt i64 %indvars.iv13, %24" (1.973369e+01%)
Noelle:     Loop "  %45 = icmp sgt i64 %indvars.iv12, %37" (1.973368e+01%)
Noelle:     Loop "  %47 = icmp slt i64 %indvars.iv7, %29" (1.964093e+00%)
Noelle:     Loop "  %48 = icmp slt i64 %indvars.iv, %35" (1.928205e+00%)
Noelle:     Loop "  %65 = icmp slt i32 %21, %.0.i" (1.532524e+01%)
Noelle:     Loop "  %77 = icmp slt i64 %indvars.iv10.i4.i, %75" (7.847813e+00%)
Noelle:     Loop "  %89 = icmp slt i64 %indvars.iv8.i6.i, %74" (7.792661e+00%)
Noelle:     Loop "  %97 = icmp slt i64 %indvars.iv.i8.i, %35" (7.628807e+00%)
Noelle:     Loop "  %134 = icmp slt i64 %indvars.iv10.i.i, %132" (7.474108e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv8.i.i, %131" (7.421582e+00%)
Noelle:     Loop "  %154 = icmp slt i64 %indvars.iv.i.i, %35" (7.265531e+00%)
Noelle:     Loop "  %181 = icmp slt i64 %indvars.iv5.i, %29" (6.710054e-01%)
Noelle:     Loop "  %182 = icmp slt i64 %indvars.iv.i, %35" (6.566642e-01%)
Noelle:     Loop "  %196 = icmp slt i64 %indvars.iv11, %29" (1.773063e+00%)
Noelle:     Loop "  %197 = icmp slt i64 %indvars.iv9, %35" (1.737175e+00%)
Noelle:  Function "cffts2"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (6.149890e-07%)
Noelle:     Loop "  %43 = icmp slt i64 %indvars.iv13, %24" (1.973369e+01%)
Noelle:     Loop "  %44 = icmp sgt i64 %indvars.iv14, %41" (1.973368e+01%)
Noelle:     Loop "  %45 = icmp slt i64 %indvars.iv7, %31" (1.964093e+00%)
Noelle:     Loop "  %46 = icmp slt i64 %indvars.iv, %30" (1.928205e+00%)
Noelle:     Loop "  %63 = icmp slt i32 %21, %.0.i" (1.532524e+01%)
Noelle:     Loop "  %75 = icmp slt i64 %indvars.iv10.i4.i, %73" (7.847813e+00%)
Noelle:     Loop "  %87 = icmp slt i64 %indvars.iv8.i6.i, %72" (7.792661e+00%)
Noelle:     Loop "  %95 = icmp slt i64 %indvars.iv.i8.i, %30" (7.628807e+00%)
Noelle:     Loop "  %132 = icmp slt i64 %indvars.iv10.i.i, %130" (7.474108e+00%)
Noelle:     Loop "  %144 = icmp slt i64 %indvars.iv8.i.i, %129" (7.421582e+00%)
Noelle:     Loop "  %152 = icmp slt i64 %indvars.iv.i.i, %30" (7.265531e+00%)
Noelle:     Loop "  %178 = icmp slt i64 %indvars.iv5.i, %31" (6.710054e-01%)
Noelle:     Loop "  %179 = icmp slt i64 %indvars.iv.i, %30" (6.566642e-01%)
Noelle:     Loop "  %193 = icmp slt i64 %indvars.iv11, %31" (1.773063e+00%)
Noelle:     Loop "  %194 = icmp slt i64 %indvars.iv9, %30" (1.737175e+00%)
Noelle:  Function "cffts1"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv14, 3" (6.149890e-07%)
Noelle:     Loop "  %43 = icmp slt i64 %indvars.iv12, %24" (1.124997e+01%)
Noelle:     Loop "  %45 = icmp sgt i64 %indvars.iv11, %37" (1.124996e+01%)
Noelle:     Loop "  %46 = icmp slt i64 %indvars.iv6, %36" (1.626028e+00%)
Noelle:     Loop "  %51 = icmp slt i64 %indvars.iv, %29" (1.624314e+00%)
Noelle:     Loop "  %66 = icmp slt i32 %21, %.0.i" (7.662631e+00%)
Noelle:     Loop "  %78 = icmp slt i64 %indvars.iv10.i4.i, %76" (3.923913e+00%)
Noelle:     Loop "  %90 = icmp slt i64 %indvars.iv8.i6.i, %75" (3.896337e+00%)
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv.i8.i, %36" (3.814410e+00%)
Noelle:     Loop "  %135 = icmp slt i64 %indvars.iv10.i.i, %133" (3.737060e+00%)
Noelle:     Loop "  %147 = icmp slt i64 %indvars.iv8.i.i, %132" (3.710797e+00%)
Noelle:     Loop "  %155 = icmp slt i64 %indvars.iv.i.i, %36" (3.632771e+00%)
Noelle:     Loop "  %182 = icmp slt i64 %indvars.iv5.i, %29" (3.355033e-01%)
Noelle:     Loop "  %183 = icmp slt i64 %indvars.iv.i, %36" (3.283327e-01%)
Noelle:     Loop "  %197 = icmp slt i64 %indvars.iv10, %36" (1.625655e+00%)
Noelle:     Loop "  %201 = icmp slt i64 %indvars.iv8, %29" (1.624314e+00%)
Noelle:  Function "evolve"
Noelle:     Loop "  %16 = icmp slt i64 %indvars.iv5, %8" (1.825003e+00%)
Noelle:     Loop "  %17 = icmp slt i64 %indvars.iv3, %11" (1.824999e+00%)
Noelle:     Loop "  %18 = icmp slt i64 %indvars.iv, %14" (1.823979e+00%)
Noelle:  Function "compute_initial_conditions"
Noelle:     Loop "  %34 = icmp slt i64 %indvars.iv8, %20" (6.948935e-01%)
Noelle:     Loop "  %36 = icmp sgt i64 %indvars.iv.i, %24" (5.209898e-01%)
Noelle:     Loop "  %61 = icmp slt i64 %indvars.iv6, %25" (1.739015e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 512" (1.737317e-01%)
Noelle:  Function "vranlc"
Noelle:     Loop "  %13 = icmp sgt i64 %indvars.iv, %11" (5.209896e-01%)
Noelle:  Function "compute_indexmap"
Noelle:     Loop "  %15 = icmp slt i64 %indvars.iv10, %4" (1.221094e-01%)
Noelle:     Loop "  %23 = icmp slt i64 %indvars.iv8, %8" (1.221078e-01%)
Noelle:     Loop "  %33 = icmp slt i64 %indvars.iv6, %12" (1.216664e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 1966081" (5.597954e-03%)
Noelle:  Function "checksum"
Noelle:     Loop "  %exitcond = icmp eq i32 %.0, 1025" (1.113087e-04%)
Noelle:  Function "randlc"
Noelle:  Function "fft_init"
Noelle:     Loop "  %7 = icmp sgt i32 %.01, %2" (2.024431e-06%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count" (1.990530e-06%)
Noelle:  Function "ilog2"
Noelle:     Loop "  %3 = icmp slt i32 %.01, %0" (1.433120e-06%)
Noelle:  Function "ipow46"
Noelle:     Loop "  %11 = icmp sgt i32 %.01, 1" (1.918849e-07%)
Noelle:  Function "verify"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 21" (5.990741e-08%)
Noelle:  Function "setup"
Noelle:     Loop "  %exitcond3 = icmp eq i64 %indvars.iv1, 3" (4.658028e-09%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 3" (6.987041e-09%)
Noelle:  Function "elapsed_time"
Noelle:  Function "timer_clear"
Noelle:  Function "c_print_results"
Noelle:  Function "wtime_"
Noelle:  Function "timer_stop"
Noelle:  Function "timer_start"
Noelle:  Function "timer_read"
NOELLE: FixedPoint:       There are 0 different instructions and -67 different loop instructions
NOELLE: FixedPoint:       Normalize the code
noelle-norm /tmp/tmp.9OghPd0qQO -o /tmp/tmp.9OghPd0qQO
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.9OghPd0qQO -o /tmp/tmp.9OghPd0qQO
NOELLE: FixedPoint:     Invocation 1
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.gjuMhYkPPD -o /tmp/tmp.9OghPd0qQO
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.gjuMhYkPPD -o /tmp/tmp.9OghPd0qQO
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.gjuMhYkPPD -o /tmp/tmp.9OghPd0qQO
EnablersManager: Start
Noelle: Filter out cold code
Noelle:  Function "main"
Noelle:     Loop "  %exitcond8 = icmp eq i32 %.02, 7" (8.669107e-09%)
Noelle:  Disable loop "0" as cold code
Noelle:     Loop "  %exitcond = icmp eq i32 %.1, 7" (8.669107e-09%)
Noelle:  Disable loop "1" as cold code
Noelle:     Loop "  %exitcond1 = icmp eq i32 %.01, %118" (4.793906e+01%)
Noelle:     Loop "  %exitcond.i = icmp eq i64 %indvars.iv15.i, 3" (5.590927e-07%)
Noelle:  Disable loop "3" as cold code
Noelle:     Loop "  %129 = icmp slt i64 %indvars.iv13.i, %60" (1.794278e+01%)
Noelle:     Loop "  %130 = icmp sgt i64 %indvars.iv, %79" (1.794277e+01%)
Noelle:     Loop "  %131 = icmp slt i64 %indvars.iv7.i, %68" (1.785198e+00%)
Noelle:     Loop "  %132 = icmp slt i64 %indvars.iv.i, %67" (1.752578e+00%)
Noelle:     Loop "  %150 = icmp slt i32 %57, %.0.i.i" (1.393586e+01%)
Noelle:     Loop "  %163 = icmp slt i64 %indvars.iv16.i11.i.i, %161" (7.136336e+00%)
Noelle:     Loop "  %176 = icmp slt i64 %indvars.iv14.i13.i.i, %160" (7.082883e+00%)
Noelle:     Loop "  %183 = icmp slt i64 %indvars.iv12.i14.i.i, %67" (6.933954e+00%)
Noelle:     Loop "  %222 = icmp slt i64 %indvars.iv16.i.i.i, %220" (6.796510e+00%)
Noelle:     Loop "  %235 = icmp slt i64 %indvars.iv14.i.i.i, %219" (6.745603e+00%)
Noelle:     Loop "  %242 = icmp slt i64 %indvars.iv12.i.i.i, %67" (6.603765e+00%)
Noelle:     Loop "  %269 = icmp slt i64 %indvars.iv5.i.i, %68" (6.098883e-01%)
Noelle:     Loop "  %270 = icmp slt i64 %indvars.iv.i.i, %67" (5.968533e-01%)
Noelle:     Loop "  %284 = icmp slt i64 %indvars.iv11.i, %68" (1.611568e+00%)
Noelle:     Loop "  %285 = icmp slt i64 %indvars.iv9.i, %67" (1.578948e+00%)
Noelle:     Loop "  %exitcond.i2 = icmp eq i64 %indvars.iv15.i1, 3" (5.590927e-07%)
Noelle:  Disable loop "19" as cold code
Noelle:     Loop "  %309 = icmp slt i64 %indvars.iv13.i4, %83" (1.794271e+01%)
Noelle:     Loop "  %310 = icmp sgt i64 %indvars.iv60, %97" (1.794271e+01%)
Noelle:     Loop "  %311 = icmp slt i64 %indvars.iv7.i7, %89" (1.785191e+00%)
Noelle:     Loop "  %312 = icmp slt i64 %indvars.iv.i9, %67" (1.752572e+00%)
Noelle:     Loop "  %330 = icmp slt i32 %80, %.0.i.i15" (1.393581e+01%)
Noelle:     Loop "  %343 = icmp slt i64 %indvars.iv16.i11.i.i20, %341" (7.136309e+00%)
Noelle:     Loop "  %356 = icmp slt i64 %indvars.iv14.i13.i.i22, %340" (7.082856e+00%)
Noelle:     Loop "  %363 = icmp slt i64 %indvars.iv12.i14.i.i23, %67" (6.933927e+00%)
Noelle:     Loop "  %402 = icmp slt i64 %indvars.iv16.i.i.i30, %400" (6.796484e+00%)
Noelle:     Loop "  %415 = icmp slt i64 %indvars.iv14.i.i.i32, %399" (6.745577e+00%)
Noelle:     Loop "  %422 = icmp slt i64 %indvars.iv12.i.i.i33, %67" (6.603740e+00%)
Noelle:     Loop "  %449 = icmp slt i64 %indvars.iv5.i.i40, %89" (6.098860e-01%)
Noelle:     Loop "  %450 = icmp slt i64 %indvars.iv.i.i42, %67" (5.968511e-01%)
Noelle:     Loop "  %464 = icmp slt i64 %indvars.iv11.i47, %89" (1.611561e+00%)
Noelle:     Loop "  %465 = icmp slt i64 %indvars.iv9.i49, %67" (1.578942e+00%)
Noelle:     Loop "  %exitcond.i1 = icmp eq i64 %indvars.iv14.i, 3" (5.590927e-07%)
Noelle:  Disable loop "35" as cold code
Noelle:     Loop "  %489 = icmp slt i64 %indvars.iv12.i, %101" (1.022846e+01%)
Noelle:     Loop "  %490 = icmp sgt i64 %indvars.iv62, %115" (1.022845e+01%)
Noelle:     Loop "  %491 = icmp slt i64 %indvars.iv6.i, %67" (1.477914e+00%)
Noelle:     Loop "  %496 = icmp slt i64 %indvars.iv.i5, %107" (1.476356e+00%)
Noelle:     Loop "  %512 = icmp slt i32 %98, %.0.i.i10" (6.967890e+00%)
Noelle:     Loop "  %525 = icmp slt i64 %indvars.iv16.i11.i.i15, %523" (3.568147e+00%)
Noelle:     Loop "  %538 = icmp slt i64 %indvars.iv14.i13.i.i17, %522" (3.541421e+00%)
Noelle:     Loop "  %545 = icmp slt i64 %indvars.iv12.i14.i.i18, %67" (3.466957e+00%)
Noelle:     Loop "  %584 = icmp slt i64 %indvars.iv16.i.i.i25, %582" (3.398236e+00%)
Noelle:     Loop "  %597 = icmp slt i64 %indvars.iv14.i.i.i27, %581" (3.372782e+00%)
Noelle:     Loop "  %604 = icmp slt i64 %indvars.iv12.i.i.i28, %67" (3.301864e+00%)
Noelle:     Loop "  %631 = icmp slt i64 %indvars.iv5.i.i35, %107" (3.049424e-01%)
Noelle:     Loop "  %632 = icmp slt i64 %indvars.iv.i.i37, %67" (2.984250e-01%)
Noelle:     Loop "  %646 = icmp slt i64 %indvars.iv10.i, %67" (1.477574e+00%)
Noelle:     Loop "  %650 = icmp slt i64 %indvars.iv8.i, %107" (1.476356e+00%)
Noelle:  Function "fft"
Noelle:  Function "cffts2"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (6.149890e-07%)
Noelle:  Disable loop "51" as cold code
Noelle:     Loop "  %43 = icmp slt i64 %indvars.iv13, %24" (1.973369e+01%)
Noelle:     Loop "  %44 = icmp sgt i64 %indvars.iv14, %41" (1.973368e+01%)
Noelle:     Loop "  %45 = icmp slt i64 %indvars.iv7, %31" (1.964093e+00%)
Noelle:     Loop "  %46 = icmp slt i64 %indvars.iv, %30" (1.928205e+00%)
Noelle:     Loop "  %63 = icmp slt i32 %21, %.0.i" (1.532524e+01%)
Noelle:     Loop "  %75 = icmp slt i64 %indvars.iv10.i4.i, %73" (7.847813e+00%)
Noelle:     Loop "  %87 = icmp slt i64 %indvars.iv8.i6.i, %72" (7.792661e+00%)
Noelle:     Loop "  %95 = icmp slt i64 %indvars.iv.i8.i, %30" (7.628807e+00%)
Noelle:     Loop "  %132 = icmp slt i64 %indvars.iv10.i.i, %130" (7.474108e+00%)
Noelle:     Loop "  %144 = icmp slt i64 %indvars.iv8.i.i, %129" (7.421582e+00%)
Noelle:     Loop "  %152 = icmp slt i64 %indvars.iv.i.i, %30" (7.265531e+00%)
Noelle:     Loop "  %178 = icmp slt i64 %indvars.iv5.i, %31" (6.710054e-01%)
Noelle:     Loop "  %179 = icmp slt i64 %indvars.iv.i, %30" (6.566642e-01%)
Noelle:     Loop "  %193 = icmp slt i64 %indvars.iv11, %31" (1.773063e+00%)
Noelle:     Loop "  %194 = icmp slt i64 %indvars.iv9, %30" (1.737175e+00%)
Noelle:  Function "cffts3"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (2.386818e+09%)
Noelle:     Loop "  %43 = icmp slt i64 %indvars.iv13, %24" (1.973369e+01%)
Noelle:     Loop "  %45 = icmp sgt i64 %indvars.iv12, %37" (1.973368e+01%)
Noelle:     Loop "  %47 = icmp slt i64 %indvars.iv7, %29" (1.964093e+00%)
Noelle:     Loop "  %48 = icmp slt i64 %indvars.iv, %35" (1.928205e+00%)
Noelle:     Loop "  %65 = icmp slt i32 %21, %.0.i" (1.532524e+01%)
Noelle:     Loop "  %77 = icmp slt i64 %indvars.iv10.i4.i, %75" (7.847813e+00%)
Noelle:     Loop "  %89 = icmp slt i64 %indvars.iv8.i6.i, %74" (7.792661e+00%)
Noelle:     Loop "  %97 = icmp slt i64 %indvars.iv.i8.i, %35" (7.628807e+00%)
Noelle:     Loop "  %134 = icmp slt i64 %indvars.iv10.i.i, %132" (7.474108e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv8.i.i, %131" (7.421582e+00%)
Noelle:     Loop "  %154 = icmp slt i64 %indvars.iv.i.i, %35" (7.265531e+00%)
Noelle:     Loop "  %181 = icmp slt i64 %indvars.iv5.i, %29" (6.710054e-01%)
Noelle:     Loop "  %182 = icmp slt i64 %indvars.iv.i, %35" (6.566642e-01%)
Noelle:     Loop "  %196 = icmp slt i64 %indvars.iv11, %29" (1.773063e+00%)
Noelle:     Loop "  %197 = icmp slt i64 %indvars.iv9, %35" (1.737175e+00%)
Noelle:  Function "cffts1"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv14, 3" (6.149890e-07%)
Noelle:  Disable loop "83" as cold code
Noelle:     Loop "  %43 = icmp slt i64 %indvars.iv12, %24" (1.124997e+01%)
Noelle:     Loop "  %45 = icmp sgt i64 %indvars.iv11, %37" (1.124996e+01%)
Noelle:     Loop "  %46 = icmp slt i64 %indvars.iv6, %36" (1.626028e+00%)
Noelle:     Loop "  %51 = icmp slt i64 %indvars.iv, %29" (1.624314e+00%)
Noelle:     Loop "  %66 = icmp slt i32 %21, %.0.i" (7.662631e+00%)
Noelle:     Loop "  %78 = icmp slt i64 %indvars.iv10.i4.i, %76" (3.923913e+00%)
Noelle:     Loop "  %90 = icmp slt i64 %indvars.iv8.i6.i, %75" (3.896337e+00%)
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv.i8.i, %36" (3.814410e+00%)
Noelle:     Loop "  %135 = icmp slt i64 %indvars.iv10.i.i, %133" (3.737060e+00%)
Noelle:     Loop "  %147 = icmp slt i64 %indvars.iv8.i.i, %132" (3.710797e+00%)
Noelle:     Loop "  %155 = icmp slt i64 %indvars.iv.i.i, %36" (3.632771e+00%)
Noelle:     Loop "  %182 = icmp slt i64 %indvars.iv5.i, %29" (3.355033e-01%)
Noelle:     Loop "  %183 = icmp slt i64 %indvars.iv.i, %36" (3.283327e-01%)
Noelle:     Loop "  %197 = icmp slt i64 %indvars.iv10, %36" (1.625655e+00%)
Noelle:     Loop "  %201 = icmp slt i64 %indvars.iv8, %29" (1.624314e+00%)
Noelle:  Function "evolve"
Noelle:     Loop "  %16 = icmp slt i64 %indvars.iv5, %8" (1.825003e+00%)
Noelle:     Loop "  %17 = icmp slt i64 %indvars.iv3, %11" (1.824999e+00%)
Noelle:     Loop "  %18 = icmp slt i64 %indvars.iv, %14" (1.823979e+00%)
Noelle:  Function "compute_initial_conditions"
Noelle:     Loop "  %34 = icmp slt i64 %indvars.iv8, %20" (6.948935e-01%)
Noelle:     Loop "  %36 = icmp sgt i64 %indvars.iv.i, %24" (5.209898e-01%)
Noelle:     Loop "  %61 = icmp slt i64 %indvars.iv6, %25" (1.739015e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 512" (1.737317e-01%)
Noelle:  Function "compute_indexmap"
Noelle:     Loop "  %15 = icmp slt i64 %indvars.iv10, %4" (1.221094e-01%)
Noelle:     Loop "  %23 = icmp slt i64 %indvars.iv8, %8" (1.221078e-01%)
Noelle:     Loop "  %33 = icmp slt i64 %indvars.iv6, %12" (1.216664e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 1966081" (5.597954e-03%)
Noelle:  Disable loop "109" as cold code
Noelle:  Function "checksum"
Noelle:  Disable "checksum" as cold function
Noelle:  Function "randlc"
Noelle:  Disable "randlc" as cold function
Noelle:  Function "fft_init"
Noelle:  Disable "fft_init" as cold function
Noelle:  Function "ilog2"
Noelle:  Disable "ilog2" as cold function
Noelle:  Function "ipow46"
Noelle:  Disable "ipow46" as cold function
Noelle:  Function "verify"
Noelle:  Disable "verify" as cold function
Noelle:  Function "setup"
Noelle:  Disable "setup" as cold function
Noelle:  Function "elapsed_time"
Noelle:  Disable "elapsed_time" as cold function
Noelle:  Function "timer_clear"
Noelle:  Disable "timer_clear" as cold function
Noelle:  Function "c_print_results"
Noelle:  Disable "c_print_results" as cold function
Noelle:  Function "wtime_"
Noelle:  Disable "wtime_" as cold function
Noelle:  Function "timer_stop"
Noelle:  Disable "timer_stop" as cold function
Noelle:  Function "timer_start"
Noelle:  Disable "timer_start" as cold function
Noelle:  Function "timer_read"
Noelle:  Disable "timer_read" as cold function
EnablersManager:   Try to improve all 102 loops, one at a time
EnablersManager:   Loop:
EnablersManager:     Function = "cffts3"
EnablersManager:     Entry instruction =   %exitcond = icmp eq i64 %indvars.iv15, 3
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond, label %17, label %12, !prof !33
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %465 = icmp slt i64 %indvars.iv9.i49, %67
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %465 = icmp slt i64 %indvars.iv9.i49, %67"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %465, label %466, label %478, !prof !43
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %464 = icmp slt i64 %indvars.iv11.i47, %89
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %464 = icmp slt i64 %indvars.iv11.i47, %89"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %464, label %.preheader.i48.preheader, label %479, !prof !42
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %450 = icmp slt i64 %indvars.iv.i.i42, %67
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %450 = icmp slt i64 %indvars.iv.i.i42, %67"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %450, label %451, label %462, !prof !43
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %449 = icmp slt i64 %indvars.iv5.i.i40, %89
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %449 = icmp slt i64 %indvars.iv5.i.i40, %89"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %449, label %.preheader1.i.i41.preheader, label %cfftz.exit.i46.loopexit, !prof !56
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %312 = icmp slt i64 %indvars.iv.i9, %67
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %312 = icmp slt i64 %indvars.iv.i9, %67"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %312, label %313, label %326, !prof !43
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %311 = icmp slt i64 %indvars.iv7.i7, %89
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %311 = icmp slt i64 %indvars.iv7.i7, %89"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %311, label %.preheader1.i8.preheader, label %327, !prof !42
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %363 = icmp slt i64 %indvars.iv12.i14.i.i23, %67
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %363 = icmp slt i64 %indvars.iv12.i14.i.i23, %67"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %363, label %364, label %387, !prof !53
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %356 = icmp slt i64 %indvars.iv14.i13.i.i22, %340
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %356 = icmp slt i64 %indvars.iv14.i13.i.i22, %340"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %356, label %357, label %388, !prof !52
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %343 = icmp slt i64 %indvars.iv16.i11.i.i20, %341
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %343 = icmp slt i64 %indvars.iv16.i11.i.i20, %341"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %343, label %344, label %.us-lcssa.us.loopexit1.i19.i.i27, !prof !51
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %422 = icmp slt i64 %indvars.iv12.i.i.i33, %67
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %422 = icmp slt i64 %indvars.iv12.i.i.i33, %67"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %422, label %423, label %446, !prof !53
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %415 = icmp slt i64 %indvars.iv14.i.i.i32, %399
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %415 = icmp slt i64 %indvars.iv14.i.i.i32, %399"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %415, label %416, label %447, !prof !52
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %402 = icmp slt i64 %indvars.iv16.i.i.i30, %400
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %402 = icmp slt i64 %indvars.iv16.i.i.i30, %400"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %402, label %403, label %.us-lcssa.us.loopexit1.i.i.i37, !prof !51
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %330 = icmp slt i32 %80, %.0.i.i15
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %330 = icmp slt i32 %80, %.0.i.i15"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %330, label %.preheader.i.i16..loopexit.i.i38_crit_edge, label %331, !prof !49
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %310 = icmp sgt i64 %indvars.iv60, %97
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %310 = icmp sgt i64 %indvars.iv60, %97"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %310, label %480, label %.preheader14.preheader, !prof !41
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %309 = icmp slt i64 %indvars.iv13.i4, %83
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %309 = icmp slt i64 %indvars.iv13.i4, %83"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %309, label %.preheader18.preheader, label %cffts2.exit, !prof !40
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %242 = icmp slt i64 %indvars.iv12.i.i.i, %67
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %242 = icmp slt i64 %indvars.iv12.i.i.i, %67"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %242, label %243, label %266, !prof !53
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %235 = icmp slt i64 %indvars.iv14.i.i.i, %219
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %235 = icmp slt i64 %indvars.iv14.i.i.i, %219"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %235, label %236, label %267, !prof !52
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %222 = icmp slt i64 %indvars.iv16.i.i.i, %220
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %222 = icmp slt i64 %indvars.iv16.i.i.i, %220"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %222, label %223, label %.us-lcssa.us.loopexit1.i.i.i, !prof !51
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %183 = icmp slt i64 %indvars.iv12.i14.i.i, %67
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %183 = icmp slt i64 %indvars.iv12.i14.i.i, %67"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %183, label %184, label %207, !prof !53
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %176 = icmp slt i64 %indvars.iv14.i13.i.i, %160
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %176 = icmp slt i64 %indvars.iv14.i13.i.i, %160"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %176, label %177, label %208, !prof !52
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %163 = icmp slt i64 %indvars.iv16.i11.i.i, %161
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %163 = icmp slt i64 %indvars.iv16.i11.i.i, %161"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %163, label %164, label %.us-lcssa.us.loopexit1.i19.i.i, !prof !51
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %150 = icmp slt i32 %57, %.0.i.i
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %150 = icmp slt i32 %57, %.0.i.i"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %150, label %.preheader.i.i..loopexit.i.i_crit_edge, label %151, !prof !49
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %270 = icmp slt i64 %indvars.iv.i.i, %67
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %270 = icmp slt i64 %indvars.iv.i.i, %67"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %270, label %271, label %282, !prof !43
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %269 = icmp slt i64 %indvars.iv5.i.i, %68
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %269 = icmp slt i64 %indvars.iv5.i.i, %68"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %269, label %.preheader1.i.i.preheader, label %cfftz.exit.i.loopexit, !prof !56
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %132 = icmp slt i64 %indvars.iv.i, %67
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %132 = icmp slt i64 %indvars.iv.i, %67"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %132, label %133, label %146, !prof !43
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %131 = icmp slt i64 %indvars.iv7.i, %68
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %131 = icmp slt i64 %indvars.iv7.i, %68"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %131, label %.preheader1.i.preheader, label %147, !prof !42
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %285 = icmp slt i64 %indvars.iv9.i, %67
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %285 = icmp slt i64 %indvars.iv9.i, %67"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %285, label %286, label %298, !prof !43
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %284 = icmp slt i64 %indvars.iv11.i, %68
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %284 = icmp slt i64 %indvars.iv11.i, %68"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %284, label %.preheader.i.preheader, label %299, !prof !42
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %130 = icmp sgt i64 %indvars.iv, %79
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %130 = icmp sgt i64 %indvars.iv, %79"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %130, label %300, label %.preheader16.preheader, !prof !41
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %129 = icmp slt i64 %indvars.iv13.i, %60
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %129 = icmp slt i64 %indvars.iv13.i, %60"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %129, label %.preheader19.preheader, label %cffts3.exit, !prof !40
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %545 = icmp slt i64 %indvars.iv12.i14.i.i18, %67
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %545 = icmp slt i64 %indvars.iv12.i14.i.i18, %67"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %545, label %546, label %569, !prof !53
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %538 = icmp slt i64 %indvars.iv14.i13.i.i17, %522
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %538 = icmp slt i64 %indvars.iv14.i13.i.i17, %522"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %538, label %539, label %570, !prof !52
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %525 = icmp slt i64 %indvars.iv16.i11.i.i15, %523
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %525 = icmp slt i64 %indvars.iv16.i11.i.i15, %523"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %525, label %526, label %.us-lcssa.us.loopexit1.i19.i.i22, !prof !51
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %604 = icmp slt i64 %indvars.iv12.i.i.i28, %67
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %604 = icmp slt i64 %indvars.iv12.i.i.i28, %67"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %604, label %605, label %628, !prof !53
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %597 = icmp slt i64 %indvars.iv14.i.i.i27, %581
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %597 = icmp slt i64 %indvars.iv14.i.i.i27, %581"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %597, label %598, label %629, !prof !52
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %584 = icmp slt i64 %indvars.iv16.i.i.i25, %582
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %584 = icmp slt i64 %indvars.iv16.i.i.i25, %582"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %584, label %585, label %.us-lcssa.us.loopexit1.i.i.i32, !prof !51
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %512 = icmp slt i32 %98, %.0.i.i10
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %512 = icmp slt i32 %98, %.0.i.i10"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %512, label %.preheader.i.i11..loopexit.i.i33_crit_edge, label %513, !prof !49
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %496 = icmp slt i64 %indvars.iv.i5, %107
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %496 = icmp slt i64 %indvars.iv.i5, %107"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %496, label %497, label %508, !prof !59
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %491 = icmp slt i64 %indvars.iv6.i, %67
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %491 = icmp slt i64 %indvars.iv6.i, %67"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %491, label %492, label %509, !prof !58
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %650 = icmp slt i64 %indvars.iv8.i, %107
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %650 = icmp slt i64 %indvars.iv8.i, %107"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %650, label %651, label %662, !prof !59
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %646 = icmp slt i64 %indvars.iv10.i, %67
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %646 = icmp slt i64 %indvars.iv10.i, %67"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %646, label %647, label %663, !prof !58
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %632 = icmp slt i64 %indvars.iv.i.i37, %67
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %632 = icmp slt i64 %indvars.iv.i.i37, %67"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %632, label %633, label %644, !prof !43
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %631 = icmp slt i64 %indvars.iv5.i.i35, %107
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %631 = icmp slt i64 %indvars.iv5.i.i35, %107"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %631, label %.preheader1.i.i36.preheader, label %cfftz.exit.i41.loopexit, !prof !56
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %490 = icmp sgt i64 %indvars.iv62, %115
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %490 = icmp sgt i64 %indvars.iv62, %115"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %490, label %664, label %.preheader.i4.preheader, !prof !57
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %489 = icmp slt i64 %indvars.iv12.i, %101
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %489 = icmp slt i64 %indvars.iv12.i, %101"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %489, label %.preheader17.preheader, label %cffts1.exit, !prof !40
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %exitcond1 = icmp eq i32 %.01, %118
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i8, align 1
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %11 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [3 x i32], align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca [3 x i32], align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [3 x i32], align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca [3 x i32], align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca [3 x i32], align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca [3 x i32], align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %7 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16 can be cloned
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond1 = icmp eq i32 %.01, %118"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond1, label %666, label %120, !prof !38
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts2"
EnablersManager:     Entry instruction =   %46 = icmp slt i64 %indvars.iv, %30
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %46 = icmp slt i64 %indvars.iv, %30"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %46, label %47, label %60, !prof !41
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts2"
EnablersManager:     Entry instruction =   %45 = icmp slt i64 %indvars.iv7, %31
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %45 = icmp slt i64 %indvars.iv7, %31"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %45, label %.preheader1.preheader, label %LeafBlock7.i, !prof !40
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts2"
EnablersManager:     Entry instruction =   %95 = icmp slt i64 %indvars.iv.i8.i, %30
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %95 = icmp slt i64 %indvars.iv.i8.i, %30"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %95, label %97, label %96, !prof !51
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts2"
EnablersManager:     Entry instruction =   %87 = icmp slt i64 %indvars.iv8.i6.i, %72
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %87 = icmp slt i64 %indvars.iv8.i6.i, %72"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %87, label %89, label %88, !prof !50
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts2"
EnablersManager:     Entry instruction =   %75 = icmp slt i64 %indvars.iv10.i4.i, %73
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %75 = icmp slt i64 %indvars.iv10.i4.i, %73"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %75, label %76, label %fftz2.exit20.i.loopexit, !prof !49
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts2"
EnablersManager:     Entry instruction =   %152 = icmp slt i64 %indvars.iv.i.i, %30
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %152 = icmp slt i64 %indvars.iv.i.i, %30"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %152, label %154, label %153, !prof !51
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts2"
EnablersManager:     Entry instruction =   %144 = icmp slt i64 %indvars.iv8.i.i, %129
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %144 = icmp slt i64 %indvars.iv8.i.i, %129"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %144, label %146, label %145, !prof !50
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts2"
EnablersManager:     Entry instruction =   %132 = icmp slt i64 %indvars.iv10.i.i, %130
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %132 = icmp slt i64 %indvars.iv10.i.i, %130"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %132, label %133, label %fftz2.exit.i.loopexit, !prof !49
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts2"
EnablersManager:     Entry instruction =   %63 = icmp slt i32 %21, %.0.i
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %63 = icmp slt i32 %21, %.0.i"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %63, label %.preheader.i..loopexit.i_crit_edge, label %.split.us.i5.i.preheader, !prof !47
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts2"
EnablersManager:     Entry instruction =   %179 = icmp slt i64 %indvars.iv.i, %30
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %179 = icmp slt i64 %indvars.iv.i, %30"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %179, label %180, label %191, !prof !41
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts2"
EnablersManager:     Entry instruction =   %178 = icmp slt i64 %indvars.iv5.i, %31
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %178 = icmp slt i64 %indvars.iv5.i, %31"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %178, label %.preheader1.i.preheader, label %cfftz.exit.loopexit, !prof !54
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts2"
EnablersManager:     Entry instruction =   %194 = icmp slt i64 %indvars.iv9, %30
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %194 = icmp slt i64 %indvars.iv9, %30"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %194, label %195, label %207, !prof !41
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts2"
EnablersManager:     Entry instruction =   %193 = icmp slt i64 %indvars.iv11, %31
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %193 = icmp slt i64 %indvars.iv11, %31"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %193, label %.preheader.preheader, label %208, !prof !40
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts2"
EnablersManager:     Entry instruction =   %44 = icmp sgt i64 %indvars.iv14, %41
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %44 = icmp sgt i64 %indvars.iv14, %41"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %44, label %209, label %.preheader7.preheader, !prof !39
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts2"
EnablersManager:     Entry instruction =   %43 = icmp slt i64 %indvars.iv13, %24
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %43 = icmp slt i64 %indvars.iv13, %24"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %43, label %.preheader8.preheader, label %210, !prof !38
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts3"
EnablersManager:     Entry instruction =   %97 = icmp slt i64 %indvars.iv.i8.i, %35
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %97 = icmp slt i64 %indvars.iv.i8.i, %35"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %97, label %99, label %98, !prof !51
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts3"
EnablersManager:     Entry instruction =   %89 = icmp slt i64 %indvars.iv8.i6.i, %74
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %89 = icmp slt i64 %indvars.iv8.i6.i, %74"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %89, label %91, label %90, !prof !50
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts3"
EnablersManager:     Entry instruction =   %77 = icmp slt i64 %indvars.iv10.i4.i, %75
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %77 = icmp slt i64 %indvars.iv10.i4.i, %75"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %77, label %78, label %fftz2.exit20.i.loopexit, !prof !49
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts3"
EnablersManager:     Entry instruction =   %154 = icmp slt i64 %indvars.iv.i.i, %35
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %154 = icmp slt i64 %indvars.iv.i.i, %35"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %154, label %156, label %155, !prof !51
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts3"
EnablersManager:     Entry instruction =   %146 = icmp slt i64 %indvars.iv8.i.i, %131
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %146 = icmp slt i64 %indvars.iv8.i.i, %131"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %146, label %148, label %147, !prof !50
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts3"
EnablersManager:     Entry instruction =   %134 = icmp slt i64 %indvars.iv10.i.i, %132
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %134 = icmp slt i64 %indvars.iv10.i.i, %132"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %134, label %135, label %fftz2.exit.i.loopexit, !prof !49
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts3"
EnablersManager:     Entry instruction =   %65 = icmp slt i32 %21, %.0.i
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %65 = icmp slt i32 %21, %.0.i"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %65, label %.preheader.i..loopexit.i_crit_edge, label %.split.us.i5.i.preheader, !prof !47
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts3"
EnablersManager:     Entry instruction =   %48 = icmp slt i64 %indvars.iv, %35
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %48 = icmp slt i64 %indvars.iv, %35"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %48, label %49, label %62, !prof !41
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts3"
EnablersManager:     Entry instruction =   %47 = icmp slt i64 %indvars.iv7, %29
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %47 = icmp slt i64 %indvars.iv7, %29"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %47, label %.preheader1.preheader, label %LeafBlock7._crit_edge.i, !prof !40
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts3"
EnablersManager:     Entry instruction =   %197 = icmp slt i64 %indvars.iv9, %35
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %197 = icmp slt i64 %indvars.iv9, %35"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %197, label %198, label %210, !prof !41
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts3"
EnablersManager:     Entry instruction =   %196 = icmp slt i64 %indvars.iv11, %29
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %196 = icmp slt i64 %indvars.iv11, %29"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %196, label %.preheader.preheader, label %211, !prof !40
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts3"
EnablersManager:     Entry instruction =   %182 = icmp slt i64 %indvars.iv.i, %35
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %182 = icmp slt i64 %indvars.iv.i, %35"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %182, label %183, label %194, !prof !41
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts3"
EnablersManager:     Entry instruction =   %181 = icmp slt i64 %indvars.iv5.i, %29
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %181 = icmp slt i64 %indvars.iv5.i, %29"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %181, label %.preheader1.i.preheader, label %cfftz.exit.loopexit, !prof !54
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts3"
EnablersManager:     Entry instruction =   %45 = icmp sgt i64 %indvars.iv12, %37
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %45 = icmp sgt i64 %indvars.iv12, %37"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %45, label %212, label %.preheader3, !prof !39
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts3"
EnablersManager:     Entry instruction =   %43 = icmp slt i64 %indvars.iv13, %24
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %43 = icmp slt i64 %indvars.iv13, %24"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %43, label %.preheader4, label %213, !prof !38
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts1"
EnablersManager:     Entry instruction =   %51 = icmp slt i64 %indvars.iv, %29
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %51 = icmp slt i64 %indvars.iv, %29"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %51, label %52, label %63, !prof !41
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts1"
EnablersManager:     Entry instruction =   %46 = icmp slt i64 %indvars.iv6, %36
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %46 = icmp slt i64 %indvars.iv6, %36"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %46, label %47, label %LeafBlock7._crit_edge.i, !prof !40
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts1"
EnablersManager:     Entry instruction =   %201 = icmp slt i64 %indvars.iv8, %29
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %201 = icmp slt i64 %indvars.iv8, %29"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %201, label %202, label %213, !prof !41
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts1"
EnablersManager:     Entry instruction =   %197 = icmp slt i64 %indvars.iv10, %36
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %197 = icmp slt i64 %indvars.iv10, %36"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %197, label %198, label %214, !prof !40
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts1"
EnablersManager:     Entry instruction =   %183 = icmp slt i64 %indvars.iv.i, %36
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %183 = icmp slt i64 %indvars.iv.i, %36"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %183, label %184, label %195, !prof !55
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts1"
EnablersManager:     Entry instruction =   %182 = icmp slt i64 %indvars.iv5.i, %29
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %182 = icmp slt i64 %indvars.iv5.i, %29"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %182, label %.preheader1.i.preheader, label %cfftz.exit.loopexit, !prof !54
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts1"
EnablersManager:     Entry instruction =   %98 = icmp slt i64 %indvars.iv.i8.i, %36
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %98 = icmp slt i64 %indvars.iv.i8.i, %36"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %98, label %100, label %99, !prof !51
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts1"
EnablersManager:     Entry instruction =   %90 = icmp slt i64 %indvars.iv8.i6.i, %75
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %90 = icmp slt i64 %indvars.iv8.i6.i, %75"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %90, label %92, label %91, !prof !50
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts1"
EnablersManager:     Entry instruction =   %78 = icmp slt i64 %indvars.iv10.i4.i, %76
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %78 = icmp slt i64 %indvars.iv10.i4.i, %76"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %78, label %79, label %fftz2.exit20.i.loopexit, !prof !49
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts1"
EnablersManager:     Entry instruction =   %155 = icmp slt i64 %indvars.iv.i.i, %36
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %155 = icmp slt i64 %indvars.iv.i.i, %36"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %155, label %157, label %156, !prof !51
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts1"
EnablersManager:     Entry instruction =   %147 = icmp slt i64 %indvars.iv8.i.i, %132
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %147 = icmp slt i64 %indvars.iv8.i.i, %132"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %147, label %149, label %148, !prof !50
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts1"
EnablersManager:     Entry instruction =   %135 = icmp slt i64 %indvars.iv10.i.i, %133
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %135 = icmp slt i64 %indvars.iv10.i.i, %133"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %135, label %136, label %fftz2.exit.i.loopexit, !prof !49
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts1"
EnablersManager:     Entry instruction =   %66 = icmp slt i32 %21, %.0.i
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %66 = icmp slt i32 %21, %.0.i"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %66, label %.preheader.i..loopexit.i_crit_edge, label %.split.us.i5.i.preheader, !prof !47
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts1"
EnablersManager:     Entry instruction =   %45 = icmp sgt i64 %indvars.iv11, %37
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %45 = icmp sgt i64 %indvars.iv11, %37"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %45, label %215, label %.preheader.preheader, !prof !39
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "cffts1"
EnablersManager:     Entry instruction =   %43 = icmp slt i64 %indvars.iv12, %24
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %43 = icmp slt i64 %indvars.iv12, %24"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %43, label %.preheader3, label %216, !prof !38
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "evolve"
EnablersManager:     Entry instruction =   %18 = icmp slt i64 %indvars.iv, %14
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %18 = icmp slt i64 %indvars.iv, %14"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %18, label %19, label %34, !prof !39
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "evolve"
EnablersManager:     Entry instruction =   %17 = icmp slt i64 %indvars.iv3, %11
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %17 = icmp slt i64 %indvars.iv3, %11"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %17, label %.preheader.preheader, label %35, !prof !38
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "evolve"
EnablersManager:     Entry instruction =   %16 = icmp slt i64 %indvars.iv5, %8
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %16 = icmp slt i64 %indvars.iv5, %8"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %16, label %.preheader1.preheader, label %36, !prof !37
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "compute_initial_conditions"
EnablersManager:     Entry instruction =   %36 = icmp sgt i64 %indvars.iv.i, %24
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %36 = icmp sgt i64 %indvars.iv.i, %24"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %36, label %vranlc.exit.preheader, label %37, !prof !40
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "compute_initial_conditions"
EnablersManager:     Entry instruction =   %exitcond = icmp eq i64 %indvars.iv, 512
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond = icmp eq i64 %indvars.iv, 512"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond, label %77, label %65, !prof !42
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "compute_initial_conditions"
EnablersManager:     Entry instruction =   %61 = icmp slt i64 %indvars.iv6, %25
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %61 = icmp slt i64 %indvars.iv6, %25"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %61, label %62, label %78, !prof !41
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "compute_initial_conditions"
EnablersManager:     Entry instruction =   %34 = icmp slt i64 %indvars.iv8, %20
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %34 = icmp slt i64 %indvars.iv8, %20"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %34, label %.preheader, label %103, !prof !39
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "compute_indexmap"
EnablersManager:     Entry instruction =   %33 = icmp slt i64 %indvars.iv6, %12
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %33 = icmp slt i64 %indvars.iv6, %12"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %33, label %34, label %.loopexit.loopexit, !prof !39
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "compute_indexmap"
EnablersManager:     Entry instruction =   %23 = icmp slt i64 %indvars.iv8, %8
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %23 = icmp slt i64 %indvars.iv8, %8"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %23, label %24, label %.loopexit3.loopexit, !prof !38
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "compute_indexmap"
EnablersManager:     Entry instruction =   %15 = icmp slt i64 %indvars.iv10, %4
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %15 = icmp slt i64 %indvars.iv10, %4"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %15, label %16, label %43, !prof !37
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager: Exit
Noelle:  Function "main"
Noelle:     Loop "  %exitcond8 = icmp eq i32 %.02, 7" (8.669107e-09%)
Noelle:     Loop "  %exitcond = icmp eq i32 %.1, 7" (8.669107e-09%)
Noelle:     Loop "  %exitcond1 = icmp eq i32 %.01, %118" (4.793906e+01%)
Noelle:     Loop "  %exitcond.i = icmp eq i64 %indvars.iv15.i, 3" (5.590927e-07%)
Noelle:     Loop "  %129 = icmp slt i64 %indvars.iv13.i, %60" (1.794278e+01%)
Noelle:     Loop "  %130 = icmp sgt i64 %indvars.iv, %79" (1.794277e+01%)
Noelle:     Loop "  %131 = icmp slt i64 %indvars.iv7.i, %68" (1.785198e+00%)
Noelle:     Loop "  %132 = icmp slt i64 %indvars.iv.i, %67" (1.752578e+00%)
Noelle:     Loop "  %150 = icmp slt i32 %57, %.0.i.i" (1.393586e+01%)
Noelle:     Loop "  %163 = icmp slt i64 %indvars.iv16.i11.i.i, %161" (7.136336e+00%)
Noelle:     Loop "  %176 = icmp slt i64 %indvars.iv14.i13.i.i, %160" (7.082883e+00%)
Noelle:     Loop "  %183 = icmp slt i64 %indvars.iv12.i14.i.i, %67" (6.933954e+00%)
Noelle:     Loop "  %222 = icmp slt i64 %indvars.iv16.i.i.i, %220" (6.796510e+00%)
Noelle:     Loop "  %235 = icmp slt i64 %indvars.iv14.i.i.i, %219" (6.745603e+00%)
Noelle:     Loop "  %242 = icmp slt i64 %indvars.iv12.i.i.i, %67" (6.603765e+00%)
Noelle:     Loop "  %269 = icmp slt i64 %indvars.iv5.i.i, %68" (6.098883e-01%)
Noelle:     Loop "  %270 = icmp slt i64 %indvars.iv.i.i, %67" (5.968533e-01%)
Noelle:     Loop "  %284 = icmp slt i64 %indvars.iv11.i, %68" (1.611568e+00%)
Noelle:     Loop "  %285 = icmp slt i64 %indvars.iv9.i, %67" (1.578948e+00%)
Noelle:     Loop "  %exitcond.i2 = icmp eq i64 %indvars.iv15.i1, 3" (5.590927e-07%)
Noelle:     Loop "  %309 = icmp slt i64 %indvars.iv13.i4, %83" (1.794271e+01%)
Noelle:     Loop "  %310 = icmp sgt i64 %indvars.iv60, %97" (1.794271e+01%)
Noelle:     Loop "  %311 = icmp slt i64 %indvars.iv7.i7, %89" (1.785191e+00%)
Noelle:     Loop "  %312 = icmp slt i64 %indvars.iv.i9, %67" (1.752572e+00%)
Noelle:     Loop "  %330 = icmp slt i32 %80, %.0.i.i15" (1.393581e+01%)
Noelle:     Loop "  %343 = icmp slt i64 %indvars.iv16.i11.i.i20, %341" (7.136309e+00%)
Noelle:     Loop "  %356 = icmp slt i64 %indvars.iv14.i13.i.i22, %340" (7.082856e+00%)
Noelle:     Loop "  %363 = icmp slt i64 %indvars.iv12.i14.i.i23, %67" (6.933927e+00%)
Noelle:     Loop "  %402 = icmp slt i64 %indvars.iv16.i.i.i30, %400" (6.796484e+00%)
Noelle:     Loop "  %415 = icmp slt i64 %indvars.iv14.i.i.i32, %399" (6.745577e+00%)
Noelle:     Loop "  %422 = icmp slt i64 %indvars.iv12.i.i.i33, %67" (6.603740e+00%)
Noelle:     Loop "  %449 = icmp slt i64 %indvars.iv5.i.i40, %89" (6.098860e-01%)
Noelle:     Loop "  %450 = icmp slt i64 %indvars.iv.i.i42, %67" (5.968511e-01%)
Noelle:     Loop "  %464 = icmp slt i64 %indvars.iv11.i47, %89" (1.611561e+00%)
Noelle:     Loop "  %465 = icmp slt i64 %indvars.iv9.i49, %67" (1.578942e+00%)
Noelle:     Loop "  %exitcond.i1 = icmp eq i64 %indvars.iv14.i, 3" (5.590927e-07%)
Noelle:     Loop "  %489 = icmp slt i64 %indvars.iv12.i, %101" (1.022846e+01%)
Noelle:     Loop "  %490 = icmp sgt i64 %indvars.iv62, %115" (1.022845e+01%)
Noelle:     Loop "  %491 = icmp slt i64 %indvars.iv6.i, %67" (1.477914e+00%)
Noelle:     Loop "  %496 = icmp slt i64 %indvars.iv.i5, %107" (1.476356e+00%)
Noelle:     Loop "  %512 = icmp slt i32 %98, %.0.i.i10" (6.967890e+00%)
Noelle:     Loop "  %525 = icmp slt i64 %indvars.iv16.i11.i.i15, %523" (3.568147e+00%)
Noelle:     Loop "  %538 = icmp slt i64 %indvars.iv14.i13.i.i17, %522" (3.541421e+00%)
Noelle:     Loop "  %545 = icmp slt i64 %indvars.iv12.i14.i.i18, %67" (3.466957e+00%)
Noelle:     Loop "  %584 = icmp slt i64 %indvars.iv16.i.i.i25, %582" (3.398236e+00%)
Noelle:     Loop "  %597 = icmp slt i64 %indvars.iv14.i.i.i27, %581" (3.372782e+00%)
Noelle:     Loop "  %604 = icmp slt i64 %indvars.iv12.i.i.i28, %67" (3.301864e+00%)
Noelle:     Loop "  %631 = icmp slt i64 %indvars.iv5.i.i35, %107" (3.049424e-01%)
Noelle:     Loop "  %632 = icmp slt i64 %indvars.iv.i.i37, %67" (2.984250e-01%)
Noelle:     Loop "  %646 = icmp slt i64 %indvars.iv10.i, %67" (1.477574e+00%)
Noelle:     Loop "  %650 = icmp slt i64 %indvars.iv8.i, %107" (1.476356e+00%)
Noelle:  Function "fft"
Noelle:  Function "cffts3"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (2.386818e+09%)
Noelle:     Loop "  %43 = icmp slt i64 %indvars.iv13, %24" (1.973369e+01%)
Noelle:     Loop "  %45 = icmp sgt i64 %indvars.iv12, %37" (1.973368e+01%)
Noelle:     Loop "  %47 = icmp slt i64 %indvars.iv7, %29" (1.964093e+00%)
Noelle:     Loop "  %48 = icmp slt i64 %indvars.iv, %35" (1.928205e+00%)
Noelle:     Loop "  %65 = icmp slt i32 %21, %.0.i" (1.532524e+01%)
Noelle:     Loop "  %77 = icmp slt i64 %indvars.iv10.i4.i, %75" (7.847813e+00%)
Noelle:     Loop "  %89 = icmp slt i64 %indvars.iv8.i6.i, %74" (7.792661e+00%)
Noelle:     Loop "  %97 = icmp slt i64 %indvars.iv.i8.i, %35" (7.628807e+00%)
Noelle:     Loop "  %134 = icmp slt i64 %indvars.iv10.i.i, %132" (7.474108e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv8.i.i, %131" (7.421582e+00%)
Noelle:     Loop "  %154 = icmp slt i64 %indvars.iv.i.i, %35" (7.265531e+00%)
Noelle:     Loop "  %181 = icmp slt i64 %indvars.iv5.i, %29" (6.710054e-01%)
Noelle:     Loop "  %182 = icmp slt i64 %indvars.iv.i, %35" (6.566642e-01%)
Noelle:     Loop "  %196 = icmp slt i64 %indvars.iv11, %29" (1.773063e+00%)
Noelle:     Loop "  %197 = icmp slt i64 %indvars.iv9, %35" (1.737175e+00%)
Noelle:  Function "cffts2"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (6.149890e-07%)
Noelle:     Loop "  %43 = icmp slt i64 %indvars.iv13, %24" (1.973369e+01%)
Noelle:     Loop "  %44 = icmp sgt i64 %indvars.iv14, %41" (1.973368e+01%)
Noelle:     Loop "  %45 = icmp slt i64 %indvars.iv7, %31" (1.964093e+00%)
Noelle:     Loop "  %46 = icmp slt i64 %indvars.iv, %30" (1.928205e+00%)
Noelle:     Loop "  %63 = icmp slt i32 %21, %.0.i" (1.532524e+01%)
Noelle:     Loop "  %75 = icmp slt i64 %indvars.iv10.i4.i, %73" (7.847813e+00%)
Noelle:     Loop "  %87 = icmp slt i64 %indvars.iv8.i6.i, %72" (7.792661e+00%)
Noelle:     Loop "  %95 = icmp slt i64 %indvars.iv.i8.i, %30" (7.628807e+00%)
Noelle:     Loop "  %132 = icmp slt i64 %indvars.iv10.i.i, %130" (7.474108e+00%)
Noelle:     Loop "  %144 = icmp slt i64 %indvars.iv8.i.i, %129" (7.421582e+00%)
Noelle:     Loop "  %152 = icmp slt i64 %indvars.iv.i.i, %30" (7.265531e+00%)
Noelle:     Loop "  %178 = icmp slt i64 %indvars.iv5.i, %31" (6.710054e-01%)
Noelle:     Loop "  %179 = icmp slt i64 %indvars.iv.i, %30" (6.566642e-01%)
Noelle:     Loop "  %193 = icmp slt i64 %indvars.iv11, %31" (1.773063e+00%)
Noelle:     Loop "  %194 = icmp slt i64 %indvars.iv9, %30" (1.737175e+00%)
Noelle:  Function "cffts1"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv14, 3" (6.149890e-07%)
Noelle:     Loop "  %43 = icmp slt i64 %indvars.iv12, %24" (1.124997e+01%)
Noelle:     Loop "  %45 = icmp sgt i64 %indvars.iv11, %37" (1.124996e+01%)
Noelle:     Loop "  %46 = icmp slt i64 %indvars.iv6, %36" (1.626028e+00%)
Noelle:     Loop "  %51 = icmp slt i64 %indvars.iv, %29" (1.624314e+00%)
Noelle:     Loop "  %66 = icmp slt i32 %21, %.0.i" (7.662631e+00%)
Noelle:     Loop "  %78 = icmp slt i64 %indvars.iv10.i4.i, %76" (3.923913e+00%)
Noelle:     Loop "  %90 = icmp slt i64 %indvars.iv8.i6.i, %75" (3.896337e+00%)
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv.i8.i, %36" (3.814410e+00%)
Noelle:     Loop "  %135 = icmp slt i64 %indvars.iv10.i.i, %133" (3.737060e+00%)
Noelle:     Loop "  %147 = icmp slt i64 %indvars.iv8.i.i, %132" (3.710797e+00%)
Noelle:     Loop "  %155 = icmp slt i64 %indvars.iv.i.i, %36" (3.632771e+00%)
Noelle:     Loop "  %182 = icmp slt i64 %indvars.iv5.i, %29" (3.355033e-01%)
Noelle:     Loop "  %183 = icmp slt i64 %indvars.iv.i, %36" (3.283327e-01%)
Noelle:     Loop "  %197 = icmp slt i64 %indvars.iv10, %36" (1.625655e+00%)
Noelle:     Loop "  %201 = icmp slt i64 %indvars.iv8, %29" (1.624314e+00%)
Noelle:  Function "evolve"
Noelle:     Loop "  %16 = icmp slt i64 %indvars.iv5, %8" (1.825003e+00%)
Noelle:     Loop "  %17 = icmp slt i64 %indvars.iv3, %11" (1.824999e+00%)
Noelle:     Loop "  %18 = icmp slt i64 %indvars.iv, %14" (1.823979e+00%)
Noelle:  Function "compute_initial_conditions"
Noelle:     Loop "  %34 = icmp slt i64 %indvars.iv8, %20" (6.948935e-01%)
Noelle:     Loop "  %36 = icmp sgt i64 %indvars.iv.i, %24" (5.209898e-01%)
Noelle:     Loop "  %61 = icmp slt i64 %indvars.iv6, %25" (1.739015e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 512" (1.737317e-01%)
Noelle:  Function "vranlc"
Noelle:     Loop "  %13 = icmp sgt i64 %indvars.iv, %11" (5.209896e-01%)
Noelle:  Function "compute_indexmap"
Noelle:     Loop "  %15 = icmp slt i64 %indvars.iv10, %4" (1.221094e-01%)
Noelle:     Loop "  %23 = icmp slt i64 %indvars.iv8, %8" (1.221078e-01%)
Noelle:     Loop "  %33 = icmp slt i64 %indvars.iv6, %12" (1.216664e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 1966081" (5.597954e-03%)
Noelle:  Function "checksum"
Noelle:     Loop "  %exitcond = icmp eq i32 %.0, 1025" (1.113087e-04%)
Noelle:  Function "randlc"
Noelle:  Function "fft_init"
Noelle:     Loop "  %7 = icmp sgt i32 %.01, %2" (2.024431e-06%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count" (1.990530e-06%)
Noelle:  Function "ilog2"
Noelle:     Loop "  %3 = icmp slt i32 %.01, %0" (1.433120e-06%)
Noelle:  Function "ipow46"
Noelle:     Loop "  %11 = icmp sgt i32 %.01, 1" (1.918849e-07%)
Noelle:  Function "verify"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 21" (5.990741e-08%)
Noelle:  Function "setup"
Noelle:     Loop "  %exitcond3 = icmp eq i64 %indvars.iv1, 3" (4.658028e-09%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 3" (6.987041e-09%)
Noelle:  Function "elapsed_time"
Noelle:  Function "timer_clear"
Noelle:  Function "c_print_results"
Noelle:  Function "wtime_"
Noelle:  Function "timer_stop"
Noelle:  Function "timer_start"
Noelle:  Function "timer_read"
Noelle:  Function "main"
Noelle:     Loop "  %exitcond8 = icmp eq i32 %.02, 7" (8.669107e-09%)
Noelle:     Loop "  %exitcond = icmp eq i32 %.1, 7" (8.669107e-09%)
Noelle:     Loop "  %exitcond1 = icmp eq i32 %.01, %118" (4.793906e+01%)
Noelle:     Loop "  %exitcond.i = icmp eq i64 %indvars.iv15.i, 3" (5.590927e-07%)
Noelle:     Loop "  %129 = icmp slt i64 %indvars.iv13.i, %60" (1.794278e+01%)
Noelle:     Loop "  %130 = icmp sgt i64 %indvars.iv, %79" (1.794277e+01%)
Noelle:     Loop "  %131 = icmp slt i64 %indvars.iv7.i, %68" (1.785198e+00%)
Noelle:     Loop "  %132 = icmp slt i64 %indvars.iv.i, %67" (1.752578e+00%)
Noelle:     Loop "  %150 = icmp slt i32 %57, %.0.i.i" (1.393586e+01%)
Noelle:     Loop "  %163 = icmp slt i64 %indvars.iv16.i11.i.i, %161" (7.136336e+00%)
Noelle:     Loop "  %176 = icmp slt i64 %indvars.iv14.i13.i.i, %160" (7.082883e+00%)
Noelle:     Loop "  %183 = icmp slt i64 %indvars.iv12.i14.i.i, %67" (6.933954e+00%)
Noelle:     Loop "  %222 = icmp slt i64 %indvars.iv16.i.i.i, %220" (6.796510e+00%)
Noelle:     Loop "  %235 = icmp slt i64 %indvars.iv14.i.i.i, %219" (6.745603e+00%)
Noelle:     Loop "  %242 = icmp slt i64 %indvars.iv12.i.i.i, %67" (6.603765e+00%)
Noelle:     Loop "  %269 = icmp slt i64 %indvars.iv5.i.i, %68" (6.098883e-01%)
Noelle:     Loop "  %270 = icmp slt i64 %indvars.iv.i.i, %67" (5.968533e-01%)
Noelle:     Loop "  %284 = icmp slt i64 %indvars.iv11.i, %68" (1.611568e+00%)
Noelle:     Loop "  %285 = icmp slt i64 %indvars.iv9.i, %67" (1.578948e+00%)
Noelle:     Loop "  %exitcond.i2 = icmp eq i64 %indvars.iv15.i1, 3" (5.590927e-07%)
Noelle:     Loop "  %309 = icmp slt i64 %indvars.iv13.i4, %83" (1.794271e+01%)
Noelle:     Loop "  %310 = icmp sgt i64 %indvars.iv60, %97" (1.794271e+01%)
Noelle:     Loop "  %311 = icmp slt i64 %indvars.iv7.i7, %89" (1.785191e+00%)
Noelle:     Loop "  %312 = icmp slt i64 %indvars.iv.i9, %67" (1.752572e+00%)
Noelle:     Loop "  %330 = icmp slt i32 %80, %.0.i.i15" (1.393581e+01%)
Noelle:     Loop "  %343 = icmp slt i64 %indvars.iv16.i11.i.i20, %341" (7.136309e+00%)
Noelle:     Loop "  %356 = icmp slt i64 %indvars.iv14.i13.i.i22, %340" (7.082856e+00%)
Noelle:     Loop "  %363 = icmp slt i64 %indvars.iv12.i14.i.i23, %67" (6.933927e+00%)
Noelle:     Loop "  %402 = icmp slt i64 %indvars.iv16.i.i.i30, %400" (6.796484e+00%)
Noelle:     Loop "  %415 = icmp slt i64 %indvars.iv14.i.i.i32, %399" (6.745577e+00%)
Noelle:     Loop "  %422 = icmp slt i64 %indvars.iv12.i.i.i33, %67" (6.603740e+00%)
Noelle:     Loop "  %449 = icmp slt i64 %indvars.iv5.i.i40, %89" (6.098860e-01%)
Noelle:     Loop "  %450 = icmp slt i64 %indvars.iv.i.i42, %67" (5.968511e-01%)
Noelle:     Loop "  %464 = icmp slt i64 %indvars.iv11.i47, %89" (1.611561e+00%)
Noelle:     Loop "  %465 = icmp slt i64 %indvars.iv9.i49, %67" (1.578942e+00%)
Noelle:     Loop "  %exitcond.i1 = icmp eq i64 %indvars.iv14.i, 3" (5.590927e-07%)
Noelle:     Loop "  %489 = icmp slt i64 %indvars.iv12.i, %101" (1.022846e+01%)
Noelle:     Loop "  %490 = icmp sgt i64 %indvars.iv62, %115" (1.022845e+01%)
Noelle:     Loop "  %491 = icmp slt i64 %indvars.iv6.i, %67" (1.477914e+00%)
Noelle:     Loop "  %496 = icmp slt i64 %indvars.iv.i5, %107" (1.476356e+00%)
Noelle:     Loop "  %512 = icmp slt i32 %98, %.0.i.i10" (6.967890e+00%)
Noelle:     Loop "  %525 = icmp slt i64 %indvars.iv16.i11.i.i15, %523" (3.568147e+00%)
Noelle:     Loop "  %538 = icmp slt i64 %indvars.iv14.i13.i.i17, %522" (3.541421e+00%)
Noelle:     Loop "  %545 = icmp slt i64 %indvars.iv12.i14.i.i18, %67" (3.466957e+00%)
Noelle:     Loop "  %584 = icmp slt i64 %indvars.iv16.i.i.i25, %582" (3.398236e+00%)
Noelle:     Loop "  %597 = icmp slt i64 %indvars.iv14.i.i.i27, %581" (3.372782e+00%)
Noelle:     Loop "  %604 = icmp slt i64 %indvars.iv12.i.i.i28, %67" (3.301864e+00%)
Noelle:     Loop "  %631 = icmp slt i64 %indvars.iv5.i.i35, %107" (3.049424e-01%)
Noelle:     Loop "  %632 = icmp slt i64 %indvars.iv.i.i37, %67" (2.984250e-01%)
Noelle:     Loop "  %646 = icmp slt i64 %indvars.iv10.i, %67" (1.477574e+00%)
Noelle:     Loop "  %650 = icmp slt i64 %indvars.iv8.i, %107" (1.476356e+00%)
Noelle:  Function "fft"
Noelle:  Function "cffts3"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (2.386818e+09%)
Noelle:     Loop "  %43 = icmp slt i64 %indvars.iv13, %24" (1.973369e+01%)
Noelle:     Loop "  %45 = icmp sgt i64 %indvars.iv12, %37" (1.973368e+01%)
Noelle:     Loop "  %47 = icmp slt i64 %indvars.iv7, %29" (1.964093e+00%)
Noelle:     Loop "  %48 = icmp slt i64 %indvars.iv, %35" (1.928205e+00%)
Noelle:     Loop "  %65 = icmp slt i32 %21, %.0.i" (1.532524e+01%)
Noelle:     Loop "  %77 = icmp slt i64 %indvars.iv10.i4.i, %75" (7.847813e+00%)
Noelle:     Loop "  %89 = icmp slt i64 %indvars.iv8.i6.i, %74" (7.792661e+00%)
Noelle:     Loop "  %97 = icmp slt i64 %indvars.iv.i8.i, %35" (7.628807e+00%)
Noelle:     Loop "  %134 = icmp slt i64 %indvars.iv10.i.i, %132" (7.474108e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv8.i.i, %131" (7.421582e+00%)
Noelle:     Loop "  %154 = icmp slt i64 %indvars.iv.i.i, %35" (7.265531e+00%)
Noelle:     Loop "  %181 = icmp slt i64 %indvars.iv5.i, %29" (6.710054e-01%)
Noelle:     Loop "  %182 = icmp slt i64 %indvars.iv.i, %35" (6.566642e-01%)
Noelle:     Loop "  %196 = icmp slt i64 %indvars.iv11, %29" (1.773063e+00%)
Noelle:     Loop "  %197 = icmp slt i64 %indvars.iv9, %35" (1.737175e+00%)
Noelle:  Function "cffts2"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3" (6.149890e-07%)
Noelle:     Loop "  %43 = icmp slt i64 %indvars.iv13, %24" (1.973369e+01%)
Noelle:     Loop "  %44 = icmp sgt i64 %indvars.iv14, %41" (1.973368e+01%)
Noelle:     Loop "  %45 = icmp slt i64 %indvars.iv7, %31" (1.964093e+00%)
Noelle:     Loop "  %46 = icmp slt i64 %indvars.iv, %30" (1.928205e+00%)
Noelle:     Loop "  %63 = icmp slt i32 %21, %.0.i" (1.532524e+01%)
Noelle:     Loop "  %75 = icmp slt i64 %indvars.iv10.i4.i, %73" (7.847813e+00%)
Noelle:     Loop "  %87 = icmp slt i64 %indvars.iv8.i6.i, %72" (7.792661e+00%)
Noelle:     Loop "  %95 = icmp slt i64 %indvars.iv.i8.i, %30" (7.628807e+00%)
Noelle:     Loop "  %132 = icmp slt i64 %indvars.iv10.i.i, %130" (7.474108e+00%)
Noelle:     Loop "  %144 = icmp slt i64 %indvars.iv8.i.i, %129" (7.421582e+00%)
Noelle:     Loop "  %152 = icmp slt i64 %indvars.iv.i.i, %30" (7.265531e+00%)
Noelle:     Loop "  %178 = icmp slt i64 %indvars.iv5.i, %31" (6.710054e-01%)
Noelle:     Loop "  %179 = icmp slt i64 %indvars.iv.i, %30" (6.566642e-01%)
Noelle:     Loop "  %193 = icmp slt i64 %indvars.iv11, %31" (1.773063e+00%)
Noelle:     Loop "  %194 = icmp slt i64 %indvars.iv9, %30" (1.737175e+00%)
Noelle:  Function "cffts1"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv14, 3" (6.149890e-07%)
Noelle:     Loop "  %43 = icmp slt i64 %indvars.iv12, %24" (1.124997e+01%)
Noelle:     Loop "  %45 = icmp sgt i64 %indvars.iv11, %37" (1.124996e+01%)
Noelle:     Loop "  %46 = icmp slt i64 %indvars.iv6, %36" (1.626028e+00%)
Noelle:     Loop "  %51 = icmp slt i64 %indvars.iv, %29" (1.624314e+00%)
Noelle:     Loop "  %66 = icmp slt i32 %21, %.0.i" (7.662631e+00%)
Noelle:     Loop "  %78 = icmp slt i64 %indvars.iv10.i4.i, %76" (3.923913e+00%)
Noelle:     Loop "  %90 = icmp slt i64 %indvars.iv8.i6.i, %75" (3.896337e+00%)
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv.i8.i, %36" (3.814410e+00%)
Noelle:     Loop "  %135 = icmp slt i64 %indvars.iv10.i.i, %133" (3.737060e+00%)
Noelle:     Loop "  %147 = icmp slt i64 %indvars.iv8.i.i, %132" (3.710797e+00%)
Noelle:     Loop "  %155 = icmp slt i64 %indvars.iv.i.i, %36" (3.632771e+00%)
Noelle:     Loop "  %182 = icmp slt i64 %indvars.iv5.i, %29" (3.355033e-01%)
Noelle:     Loop "  %183 = icmp slt i64 %indvars.iv.i, %36" (3.283327e-01%)
Noelle:     Loop "  %197 = icmp slt i64 %indvars.iv10, %36" (1.625655e+00%)
Noelle:     Loop "  %201 = icmp slt i64 %indvars.iv8, %29" (1.624314e+00%)
Noelle:  Function "evolve"
Noelle:     Loop "  %16 = icmp slt i64 %indvars.iv5, %8" (1.825003e+00%)
Noelle:     Loop "  %17 = icmp slt i64 %indvars.iv3, %11" (1.824999e+00%)
Noelle:     Loop "  %18 = icmp slt i64 %indvars.iv, %14" (1.823979e+00%)
Noelle:  Function "compute_initial_conditions"
Noelle:     Loop "  %34 = icmp slt i64 %indvars.iv8, %20" (6.948935e-01%)
Noelle:     Loop "  %36 = icmp sgt i64 %indvars.iv.i, %24" (5.209898e-01%)
Noelle:     Loop "  %61 = icmp slt i64 %indvars.iv6, %25" (1.739015e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 512" (1.737317e-01%)
Noelle:  Function "vranlc"
Noelle:     Loop "  %13 = icmp sgt i64 %indvars.iv, %11" (5.209896e-01%)
Noelle:  Function "compute_indexmap"
Noelle:     Loop "  %15 = icmp slt i64 %indvars.iv10, %4" (1.221094e-01%)
Noelle:     Loop "  %23 = icmp slt i64 %indvars.iv8, %8" (1.221078e-01%)
Noelle:     Loop "  %33 = icmp slt i64 %indvars.iv6, %12" (1.216664e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 1966081" (5.597954e-03%)
Noelle:  Function "checksum"
Noelle:     Loop "  %exitcond = icmp eq i32 %.0, 1025" (1.113087e-04%)
Noelle:  Function "randlc"
Noelle:  Function "fft_init"
Noelle:     Loop "  %7 = icmp sgt i32 %.01, %2" (2.024431e-06%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, %wide.trip.count" (1.990530e-06%)
Noelle:  Function "ilog2"
Noelle:     Loop "  %3 = icmp slt i32 %.01, %0" (1.433120e-06%)
Noelle:  Function "ipow46"
Noelle:     Loop "  %11 = icmp sgt i32 %.01, 1" (1.918849e-07%)
Noelle:  Function "verify"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 21" (5.990741e-08%)
Noelle:  Function "setup"
Noelle:     Loop "  %exitcond3 = icmp eq i64 %indvars.iv1, 3" (4.658028e-09%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 3" (6.987041e-09%)
Noelle:  Function "elapsed_time"
Noelle:  Function "timer_clear"
Noelle:  Function "c_print_results"
Noelle:  Function "wtime_"
Noelle:  Function "timer_stop"
Noelle:  Function "timer_start"
Noelle:  Function "timer_read"
NOELLE: FixedPoint: Exit
NOELLE: Enablers: Exit
noelle-simplification baseline_pre.bc -o baseline_pre.bc
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -tbaa -early-cse-memssa -licm -simplifycfg -simplifycfg-sink-common=false -instcombine -tailcallelim -loop-simplify -lcssa -licm -loop-unswitch -globalopt -instcombine -ipsccp -dce -gvn -dse -adce -loop-simplify -lcssa -indvars -loop-deletion -instcombine -indvars -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa --functionattrs --rpo-functionattrs baseline_pre.bc -o baseline_pre.bc
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CleanMetadata.so -CleanMetadata -clean-loop-metadata=true -clean-prof-metadata=true -clean-pdg-metadata=true baseline_pre.bc -o baseline_pre.bc
noelle/core/Clean Loop Metadata
noelle/core/Clean PDG Metadata
noelle/core/Clean profiler metadata
opt --strip-named-metadata baseline_pre.bc -o baseline_pre.bc
Running: ./baseline_pre_prof in /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/NAS/benchmarks/ft.B


 NAS Parallel Benchmarks 3.0 structured OpenMP C version - FT Benchmark

 Size                : 512x256x256
 Iterations          :          20
T =     1     Checksum =     9.995740197746e-01     9.984008193801e-01
T =     2     Checksum =     1.000067899610e+00     9.992551110335e-01
T =     3     Checksum =     1.000301376280e+00     9.996532314851e-01
T =     4     Checksum =     1.000413996760e+00     9.998689910176e-01
T =     5     Checksum =     1.000471428537e+00     9.999953848933e-01
T =     6     Checksum =     1.000503343459e+00     1.000073704006e+00
T =     7     Checksum =     1.000523147868e+00     1.000124398283e+00
T =     8     Checksum =     1.000536994050e+00     1.000158344894e+00
T =     9     Checksum =     1.000547758917e+00     1.000181678041e+00
T =    10     Checksum =     1.000556810869e+00     1.000198032189e+00
T =    11     Checksum =     1.000564808752e+00     1.000209650933e+00
T =    12     Checksum =     1.000572071338e+00     1.000217966769e+00
T =    13     Checksum =     1.000578752315e+00     1.000223920180e+00
T =    14     Checksum =     1.000584925116e+00     1.000228143441e+00
T =    15     Checksum =     1.000590624866e+00     1.000231070704e+00
T =    16     Checksum =     1.000595869380e+00     1.000233006089e+00
T =    17     Checksum =     1.000600669679e+00     1.000234166879e+00
T =    18     Checksum =     1.000605035143e+00     1.000234711495e+00
T =    19     Checksum =     1.000608975873e+00     1.000234757879e+00
T =    20     Checksum =     1.000612503619e+00     1.000234395745e+00
Result verification successful
class = B


 FT Benchmark Completed
 Class           =                        B
 Size            =              512x256x256
 Iterations      =                       20
 Threads         =                        1
 Time in seconds =                    57.42
 Mop/s total     =                  1603.09
 Operation type  =           floating point
 Verification    =             UNSUCCESSFUL
 Version         =           3.0 structured
 Compile date    =              20 Jan 2023

 Compile options:
    CC           = gclang
    CLINK        = gclang
    C_LIB        = (none)
    C_INC        = -I../common
    CFLAGS       = -g -O1 -Xclang -disable-llvm-passes
    CLINKFLAGS   = -lm -mcmodel=large
    RAND         = randdp
--------------------------------------------------------------------------------------
DONE
opt -pgo-test-profile-file=/tmp/tmp.dBMfS5BfHV -block-freq -pgo-instr-use baseline_pre.bc -o baseline_with_metadata.bc
noelle-load -PDGAnalysis -noelle-pdg-verbose=3 -noelle-pdg-embed baseline_with_metadata.bc -o baseline_with_metadata.bc
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -PDGAnalysis -noelle-pdg-verbose=3 -noelle-pdg-embed baseline_with_metadata.bc -o baseline_with_metadata.bc
PDGAnalysis: Construct PDG from Analysis
Embed PDG as metadata
noelle-parallelizer baseline_with_metadata.bc -o baseline_parallelized.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
noelle-meta-loop-embed baseline_with_metadata.bc -o afterLoopMetadata.bc
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopMetadata.so -LoopMetadata baseline_with_metadata.bc -o afterLoopMetadata.bc
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopMetadata.so -LoopMetadata baseline_with_metadata.bc -o afterLoopMetadata.bc
noelle-parallelization-planner afterLoopMetadata.bc -o baseline_with_parallel_plan.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Planner.so -planner afterLoopMetadata.bc -o baseline_with_parallel_plan.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Planner.so -planner afterLoopMetadata.bc -o baseline_with_parallel_plan.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Planner.so -planner afterLoopMetadata.bc -o baseline_with_parallel_plan.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
Planner: Start
Planner:  Fetching the program loops
Noelle: Filter out cold code
Noelle:  Function "main"
Noelle:     Loop "  %exitcond8 = icmp eq i32 %.02, 7, !noelle.pdg.inst.id !1052" (5.096999e-08%)
Noelle:  Disable loop "0" as cold code
Noelle:     Loop "  %exitcond = icmp eq i32 %.1, 7, !noelle.pdg.inst.id !1071" (5.096999e-08%)
Noelle:  Disable loop "1" as cold code
Noelle:     Loop "  %exitcond1 = icmp eq i32 %.01, %70, !noelle.pdg.inst.id !1113" (6.805510e+01%)
Noelle:     Loop "  %exitcond.i = icmp eq i64 %indvars.iv15.i, 3, !noelle.pdg.inst.id !1123" (2.738686e-07%)
Noelle:  Disable loop "3" as cold code
Noelle:     Loop "  %81 = icmp slt i64 %indvars.iv13.i, %40, !noelle.pdg.inst.id !1132" (1.997330e+01%)
Noelle:     Loop "  %82 = icmp sgt i64 %indvars.iv, %49, !noelle.pdg.inst.id !1138" (1.997328e+01%)
Noelle:     Loop "  %83 = icmp slt i64 %indvars.iv7.i, %48, !noelle.pdg.inst.id !1144" (1.049606e+01%)
Noelle:     Loop "  %84 = icmp slt i64 %indvars.iv.i, %47, !noelle.pdg.inst.id !1150" (1.030428e+01%)
Noelle:     Loop "  br i1 false, label %.preheader.i.i..loopexit.i.i_crit_edge, label %100, !prof !1173, !noelle.loop.id !1177, !noelle.pdg.inst.id !1178" (4.984683e-04%)
Noelle:  Disable loop "8" as cold code
Noelle:     Loop "  br i1 false, label %101, label %.us-lcssa.us.loopexit1.i19.i.i, !prof !1173, !noelle.loop.id !1181, !noelle.pdg.inst.id !1182" (1.246163e-04%)
Noelle:  Disable loop "9" as cold code
Noelle:     Loop "  br i1 false, label %103, label %107, !noelle.loop.id !1184, !noelle.pdg.inst.id !1185" (0.000000e+00%)
Noelle:  Disable loop "10" as cold code
Noelle:     Loop "  br i1 false, label %105, label %106, !noelle.loop.id !1187, !noelle.pdg.inst.id !1188" (0.000000e+00%)
Noelle:  Disable loop "11" as cold code
Noelle:     Loop "  br i1 false, label %109, label %.us-lcssa.us.loopexit1.i.i.i, !noelle.loop.id !1195, !noelle.pdg.inst.id !1196" (3.042985e-09%)
Noelle:  Disable loop "12" as cold code
Noelle:     Loop "  br i1 false, label %111, label %115, !noelle.loop.id !1198, !noelle.pdg.inst.id !1199" (3.042985e-09%)
Noelle:  Disable loop "13" as cold code
Noelle:     Loop "  br i1 false, label %113, label %114, !noelle.loop.id !1201, !noelle.pdg.inst.id !1202" (3.042985e-09%)
Noelle:  Disable loop "14" as cold code
Noelle:     Loop "  br i1 false, label %.preheader1.i.i.preheader, label %cfftz.exit.i.loopexit, !noelle.loop.id !1211, !noelle.pdg.inst.id !1212" (0.000000e+00%)
Noelle:  Disable loop "15" as cold code
Noelle:     Loop "  br i1 false, label %116, label %117, !noelle.loop.id !1214, !noelle.pdg.inst.id !1215" (0.000000e+00%)
Noelle:  Disable loop "16" as cold code
Noelle:     Loop "  %119 = icmp slt i64 %indvars.iv11.i, %48, !noelle.pdg.inst.id !1221" (9.475207e+00%)
Noelle:     Loop "  %120 = icmp slt i64 %indvars.iv9.i, %47, !noelle.pdg.inst.id !1226" (9.283423e+00%)
Noelle:     Loop "  %exitcond.i2 = icmp eq i64 %indvars.iv15.i1, 3, !noelle.pdg.inst.id !1249" (2.738686e-07%)
Noelle:  Disable loop "19" as cold code
Noelle:     Loop "  %140 = icmp slt i64 %indvars.iv13.i4, %52, !noelle.pdg.inst.id !1257" (1.997322e+01%)
Noelle:     Loop "  %141 = icmp sgt i64 %indvars.iv60, %59, !noelle.pdg.inst.id !1262" (1.997320e+01%)
Noelle:     Loop "  %142 = icmp slt i64 %indvars.iv7.i7, %58, !noelle.pdg.inst.id !1267" (1.049602e+01%)
Noelle:     Loop "  %143 = icmp slt i64 %indvars.iv.i9, %47, !noelle.pdg.inst.id !1272" (1.030424e+01%)
Noelle:     Loop "  br i1 false, label %.preheader.i.i16..loopexit.i.i38_crit_edge, label %159, !prof !1173, !noelle.loop.id !1293, !noelle.pdg.inst.id !1294" (4.984652e-04%)
Noelle:  Disable loop "24" as cold code
Noelle:     Loop "  br i1 false, label %160, label %.us-lcssa.us.loopexit1.i19.i.i27, !prof !1173, !noelle.loop.id !1297, !noelle.pdg.inst.id !1298" (1.246155e-04%)
Noelle:  Disable loop "25" as cold code
Noelle:     Loop "  br i1 false, label %162, label %166, !noelle.loop.id !1300, !noelle.pdg.inst.id !1301" (0.000000e+00%)
Noelle:  Disable loop "26" as cold code
Noelle:     Loop "  br i1 false, label %164, label %165, !noelle.loop.id !1303, !noelle.pdg.inst.id !1304" (0.000000e+00%)
Noelle:  Disable loop "27" as cold code
Noelle:     Loop "  br i1 false, label %168, label %.us-lcssa.us.loopexit1.i.i.i37, !noelle.loop.id !1310, !noelle.pdg.inst.id !1311" (3.042985e-09%)
Noelle:  Disable loop "28" as cold code
Noelle:     Loop "  br i1 false, label %170, label %174, !noelle.loop.id !1313, !noelle.pdg.inst.id !1314" (3.042985e-09%)
Noelle:  Disable loop "29" as cold code
Noelle:     Loop "  br i1 false, label %172, label %173, !noelle.loop.id !1316, !noelle.pdg.inst.id !1317" (3.042985e-09%)
Noelle:  Disable loop "30" as cold code
Noelle:     Loop "  br i1 false, label %.preheader1.i.i41.preheader, label %cfftz.exit.i46.loopexit, !noelle.loop.id !1326, !noelle.pdg.inst.id !1327" (0.000000e+00%)
Noelle:  Disable loop "31" as cold code
Noelle:     Loop "  br i1 false, label %175, label %176, !noelle.loop.id !1329, !noelle.pdg.inst.id !1330" (0.000000e+00%)
Noelle:  Disable loop "32" as cold code
Noelle:     Loop "  %178 = icmp slt i64 %indvars.iv11.i47, %58, !noelle.pdg.inst.id !1336" (9.475171e+00%)
Noelle:     Loop "  %179 = icmp slt i64 %indvars.iv9.i49, %47, !noelle.pdg.inst.id !1341" (9.283387e+00%)
Noelle:     Loop "  %exitcond.i1 = icmp eq i64 %indvars.iv14.i, 3, !noelle.pdg.inst.id !1364" (2.738686e-07%)
Noelle:  Disable loop "35" as cold code
Noelle:     Loop "  %199 = icmp slt i64 %indvars.iv12.i, %62, !noelle.pdg.inst.id !1372" (1.737782e+01%)
Noelle:     Loop "  %200 = icmp sgt i64 %indvars.iv62, %69, !noelle.pdg.inst.id !1377" (1.737779e+01%)
Noelle:     Loop "  %201 = icmp slt i64 %indvars.iv6.i, %47, !noelle.pdg.inst.id !1383" (8.689389e+00%)
Noelle:     Loop "  %206 = icmp slt i64 %indvars.iv.i5, %68, !noelle.pdg.inst.id !1392" (8.680230e+00%)
Noelle:     Loop "  br i1 false, label %.preheader.i.i11..loopexit.i.i33_crit_edge, label %220, !prof !1408, !noelle.loop.id !1412, !noelle.pdg.inst.id !1413" (2.492341e-04%)
Noelle:  Disable loop "40" as cold code
Noelle:     Loop "  br i1 false, label %221, label %.us-lcssa.us.loopexit1.i19.i.i22, !prof !1408, !noelle.loop.id !1416, !noelle.pdg.inst.id !1417" (6.230815e-05%)
Noelle:  Disable loop "41" as cold code
Noelle:     Loop "  br i1 false, label %223, label %227, !noelle.loop.id !1419, !noelle.pdg.inst.id !1420" (0.000000e+00%)
Noelle:  Disable loop "42" as cold code
Noelle:     Loop "  br i1 false, label %225, label %226, !noelle.loop.id !1422, !noelle.pdg.inst.id !1423" (0.000000e+00%)
Noelle:  Disable loop "43" as cold code
Noelle:     Loop "  br i1 false, label %229, label %.us-lcssa.us.loopexit1.i.i.i32, !noelle.loop.id !1430, !noelle.pdg.inst.id !1431" (1.521492e-09%)
Noelle:  Disable loop "44" as cold code
Noelle:     Loop "  br i1 false, label %231, label %235, !noelle.loop.id !1433, !noelle.pdg.inst.id !1434" (1.521492e-09%)
Noelle:  Disable loop "45" as cold code
Noelle:     Loop "  br i1 false, label %233, label %234, !noelle.loop.id !1436, !noelle.pdg.inst.id !1437" (1.521492e-09%)
Noelle:  Disable loop "46" as cold code
Noelle:     Loop "  br i1 false, label %.preheader1.i.i36.preheader, label %cfftz.exit.i41.loopexit, !noelle.loop.id !1446, !noelle.pdg.inst.id !1447" (0.000000e+00%)
Noelle:  Disable loop "47" as cold code
Noelle:     Loop "  br i1 false, label %236, label %237, !noelle.loop.id !1449, !noelle.pdg.inst.id !1450" (0.000000e+00%)
Noelle:  Disable loop "48" as cold code
Noelle:     Loop "  %239 = icmp slt i64 %indvars.iv10.i, %47, !noelle.pdg.inst.id !1456" (8.687396e+00%)
Noelle:     Loop "  %243 = icmp slt i64 %indvars.iv8.i, %68, !noelle.pdg.inst.id !1462" (8.680230e+00%)
Noelle:  Function "fft"
Noelle:  Function "evolve"
Noelle:     Loop "  %16 = icmp slt i64 %indvars.iv5, %8, !noelle.pdg.inst.id !61" (1.073010e+01%)
Noelle:     Loop "  %17 = icmp slt i64 %indvars.iv3, %11, !noelle.pdg.inst.id !67" (1.073007e+01%)
Noelle:     Loop "  %18 = icmp slt i64 %indvars.iv, %14, !noelle.pdg.inst.id !73" (1.072408e+01%)
Noelle:  Function "cffts1"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv14, 3, !noelle.pdg.inst.id !366" (3.294031e-07%)
Noelle:  Disable loop "54" as cold code
Noelle:     Loop "  %43 = icmp slt i64 %indvars.iv12, %24, !noelle.pdg.inst.id !403" (1.000171e+01%)
Noelle:     Loop "  %44 = icmp sgt i64 %indvars.iv11, %37, !noelle.pdg.inst.id !409" (1.000171e+01%)
Noelle:     Loop "  %45 = icmp slt i64 %indvars.iv6, %36, !noelle.pdg.inst.id !415" (8.691114e-01%)
Noelle:     Loop "  %50 = icmp slt i64 %indvars.iv, %29, !noelle.pdg.inst.id !424" (8.681953e-01%)
Noelle:     Loop "  %65 = icmp slt i32 %21, %.0.i, !noelle.pdg.inst.id !451" (7.366971e+00%)
Noelle:     Loop "  %77 = icmp slt i64 %indvars.iv10.i4.i, %75, !noelle.pdg.inst.id !472" (4.098632e+00%)
Noelle:     Loop "  %89 = icmp slt i64 %indvars.iv8.i6.i, %74, !noelle.pdg.inst.id !485" (4.066661e+00%)
Noelle:     Loop "  %97 = icmp slt i64 %indvars.iv.i8.i, %36, !noelle.pdg.inst.id !497" (3.980516e+00%)
Noelle:     Loop "  %134 = icmp slt i64 %indvars.iv10.i.i, %132, !noelle.pdg.inst.id !541" (3.267374e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv8.i.i, %131, !noelle.pdg.inst.id !554" (3.251407e+00%)
Noelle:     Loop "  %154 = icmp slt i64 %indvars.iv.i.i, %36, !noelle.pdg.inst.id !566" (3.184413e+00%)
Noelle:     Loop "  %180 = icmp slt i64 %indvars.iv5.i, %29, !noelle.pdg.inst.id !599" (8.966320e-01%)
Noelle:     Loop "  %181 = icmp slt i64 %indvars.iv.i, %36, !noelle.pdg.inst.id !605" (8.774685e-01%)
Noelle:     Loop "  %195 = icmp slt i64 %indvars.iv10, %36, !noelle.pdg.inst.id !624" (8.689119e-01%)
Noelle:     Loop "  %199 = icmp slt i64 %indvars.iv8, %29, !noelle.pdg.inst.id !630" (8.681953e-01%)
Noelle:  Function "cffts3"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3, !noelle.pdg.inst.id !358" (3.415750e-07%)
Noelle:  Disable loop "70" as cold code
Noelle:     Loop "  %43 = icmp slt i64 %indvars.iv13, %24, !noelle.pdg.inst.id !395" (8.553348e+00%)
Noelle:     Loop "  %44 = icmp sgt i64 %indvars.iv12, %37, !noelle.pdg.inst.id !401" (8.553346e+00%)
Noelle:     Loop "  %45 = icmp slt i64 %indvars.iv7, %29, !noelle.pdg.inst.id !407" (1.049807e+00%)
Noelle:     Loop "  %46 = icmp slt i64 %indvars.iv, %35, !noelle.pdg.inst.id !413" (1.030625e+00%)
Noelle:     Loop "  %63 = icmp slt i32 %21, %.0.i, !noelle.pdg.inst.id !443" (6.555687e+00%)
Noelle:     Loop "  %75 = icmp slt i64 %indvars.iv10.i4.i, %73, !noelle.pdg.inst.id !465" (3.286512e+00%)
Noelle:     Loop "  %87 = icmp slt i64 %indvars.iv8.i6.i, %72, !noelle.pdg.inst.id !478" (3.254579e+00%)
Noelle:     Loop "  %95 = icmp slt i64 %indvars.iv.i8.i, %35, !noelle.pdg.inst.id !490" (3.184407e+00%)
Noelle:     Loop "  %132 = icmp slt i64 %indvars.iv10.i.i, %130, !noelle.pdg.inst.id !533" (3.267442e+00%)
Noelle:     Loop "  %144 = icmp slt i64 %indvars.iv8.i.i, %129, !noelle.pdg.inst.id !546" (3.251401e+00%)
Noelle:     Loop "  %152 = icmp slt i64 %indvars.iv.i.i, %35, !noelle.pdg.inst.id !558" (3.184407e+00%)
Noelle:     Loop "  %178 = icmp slt i64 %indvars.iv5.i, %29, !noelle.pdg.inst.id !589" (0.000000e+00%)
Noelle:  Disable loop "82" as cold code
Noelle:     Loop "  %179 = icmp slt i64 %indvars.iv.i, %35, !noelle.pdg.inst.id !594" (0.000000e+00%)
Noelle:  Disable loop "83" as cold code
Noelle:     Loop "  %193 = icmp slt i64 %indvars.iv11, %29, !noelle.pdg.inst.id !612" (9.477015e-01%)
Noelle:     Loop "  %194 = icmp slt i64 %indvars.iv9, %35, !noelle.pdg.inst.id !617" (9.285194e-01%)
Noelle:  Function "cffts2"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3, !noelle.pdg.inst.id !366" (3.294031e-07%)
Noelle:  Disable loop "86" as cold code
Noelle:     Loop "  %43 = icmp slt i64 %indvars.iv13, %24, !noelle.pdg.inst.id !403" (8.553348e+00%)
Noelle:     Loop "  %44 = icmp sgt i64 %indvars.iv14, %41, !noelle.pdg.inst.id !409" (8.553346e+00%)
Noelle:     Loop "  %45 = icmp slt i64 %indvars.iv7, %31, !noelle.pdg.inst.id !415" (1.049807e+00%)
Noelle:     Loop "  %46 = icmp slt i64 %indvars.iv, %30, !noelle.pdg.inst.id !421" (1.030625e+00%)
Noelle:     Loop "  %63 = icmp slt i32 %21, %.0.i, !noelle.pdg.inst.id !451" (6.555687e+00%)
Noelle:     Loop "  %75 = icmp slt i64 %indvars.iv10.i4.i, %73, !noelle.pdg.inst.id !473" (3.286512e+00%)
Noelle:     Loop "  %87 = icmp slt i64 %indvars.iv8.i6.i, %72, !noelle.pdg.inst.id !486" (3.254579e+00%)
Noelle:     Loop "  %95 = icmp slt i64 %indvars.iv.i8.i, %30, !noelle.pdg.inst.id !498" (3.184407e+00%)
Noelle:     Loop "  %132 = icmp slt i64 %indvars.iv10.i.i, %130, !noelle.pdg.inst.id !541" (3.267442e+00%)
Noelle:     Loop "  %144 = icmp slt i64 %indvars.iv8.i.i, %129, !noelle.pdg.inst.id !554" (3.251401e+00%)
Noelle:     Loop "  %152 = icmp slt i64 %indvars.iv.i.i, %30, !noelle.pdg.inst.id !566" (3.184407e+00%)
Noelle:     Loop "  %178 = icmp slt i64 %indvars.iv5.i, %31, !noelle.pdg.inst.id !597" (0.000000e+00%)
Noelle:  Disable loop "98" as cold code
Noelle:     Loop "  %179 = icmp slt i64 %indvars.iv.i, %30, !noelle.pdg.inst.id !602" (0.000000e+00%)
Noelle:  Disable loop "99" as cold code
Noelle:     Loop "  %193 = icmp slt i64 %indvars.iv11, %31, !noelle.pdg.inst.id !620" (9.477015e-01%)
Noelle:     Loop "  %194 = icmp slt i64 %indvars.iv9, %30, !noelle.pdg.inst.id !625" (9.285194e-01%)
Noelle:  Function "compute_initial_conditions"
Noelle:     Loop "  %34 = icmp slt i64 %indvars.iv8, %20, !noelle.pdg.inst.id !141" (4.085625e+00%)
Noelle:     Loop "  %35 = icmp sgt i64 %indvars.iv.i, %24, !noelle.pdg.inst.id !148" (3.063158e+00%)
Noelle:     Loop "  %60 = icmp slt i64 %indvars.iv6, %25, !noelle.pdg.inst.id !180" (1.022454e+00%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 512, !noelle.pdg.inst.id !189" (1.021455e+00%)
Noelle:  Function "compute_indexmap"
Noelle:     Loop "  %15 = icmp slt i64 %indvars.iv10, %4, !noelle.pdg.inst.id !75" (7.179418e-01%)
Noelle:     Loop "  %23 = icmp slt i64 %indvars.iv8, %8, !noelle.pdg.inst.id !89" (7.179324e-01%)
Noelle:     Loop "  %33 = icmp slt i64 %indvars.iv6, %12, !noelle.pdg.inst.id !103" (7.153375e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 1966081, !noelle.pdg.inst.id !124" (3.291316e-02%)
Noelle:  Disable loop "109" as cold code
Noelle:  Function "checksum"
Noelle:  Disable "checksum" as cold function
Noelle:  Function "fft_init"
Noelle:  Disable "fft_init" as cold function
Noelle:  Function "ipow46"
Noelle:  Disable "ipow46" as cold function
Noelle:  Function "ilog2"
Noelle:  Disable "ilog2" as cold function
Noelle:  Function "randlc"
Noelle:  Disable "randlc" as cold function
Noelle:  Function "setup"
Noelle:  Disable "setup" as cold function
Noelle:  Function "elapsed_time"
Noelle:  Disable "elapsed_time" as cold function
Noelle:  Function "timer_clear"
Noelle:  Disable "timer_clear" as cold function
Noelle:  Function "c_print_results"
Noelle:  Disable "c_print_results" as cold function
Noelle:  Function "wtime_"
Noelle:  Disable "wtime_" as cold function
Noelle:  Function "timer_stop"
Noelle:  Disable "timer_stop" as cold function
Noelle:  Function "timer_start"
Noelle:  Disable "timer_start" as cold function
Noelle:  Function "verify"
Noelle:  Disable "verify" as cold function
Noelle:  Function "timer_read"
Noelle:  Disable "timer_read" as cold function
Noelle:  Function "vranlc"
Noelle:  Disable "vranlc" as cold function
Planner:    There are 70 loops in the program we are going to consider
Planner:  Filter out loops not worth considering
Planner:    Loop 73 has 5.000000e+00 number of iterations on average per loop invocation
Planner:      It is too low. The threshold is 12
Planner:    Loop 75 has 1.913616e+03 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 76 has 4.990000e+02 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 78 has 7.023530e+00 number of iterations on average per loop invocation
Planner:      It is too low. The threshold is 12
Planner:    Loop 79 has 4.990000e+02 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 81 has 2.750000e+02 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 7 has 3.230000e+02 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 18 has 2.910000e+02 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 23 has 3.230000e+02 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 34 has 2.910000e+02 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 104 has 3.230000e+02 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 115 has 2.910000e+02 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 105 has 4.999939e+00 number of iterations on average per loop invocation
Planner:      It is too low. The threshold is 12
Planner:    Loop 107 has 1.535988e+03 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 108 has 4.990000e+02 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 110 has 7.023527e+00 number of iterations on average per loop invocation
Planner:      It is too low. The threshold is 12
Planner:    Loop 111 has 4.990000e+02 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 89 has 4.999939e+00 number of iterations on average per loop invocation
Planner:      It is too low. The threshold is 12
Planner:    Loop 91 has 1.535988e+03 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 92 has 4.990000e+02 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 94 has 7.023527e+00 number of iterations on average per loop invocation
Planner:      It is too low. The threshold is 12
Planner:    Loop 95 has 4.990000e+02 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 99 has 2.910000e+02 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 88 has 3.230000e+02 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:  There are 7 loop nesting trees in the program
Planner:    ID: 63 (1)
Planner:      Function: "evolve"
Planner:      Loop: "  %16 = icmp slt i64 %indvars.iv5, %8, !noelle.pdg.inst.id !61"
Planner:      Loop nesting level: 1
Planner:      Hotness = 1.073010e+01 %
Planner:      Average instructions per invocation = 7.052351e+08 %
Planner:      Average iterations per invocation = 2.568500e+02 %
Planner:    
Planner:      ID: 64 (2)
Planner:        Function: "evolve"
Planner:        Loop: "  %17 = icmp slt i64 %indvars.iv3, %11, !noelle.pdg.inst.id !67"
Planner:        Loop nesting level: 2
Planner:        Hotness = 1.073007e+01 %
Planner:        Average instructions per invocation = 2.755895e+06 %
Planner:        Average iterations per invocation = 2.570998e+02 %
Planner:      
Planner:        ID: 65 (3)
Planner:          Function: "evolve"
Planner:          Loop: "  %18 = icmp slt i64 %indvars.iv, %14, !noelle.pdg.inst.id !73"
Planner:          Loop nesting level: 3
Planner:          Hotness = 1.072408e+01 %
Planner:          Average instructions per invocation = 1.075502e+04 %
Planner:          Average iterations per invocation = 5.130007e+02 %
Planner:        
Planner:    ID: 69 (1)
Planner:      Function: "cffts1"
Planner:      Loop: "  %43 = icmp slt i64 %indvars.iv12, %24, !noelle.pdg.inst.id !403"
Planner:      Loop nesting level: 1
Planner:      Hotness = 1.000171e+01 %
Planner:      Average instructions per invocation = 6.573619e+09 %
Planner:      Average iterations per invocation = 2.565000e+02 %
Planner:    
Planner:      ID: 70 (2)
Planner:        Function: "cffts1"
Planner:        Loop: "  %44 = icmp sgt i64 %indvars.iv11, %37, !noelle.pdg.inst.id !409"
Planner:        Loop nesting level: 2
Planner:        Hotness = 1.000171e+01 %
Planner:        Average instructions per invocation = 2.567819e+07 %
Planner:        Average iterations per invocation = 1.699805e+01 %
Planner:      
Planner:        ID: 71 (3)
Planner:          Function: "cffts1"
Planner:          Loop: "  %45 = icmp slt i64 %indvars.iv6, %36, !noelle.pdg.inst.id !415"
Planner:          Loop nesting level: 3
Planner:          Hotness = 8.691114e-01 %
Planner:          Average instructions per invocation = 1.394587e+05 %
Planner:          Average iterations per invocation = 1.699988e+01 %
Planner:        
Planner:          ID: 72 (4)
Planner:            Function: "cffts1"
Planner:            Loop: "  %50 = icmp slt i64 %indvars.iv, %29, !noelle.pdg.inst.id !424"
Planner:            Loop nesting level: 4
Planner:            Hotness = 8.681953e-01 %
Planner:            Average instructions per invocation = 8.706983e+03 %
Planner:            Average iterations per invocation = 5.129990e+02 %
Planner:          
Planner:        ID: 77 (3)
Planner:          Function: "cffts1"
Planner:          Loop: "  %134 = icmp slt i64 %indvars.iv10.i.i, %132, !noelle.pdg.inst.id !541"
Planner:          Loop nesting level: 4
Planner:          Hotness = 3.267374e+00 %
Planner:          Average instructions per invocation = 1.310717e+05 %
Planner:          Average iterations per invocation = 4.349988e+01 %
Planner:        
Planner:        ID: 74 (3)
Planner:          Function: "cffts1"
Planner:          Loop: "  %77 = icmp slt i64 %indvars.iv10.i4.i, %75, !noelle.pdg.inst.id !472"
Planner:          Loop nesting level: 4
Planner:          Hotness = 4.098632e+00 %
Planner:          Average instructions per invocation = 1.315343e+05 %
Planner:          Average iterations per invocation = 6.919985e+01 %
Planner:        
Planner:        ID: 80 (3)
Planner:          Function: "cffts1"
Planner:          Loop: "  %180 = icmp slt i64 %indvars.iv5.i, %29, !noelle.pdg.inst.id !599"
Planner:          Loop nesting level: 3
Planner:          Hotness = 8.966320e-01 %
Planner:          Average instructions per invocation = 1.438747e+05 %
Planner:          Average iterations per invocation = 5.129989e+02 %
Planner:        
Planner:        ID: 82 (3)
Planner:          Function: "cffts1"
Planner:          Loop: "  %195 = icmp slt i64 %indvars.iv10, %36, !noelle.pdg.inst.id !624"
Planner:          Loop nesting level: 3
Planner:          Hotness = 8.689119e-01 %
Planner:          Average instructions per invocation = 1.394267e+05 %
Planner:          Average iterations per invocation = 1.699988e+01 %
Planner:        
Planner:          ID: 83 (4)
Planner:            Function: "cffts1"
Planner:            Loop: "  %199 = icmp slt i64 %indvars.iv8, %29, !noelle.pdg.inst.id !630"
Planner:            Loop nesting level: 4
Planner:            Hotness = 8.681953e-01 %
Planner:            Average instructions per invocation = 8.706983e+03 %
Planner:            Average iterations per invocation = 5.129990e+02 %
Planner:          
Planner:    ID: 2 (1)
Planner:      Function: "main"
Planner:      Loop: "  %exitcond1 = icmp eq i32 %.01, %70, !noelle.pdg.inst.id !1113"
Planner:      Loop nesting level: 1
Planner:      Hotness = 6.805510e+01 %
Planner:      Average instructions per invocation = 8.945835e+10 %
Planner:      Average iterations per invocation = 2.000000e+01 %
Planner:    
Planner:      ID: 36 (2)
Planner:        Function: "main"
Planner:        Loop: "  %199 = icmp slt i64 %indvars.iv12.i, %62, !noelle.pdg.inst.id !1372"
Planner:        Loop nesting level: 2
Planner:        Hotness = 1.737782e+01 %
Planner:        Average instructions per invocation = 1.142156e+09 %
Planner:        Average iterations per invocation = 2.569000e+02 %
Planner:      
Planner:        ID: 37 (3)
Planner:          Function: "main"
Planner:          Loop: "  %200 = icmp sgt i64 %indvars.iv62, %69, !noelle.pdg.inst.id !1377"
Planner:          Loop nesting level: 3
Planner:          Hotness = 1.737779e+01 %
Planner:          Average instructions per invocation = 4.462413e+06 %
Planner:          Average iterations per invocation = 1.699980e+01 %
Planner:        
Planner:          ID: 49 (4)
Planner:            Function: "main"
Planner:            Loop: "  %239 = icmp slt i64 %indvars.iv10.i, %47, !noelle.pdg.inst.id !1456"
Planner:            Loop nesting level: 4
Planner:            Hotness = 8.687396e+00 %
Planner:            Average instructions per invocation = 1.394263e+05 %
Planner:            Average iterations per invocation = 1.699990e+01 %
Planner:          
Planner:            ID: 50 (5)
Planner:              Function: "main"
Planner:              Loop: "  %243 = icmp slt i64 %indvars.iv8.i, %68, !noelle.pdg.inst.id !1462"
Planner:              Loop nesting level: 5
Planner:              Hotness = 8.680230e+00 %
Planner:              Average instructions per invocation = 8.707003e+03 %
Planner:              Average iterations per invocation = 5.130002e+02 %
Planner:            
Planner:          ID: 38 (4)
Planner:            Function: "main"
Planner:            Loop: "  %201 = icmp slt i64 %indvars.iv6.i, %47, !noelle.pdg.inst.id !1383"
Planner:            Loop nesting level: 4
Planner:            Hotness = 8.689389e+00 %
Planner:            Average instructions per invocation = 1.394583e+05 %
Planner:            Average iterations per invocation = 1.699990e+01 %
Planner:          
Planner:            ID: 39 (5)
Planner:              Function: "main"
Planner:              Loop: "  %206 = icmp slt i64 %indvars.iv.i5, %68, !noelle.pdg.inst.id !1392"
Planner:              Loop nesting level: 5
Planner:              Hotness = 8.680230e+00 %
Planner:              Average instructions per invocation = 8.707003e+03 %
Planner:              Average iterations per invocation = 5.130002e+02 %
Planner:            
Planner:      ID: 4 (2)
Planner:        Function: "main"
Planner:        Loop: "  %81 = icmp slt i64 %indvars.iv13.i, %40, !noelle.pdg.inst.id !1132"
Planner:        Loop nesting level: 2
Planner:        Hotness = 1.997330e+01 %
Planner:        Average instructions per invocation = 1.312744e+09 %
Planner:        Average iterations per invocation = 2.569000e+02 %
Planner:      
Planner:        ID: 5 (3)
Planner:          Function: "main"
Planner:          Loop: "  %82 = icmp sgt i64 %indvars.iv, %49, !noelle.pdg.inst.id !1138"
Planner:          Loop nesting level: 3
Planner:          Hotness = 1.997328e+01 %
Planner:          Average instructions per invocation = 5.128902e+06 %
Planner:          Average iterations per invocation = 3.299980e+01 %
Planner:        
Planner:          ID: 6 (4)
Planner:            Function: "main"
Planner:            Loop: "  %83 = icmp slt i64 %indvars.iv7.i, %48, !noelle.pdg.inst.id !1144"
Planner:            Loop nesting level: 4
Planner:            Hotness = 1.049606e+01 %
Planner:            Average instructions per invocation = 8.422706e+04 %
Planner:            Average iterations per invocation = 2.570002e+02 %
Planner:          
Planner:          ID: 17 (4)
Planner:            Function: "main"
Planner:            Loop: "  %119 = icmp slt i64 %indvars.iv11.i, %48, !noelle.pdg.inst.id !1221"
Planner:            Loop nesting level: 4
Planner:            Hotness = 9.475207e+00 %
Planner:            Average instructions per invocation = 7.603505e+04 %
Planner:            Average iterations per invocation = 2.570002e+02 %
Planner:          
Planner:      ID: 20 (2)
Planner:        Function: "main"
Planner:        Loop: "  %140 = icmp slt i64 %indvars.iv13.i4, %52, !noelle.pdg.inst.id !1257"
Planner:        Loop nesting level: 2
Planner:        Hotness = 1.997322e+01 %
Planner:        Average instructions per invocation = 1.312739e+09 %
Planner:        Average iterations per invocation = 2.569000e+02 %
Planner:      
Planner:        ID: 21 (3)
Planner:          Function: "main"
Planner:          Loop: "  %141 = icmp sgt i64 %indvars.iv60, %59, !noelle.pdg.inst.id !1262"
Planner:          Loop nesting level: 3
Planner:          Hotness = 1.997320e+01 %
Planner:          Average instructions per invocation = 5.128883e+06 %
Planner:          Average iterations per invocation = 3.299961e+01 %
Planner:        
Planner:          ID: 22 (4)
Planner:            Function: "main"
Planner:            Loop: "  %142 = icmp slt i64 %indvars.iv7.i7, %58, !noelle.pdg.inst.id !1267"
Planner:            Loop nesting level: 4
Planner:            Hotness = 1.049602e+01 %
Planner:            Average instructions per invocation = 8.422725e+04 %
Planner:            Average iterations per invocation = 2.570008e+02 %
Planner:          
Planner:          ID: 33 (4)
Planner:            Function: "main"
Planner:            Loop: "  %178 = icmp slt i64 %indvars.iv11.i47, %58, !noelle.pdg.inst.id !1336"
Planner:            Loop nesting level: 4
Planner:            Hotness = 9.475171e+00 %
Planner:            Average instructions per invocation = 7.603522e+04 %
Planner:            Average iterations per invocation = 2.570008e+02 %
Planner:          
Planner:    ID: 101 (1)
Planner:      Function: "cffts3"
Planner:      Loop: "  %43 = icmp slt i64 %indvars.iv13, %24, !noelle.pdg.inst.id !395"
Planner:      Loop nesting level: 1
Planner:      Hotness = 8.553348e+00 %
Planner:      Average instructions per invocation = 5.621683e+09 %
Planner:      Average iterations per invocation = 2.565000e+02 %
Planner:    
Planner:      ID: 102 (2)
Planner:        Function: "cffts3"
Planner:        Loop: "  %44 = icmp sgt i64 %indvars.iv12, %37, !noelle.pdg.inst.id !401"
Planner:        Loop nesting level: 2
Planner:        Hotness = 8.553346e+00 %
Planner:        Average instructions per invocation = 2.195969e+07 %
Planner:        Average iterations per invocation = 3.299805e+01 %
Planner:      
Planner:        ID: 103 (3)
Planner:          Function: "cffts3"
Planner:          Loop: "  %45 = icmp slt i64 %indvars.iv7, %29, !noelle.pdg.inst.id !407"
Planner:          Loop nesting level: 3
Planner:          Hotness = 1.049807e+00 %
Planner:          Average instructions per invocation = 8.422667e+04 %
Planner:          Average iterations per invocation = 2.569990e+02 %
Planner:        
Planner:        ID: 109 (3)
Planner:          Function: "cffts3"
Planner:          Loop: "  %132 = icmp slt i64 %indvars.iv10.i.i, %130, !noelle.pdg.inst.id !533"
Planner:          Loop nesting level: 4
Planner:          Hotness = 3.267442e+00 %
Planner:          Average instructions per invocation = 6.553725e+04 %
Planner:          Average iterations per invocation = 2.224989e+01 %
Planner:        
Planner:        ID: 106 (3)
Planner:          Function: "cffts3"
Planner:          Loop: "  %75 = icmp slt i64 %indvars.iv10.i4.i, %73, !noelle.pdg.inst.id !465"
Planner:          Loop nesting level: 4
Planner:          Hotness = 3.286512e+00 %
Planner:          Average instructions per invocation = 6.591975e+04 %
Planner:          Average iterations per invocation = 4.349982e+01 %
Planner:        
Planner:        ID: 114 (3)
Planner:          Function: "cffts3"
Planner:          Loop: "  %193 = icmp slt i64 %indvars.iv11, %29, !noelle.pdg.inst.id !612"
Planner:          Loop nesting level: 3
Planner:          Hotness = 9.477015e-01 %
Planner:          Average instructions per invocation = 7.603471e+04 %
Planner:          Average iterations per invocation = 2.569990e+02 %
Planner:        
Planner:    ID: 53 (1)
Planner:      Function: "compute_indexmap"
Planner:      Loop: "  %15 = icmp slt i64 %indvars.iv10, %4, !noelle.pdg.inst.id !75"
Planner:      Loop nesting level: 1
Planner:      Hotness = 7.179418e-01 %
Planner:      Average instructions per invocation = 4.718668e+08 %
Planner:      Average iterations per invocation = 5.125000e+02 %
Planner:    
Planner:      ID: 54 (2)
Planner:        Function: "compute_indexmap"
Planner:        Loop: "  %23 = icmp slt i64 %indvars.iv8, %8, !noelle.pdg.inst.id !89"
Planner:        Loop nesting level: 2
Planner:        Hotness = 7.179324e-01 %
Planner:        Average instructions per invocation = 9.216029e+05 %
Planner:        Average iterations per invocation = 2.569990e+02 %
Planner:      
Planner:        ID: 55 (3)
Planner:          Function: "compute_indexmap"
Planner:          Loop: "  %33 = icmp slt i64 %indvars.iv6, %12, !noelle.pdg.inst.id !103"
Planner:          Loop nesting level: 3
Planner:          Hotness = 7.153375e-01 %
Planner:          Average instructions per invocation = 3.587000e+03 %
Planner:          Average iterations per invocation = 2.570000e+02 %
Planner:        
Planner:    ID: 85 (1)
Planner:      Function: "cffts2"
Planner:      Loop: "  %43 = icmp slt i64 %indvars.iv13, %24, !noelle.pdg.inst.id !403"
Planner:      Loop nesting level: 1
Planner:      Hotness = 8.553348e+00 %
Planner:      Average instructions per invocation = 5.621683e+09 %
Planner:      Average iterations per invocation = 2.565000e+02 %
Planner:    
Planner:      ID: 86 (2)
Planner:        Function: "cffts2"
Planner:        Loop: "  %44 = icmp sgt i64 %indvars.iv14, %41, !noelle.pdg.inst.id !409"
Planner:        Loop nesting level: 2
Planner:        Hotness = 8.553346e+00 %
Planner:        Average instructions per invocation = 2.195969e+07 %
Planner:        Average iterations per invocation = 3.299805e+01 %
Planner:      
Planner:        ID: 93 (3)
Planner:          Function: "cffts2"
Planner:          Loop: "  %132 = icmp slt i64 %indvars.iv10.i.i, %130, !noelle.pdg.inst.id !541"
Planner:          Loop nesting level: 4
Planner:          Hotness = 3.267442e+00 %
Planner:          Average instructions per invocation = 6.553725e+04 %
Planner:          Average iterations per invocation = 2.224989e+01 %
Planner:        
Planner:        ID: 90 (3)
Planner:          Function: "cffts2"
Planner:          Loop: "  %75 = icmp slt i64 %indvars.iv10.i4.i, %73, !noelle.pdg.inst.id !473"
Planner:          Loop nesting level: 4
Planner:          Hotness = 3.286512e+00 %
Planner:          Average instructions per invocation = 6.591975e+04 %
Planner:          Average iterations per invocation = 4.349982e+01 %
Planner:        
Planner:        ID: 98 (3)
Planner:          Function: "cffts2"
Planner:          Loop: "  %193 = icmp slt i64 %indvars.iv11, %31, !noelle.pdg.inst.id !620"
Planner:          Loop nesting level: 3
Planner:          Hotness = 9.477015e-01 %
Planner:          Average instructions per invocation = 7.603471e+04 %
Planner:          Average iterations per invocation = 2.569990e+02 %
Planner:        
Planner:        ID: 87 (3)
Planner:          Function: "cffts2"
Planner:          Loop: "  %45 = icmp slt i64 %indvars.iv7, %31, !noelle.pdg.inst.id !415"
Planner:          Loop nesting level: 3
Planner:          Hotness = 1.049807e+00 %
Planner:          Average instructions per invocation = 8.422667e+04 %
Planner:          Average iterations per invocation = 2.569990e+02 %
Planner:        
Planner:    ID: 57 (1)
Planner:      Function: "compute_initial_conditions"
Planner:      Loop: "  %34 = icmp slt i64 %indvars.iv8, %20, !noelle.pdg.inst.id !141"
Planner:      Loop nesting level: 1
Planner:      Hotness = 4.085625e+00 %
Planner:      Average instructions per invocation = 2.685275e+09 %
Planner:      Average iterations per invocation = 2.565000e+02 %
Planner:    
Planner:      ID: 58 (2)
Planner:        Function: "compute_initial_conditions"
Planner:        Loop: "  %35 = icmp sgt i64 %indvars.iv.i, %24, !noelle.pdg.inst.id !148"
Planner:        Loop nesting level: 2
Planner:        Hotness = 3.063158e+00 %
Planner:        Average instructions per invocation = 7.864294e+06 %
Planner:        Average iterations per invocation = 2.621440e+05 %
Planner:      
Planner:      ID: 59 (2)
Planner:        Function: "compute_initial_conditions"
Planner:        Loop: "  %60 = icmp slt i64 %indvars.iv6, %25, !noelle.pdg.inst.id !180"
Planner:        Loop nesting level: 2
Planner:        Hotness = 1.022454e+00 %
Planner:        Average instructions per invocation = 2.625028e+06 %
Planner:        Average iterations per invocation = 2.569980e+02 %
Planner:      
Planner:        ID: 60 (3)
Planner:          Function: "compute_initial_conditions"
Planner:          Loop: "  %exitcond = icmp eq i64 %indvars.iv, 512, !noelle.pdg.inst.id !189"
Planner:          Loop nesting level: 3
Planner:          Hotness = 1.021455e+00 %
Planner:          Average instructions per invocation = 1.024400e+04 %
Planner:          Average iterations per invocation = 5.129999e+02 %
Planner:        
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
Planner: LoopSelector: Start
Planner: LoopSelector:   Order of loops and their maximum savings
Planner: LoopSelector:    Loop 63
Planner: LoopSelector:      Function: "evolve"
Planner: LoopSelector:      Loop nesting level: 1
Planner: LoopSelector:      "  %16 = icmp slt i64 %indvars.iv5, %8, !noelle.pdg.inst.id !61"
Planner: LoopSelector:      Coverage: 1.073010e+01%
Planner: LoopSelector:      Whole-program savings = 1.073010e+01%
Planner: LoopSelector:      Loop savings = 1.000000e+02%
Planner: LoopSelector:    Loop 64
Planner: LoopSelector:      Function: "evolve"
Planner: LoopSelector:      Loop nesting level: 2
Planner: LoopSelector:      "  %17 = icmp slt i64 %indvars.iv3, %11, !noelle.pdg.inst.id !67"
Planner: LoopSelector:      Coverage: 1.073007e+01%
Planner: LoopSelector:      Whole-program savings = 1.073007e+01%
Planner: LoopSelector:      Loop savings = 1.000000e+02%
Planner: LoopSelector:    Loop 65
Planner: LoopSelector:      Function: "evolve"
Planner: LoopSelector:      Loop nesting level: 3
Planner: LoopSelector:      "  %18 = icmp slt i64 %indvars.iv, %14, !noelle.pdg.inst.id !73"
Planner: LoopSelector:      Coverage: 1.072408e+01%
Planner: LoopSelector:      Whole-program savings = 1.072408e+01%
Planner: LoopSelector:      Loop savings = 1.000000e+02%
Planner: LoopSelector: End
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !361
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !359
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !360
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !361
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !359
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !360
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !361
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !359
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !360
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !361
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !359
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !360
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !359
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !360
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !359
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !360
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !359
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !360
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !359
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !360
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !359
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !360
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !359
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !360
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !359
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !360
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !359
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !360
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !359
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !360
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !359
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !360
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !359
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !360
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !359
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !360
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !359
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !360
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !359
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !360
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
Planner: LoopSelector:  Loop 71 saves only 8.691114e-01 when parallelized. Skip it
Planner: LoopSelector:  Loop 72 saves only 8.681953e-01 when parallelized. Skip it
Planner: LoopSelector:  Loop 83 saves only 8.681953e-01 when parallelized. Skip it
Planner: LoopSelector:  Loop 80 saves only 8.966320e-01 when parallelized. Skip it
Planner: LoopSelector:  Loop 82 saves only 8.689119e-01 when parallelized. Skip it
Planner: LoopSelector: Start
Planner: LoopSelector:   Order of loops and their maximum savings
Planner: LoopSelector:    Loop 69
Planner: LoopSelector:      Function: "cffts1"
Planner: LoopSelector:      Loop nesting level: 1
Planner: LoopSelector:      "  %43 = icmp slt i64 %indvars.iv12, %24, !noelle.pdg.inst.id !403"
Planner: LoopSelector:      Coverage: 1.000171e+01%
Planner: LoopSelector:      Whole-program savings = 5.253809e+00%
Planner: LoopSelector:      Loop savings = 5.252910e+01%
Planner: LoopSelector:    Loop 70
Planner: LoopSelector:      Function: "cffts1"
Planner: LoopSelector:      Loop nesting level: 2
Planner: LoopSelector:      "  %44 = icmp sgt i64 %indvars.iv11, %37, !noelle.pdg.inst.id !409"
Planner: LoopSelector:      Coverage: 1.000171e+01%
Planner: LoopSelector:      Whole-program savings = 5.253806e+00%
Planner: LoopSelector:      Loop savings = 5.252909e+01%
Planner: LoopSelector:    Loop 74
Planner: LoopSelector:      Function: "cffts1"
Planner: LoopSelector:      Loop nesting level: 4
Planner: LoopSelector:      "  %77 = icmp slt i64 %indvars.iv10.i4.i, %75, !noelle.pdg.inst.id !472"
Planner: LoopSelector:      Coverage: 4.098632e+00%
Planner: LoopSelector:      Whole-program savings = 3.588105e+00%
Planner: LoopSelector:      Loop savings = 8.754396e+01%
Planner: LoopSelector:    Loop 77
Planner: LoopSelector:      Function: "cffts1"
Planner: LoopSelector:      Loop nesting level: 4
Planner: LoopSelector:      "  %134 = icmp slt i64 %indvars.iv10.i.i, %132, !noelle.pdg.inst.id !541"
Planner: LoopSelector:      Coverage: 3.267374e+00%
Planner: LoopSelector:      Whole-program savings = 2.858952e+00%
Planner: LoopSelector:      Loop savings = 8.750000e+01%
Planner: LoopSelector: End
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1042
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1042 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1043
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1043 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1042
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1042 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1043
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1043 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1042
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1043
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1042
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1043
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1042
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1043
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1042
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1043
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1042
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1043
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1042
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1043
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1042
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1043
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1042
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1043
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1042
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1043
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1042
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1043
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1042
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1043
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1042
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1043
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1042
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1043
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1042
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1043
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1042
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1043
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1042
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1043
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1042
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1043
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1042
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1043
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1042
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1043
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1042
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1043
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1042
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1043
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1042
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1043
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1042
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1043
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1042
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1043
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1042
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1043
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1042
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1043
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1042
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1043
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1042
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1043
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
Planner: LoopSelector: Start
Planner: LoopSelector:   Order of loops and their maximum savings
Planner: LoopSelector:    Loop 2
Planner: LoopSelector:      Function: "main"
Planner: LoopSelector:      Loop nesting level: 1
Planner: LoopSelector:      "  %exitcond1 = icmp eq i32 %.01, %70, !noelle.pdg.inst.id !1113"
Planner: LoopSelector:      Coverage: 6.805510e+01%
Planner: LoopSelector:      Whole-program savings = 4.507409e+01%
Planner: LoopSelector:      Loop savings = 6.623177e+01%
Planner: LoopSelector:    Loop 4
Planner: LoopSelector:      Function: "main"
Planner: LoopSelector:      Loop nesting level: 2
Planner: LoopSelector:      "  %81 = icmp slt i64 %indvars.iv13.i, %40, !noelle.pdg.inst.id !1132"
Planner: LoopSelector:      Coverage: 1.997330e+01%
Planner: LoopSelector:      Whole-program savings = 1.588987e+01%
Planner: LoopSelector:      Loop savings = 7.955556e+01%
Planner: LoopSelector:    Loop 5
Planner: LoopSelector:      Function: "main"
Planner: LoopSelector:      Loop nesting level: 3
Planner: LoopSelector:      "  %82 = icmp sgt i64 %indvars.iv, %49, !noelle.pdg.inst.id !1138"
Planner: LoopSelector:      Coverage: 1.997328e+01%
Planner: LoopSelector:      Whole-program savings = 1.588985e+01%
Planner: LoopSelector:      Loop savings = 7.955553e+01%
Planner: LoopSelector:    Loop 20
Planner: LoopSelector:      Function: "main"
Planner: LoopSelector:      Loop nesting level: 2
Planner: LoopSelector:      "  %140 = icmp slt i64 %indvars.iv13.i4, %52, !noelle.pdg.inst.id !1257"
Planner: LoopSelector:      Coverage: 1.997322e+01%
Planner: LoopSelector:      Whole-program savings = 1.588981e+01%
Planner: LoopSelector:      Loop savings = 7.955556e+01%
Planner: LoopSelector:    Loop 21
Planner: LoopSelector:      Function: "main"
Planner: LoopSelector:      Loop nesting level: 3
Planner: LoopSelector:      "  %141 = icmp sgt i64 %indvars.iv60, %59, !noelle.pdg.inst.id !1262"
Planner: LoopSelector:      Coverage: 1.997320e+01%
Planner: LoopSelector:      Whole-program savings = 1.588979e+01%
Planner: LoopSelector:      Loop savings = 7.955553e+01%
Planner: LoopSelector:    Loop 36
Planner: LoopSelector:      Function: "main"
Planner: LoopSelector:      Loop nesting level: 2
Planner: LoopSelector:      "  %199 = icmp slt i64 %indvars.iv12.i, %62, !noelle.pdg.inst.id !1372"
Planner: LoopSelector:      Coverage: 1.737782e+01%
Planner: LoopSelector:      Whole-program savings = 1.533611e+01%
Planner: LoopSelector:      Loop savings = 8.825109e+01%
Planner: LoopSelector:    Loop 37
Planner: LoopSelector:      Function: "main"
Planner: LoopSelector:      Loop nesting level: 3
Planner: LoopSelector:      "  %200 = icmp sgt i64 %indvars.iv62, %69, !noelle.pdg.inst.id !1377"
Planner: LoopSelector:      Coverage: 1.737779e+01%
Planner: LoopSelector:      Whole-program savings = 1.533609e+01%
Planner: LoopSelector:      Loop savings = 8.825108e+01%
Planner: LoopSelector:    Loop 6
Planner: LoopSelector:      Function: "main"
Planner: LoopSelector:      Loop nesting level: 4
Planner: LoopSelector:      "  %83 = icmp slt i64 %indvars.iv7.i, %48, !noelle.pdg.inst.id !1144"
Planner: LoopSelector:      Coverage: 1.049606e+01%
Planner: LoopSelector:      Whole-program savings = 1.049606e+01%
Planner: LoopSelector:      Loop savings = 1.000000e+02%
Planner: LoopSelector:    Loop 22
Planner: LoopSelector:      Function: "main"
Planner: LoopSelector:      Loop nesting level: 4
Planner: LoopSelector:      "  %142 = icmp slt i64 %indvars.iv7.i7, %58, !noelle.pdg.inst.id !1267"
Planner: LoopSelector:      Coverage: 1.049602e+01%
Planner: LoopSelector:      Whole-program savings = 1.049602e+01%
Planner: LoopSelector:      Loop savings = 1.000000e+02%
Planner: LoopSelector:    Loop 17
Planner: LoopSelector:      Function: "main"
Planner: LoopSelector:      Loop nesting level: 4
Planner: LoopSelector:      "  %119 = icmp slt i64 %indvars.iv11.i, %48, !noelle.pdg.inst.id !1221"
Planner: LoopSelector:      Coverage: 9.475207e+00%
Planner: LoopSelector:      Whole-program savings = 9.475207e+00%
Planner: LoopSelector:      Loop savings = 1.000000e+02%
Planner: LoopSelector:    Loop 33
Planner: LoopSelector:      Function: "main"
Planner: LoopSelector:      Loop nesting level: 4
Planner: LoopSelector:      "  %178 = icmp slt i64 %indvars.iv11.i47, %58, !noelle.pdg.inst.id !1336"
Planner: LoopSelector:      Coverage: 9.475171e+00%
Planner: LoopSelector:      Whole-program savings = 9.475171e+00%
Planner: LoopSelector:      Loop savings = 1.000000e+02%
Planner: LoopSelector:    Loop 38
Planner: LoopSelector:      Function: "main"
Planner: LoopSelector:      Loop nesting level: 4
Planner: LoopSelector:      "  %201 = icmp slt i64 %indvars.iv6.i, %47, !noelle.pdg.inst.id !1383"
Planner: LoopSelector:      Coverage: 8.689389e+00%
Planner: LoopSelector:      Whole-program savings = 8.689389e+00%
Planner: LoopSelector:      Loop savings = 1.000000e+02%
Planner: LoopSelector:    Loop 49
Planner: LoopSelector:      Function: "main"
Planner: LoopSelector:      Loop nesting level: 4
Planner: LoopSelector:      "  %239 = icmp slt i64 %indvars.iv10.i, %47, !noelle.pdg.inst.id !1456"
Planner: LoopSelector:      Coverage: 8.687396e+00%
Planner: LoopSelector:      Whole-program savings = 8.687396e+00%
Planner: LoopSelector:      Loop savings = 1.000000e+02%
Planner: LoopSelector:    Loop 39
Planner: LoopSelector:      Function: "main"
Planner: LoopSelector:      Loop nesting level: 5
Planner: LoopSelector:      "  %206 = icmp slt i64 %indvars.iv.i5, %68, !noelle.pdg.inst.id !1392"
Planner: LoopSelector:      Coverage: 8.680230e+00%
Planner: LoopSelector:      Whole-program savings = 8.680230e+00%
Planner: LoopSelector:      Loop savings = 1.000000e+02%
Planner: LoopSelector:    Loop 50
Planner: LoopSelector:      Function: "main"
Planner: LoopSelector:      Loop nesting level: 5
Planner: LoopSelector:      "  %243 = icmp slt i64 %indvars.iv8.i, %68, !noelle.pdg.inst.id !1462"
Planner: LoopSelector:      Coverage: 8.680230e+00%
Planner: LoopSelector:      Whole-program savings = 8.680230e+00%
Planner: LoopSelector:      Loop savings = 1.000000e+02%
Planner: LoopSelector: End
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !353
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !351
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !352
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !353
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !351
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !352
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !353
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !351
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !352
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !353
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !351
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !352
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !353
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !351
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !352
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !353
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !351
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !352
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !353
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !351
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !352
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !353
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !351
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !352
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !353
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !351
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !352
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !353
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !351
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !352
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !353
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !351
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !352
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !353
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !351
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !352
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
Planner: LoopSelector:  Loop 103 saves only 1.049807e+00 when parallelized. Skip it
Planner: LoopSelector:  Loop 114 saves only 9.477015e-01 when parallelized. Skip it
Planner: LoopSelector: Start
Planner: LoopSelector:   Order of loops and their maximum savings
Planner: LoopSelector:    Loop 101
Planner: LoopSelector:      Function: "cffts3"
Planner: LoopSelector:      Loop nesting level: 1
Planner: LoopSelector:      "  %43 = icmp slt i64 %indvars.iv13, %24, !noelle.pdg.inst.id !395"
Planner: LoopSelector:      Coverage: 8.553348e+00%
Planner: LoopSelector:      Whole-program savings = 4.673349e+00%
Planner: LoopSelector:      Loop savings = 5.463766e+01%
Planner: LoopSelector:    Loop 102
Planner: LoopSelector:      Function: "cffts3"
Planner: LoopSelector:      Loop nesting level: 2
Planner: LoopSelector:      "  %44 = icmp sgt i64 %indvars.iv12, %37, !noelle.pdg.inst.id !401"
Planner: LoopSelector:      Coverage: 8.553346e+00%
Planner: LoopSelector:      Whole-program savings = 4.673347e+00%
Planner: LoopSelector:      Loop savings = 5.463765e+01%
Planner: LoopSelector:    Loop 106
Planner: LoopSelector:      Function: "cffts3"
Planner: LoopSelector:      Loop nesting level: 4
Planner: LoopSelector:      "  %75 = icmp slt i64 %indvars.iv10.i4.i, %73, !noelle.pdg.inst.id !465"
Planner: LoopSelector:      Coverage: 3.286512e+00%
Planner: LoopSelector:      Whole-program savings = 2.878091e+00%
Planner: LoopSelector:      Loop savings = 8.757282e+01%
Planner: LoopSelector:    Loop 109
Planner: LoopSelector:      Function: "cffts3"
Planner: LoopSelector:      Loop nesting level: 4
Planner: LoopSelector:      "  %132 = icmp slt i64 %indvars.iv10.i.i, %130, !noelle.pdg.inst.id !533"
Planner: LoopSelector:      Coverage: 3.267442e+00%
Planner: LoopSelector:      Whole-program savings = 2.859021e+00%
Planner: LoopSelector:      Loop savings = 8.750029e+01%
Planner: LoopSelector: End
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
Planner: LoopSelector:  Loop 55 saves only 7.153375e-01 when parallelized. Skip it
Planner: LoopSelector:  Loop 53 saves only 7.179418e-01 when parallelized. Skip it
Planner: LoopSelector:  Loop 54 saves only 7.179324e-01 when parallelized. Skip it
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !361
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !359
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !360
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !361
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !359
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !360
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !361
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !359
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !360
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !361
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !359
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !360
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !359
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !360
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !359
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !360
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !359
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !360
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !359
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !360
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !359
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !360
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !359
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !360
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !359
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !360
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !359
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !360
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
Planner: LoopSelector:  Loop 98 saves only 9.477015e-01 when parallelized. Skip it
Planner: LoopSelector:  Loop 87 saves only 1.049807e+00 when parallelized. Skip it
Planner: LoopSelector: Start
Planner: LoopSelector:   Order of loops and their maximum savings
Planner: LoopSelector:    Loop 85
Planner: LoopSelector:      Function: "cffts2"
Planner: LoopSelector:      Loop nesting level: 1
Planner: LoopSelector:      "  %43 = icmp slt i64 %indvars.iv13, %24, !noelle.pdg.inst.id !403"
Planner: LoopSelector:      Coverage: 8.553348e+00%
Planner: LoopSelector:      Whole-program savings = 4.469139e+00%
Planner: LoopSelector:      Loop savings = 5.225017e+01%
Planner: LoopSelector:    Loop 86
Planner: LoopSelector:      Function: "cffts2"
Planner: LoopSelector:      Loop nesting level: 2
Planner: LoopSelector:      "  %44 = icmp sgt i64 %indvars.iv14, %41, !noelle.pdg.inst.id !409"
Planner: LoopSelector:      Coverage: 8.553346e+00%
Planner: LoopSelector:      Whole-program savings = 4.469137e+00%
Planner: LoopSelector:      Loop savings = 5.225016e+01%
Planner: LoopSelector:    Loop 90
Planner: LoopSelector:      Function: "cffts2"
Planner: LoopSelector:      Loop nesting level: 4
Planner: LoopSelector:      "  %75 = icmp slt i64 %indvars.iv10.i4.i, %73, !noelle.pdg.inst.id !473"
Planner: LoopSelector:      Coverage: 3.286512e+00%
Planner: LoopSelector:      Whole-program savings = 2.878091e+00%
Planner: LoopSelector:      Loop savings = 8.757282e+01%
Planner: LoopSelector:    Loop 93
Planner: LoopSelector:      Function: "cffts2"
Planner: LoopSelector:      Loop nesting level: 4
Planner: LoopSelector:      "  %132 = icmp slt i64 %indvars.iv10.i.i, %130, !noelle.pdg.inst.id !541"
Planner: LoopSelector:      Coverage: 3.267442e+00%
Planner: LoopSelector:      Whole-program savings = 2.859021e+00%
Planner: LoopSelector:      Loop savings = 8.750029e+01%
Planner: LoopSelector: End
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8, !noelle.pdg.inst.id !109
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8, !noelle.pdg.inst.id !108
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8, !noelle.pdg.inst.id !109
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8, !noelle.pdg.inst.id !108
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8, !noelle.pdg.inst.id !109
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8, !noelle.pdg.inst.id !108
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8, !noelle.pdg.inst.id !109
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8, !noelle.pdg.inst.id !108
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8, !noelle.pdg.inst.id !109
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8, !noelle.pdg.inst.id !108
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8, !noelle.pdg.inst.id !109
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8, !noelle.pdg.inst.id !108
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8, !noelle.pdg.inst.id !109
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8, !noelle.pdg.inst.id !108
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8, !noelle.pdg.inst.id !109
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8, !noelle.pdg.inst.id !108
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
Planner: LoopSelector:  Loop 60 saves only 1.021455e+00 when parallelized. Skip it
Planner: LoopSelector:  Loop 58 saves only 8.168430e-01 when parallelized. Skip it
Planner: LoopSelector:  Loop 59 saves only 9.198491e-01 when parallelized. Skip it
Planner: LoopSelector: Start
Planner: LoopSelector:   Order of loops and their maximum savings
Planner: LoopSelector:    Loop 57
Planner: LoopSelector:      Function: "compute_initial_conditions"
Planner: LoopSelector:      Loop nesting level: 1
Planner: LoopSelector:      "  %34 = icmp slt i64 %indvars.iv8, %20, !noelle.pdg.inst.id !141"
Planner: LoopSelector:      Coverage: 4.085625e+00%
Planner: LoopSelector:      Whole-program savings = 3.881414e+00%
Planner: LoopSelector:      Loop savings = 9.500172e+01%
Planner: LoopSelector: End
Planner:   Maximum time saved = 9.648172e+01% (126825112648)
Planner:   Maximum time saved with DOALL only = 1.073010e+01% (14104702208)
Planner: Exit
noelle-rm-function -function-name=SIMONE_CAMPANONI_IS_GOING_TO_REMOVE_THIS_FUNCTION code_with_prototypes.bc -o code_to_parallelize.bc
NOELLE: DeadFunctions: Start
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/RemoveFunction.so -noelle-rm-function -function-name=SIMONE_CAMPANONI_IS_GOING_TO_REMOVE_THIS_FUNCTION code_with_prototypes.bc -o code_to_parallelize.bc
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/RemoveFunction.so -noelle-rm-function -function-name=SIMONE_CAMPANONI_IS_GOING_TO_REMOVE_THIS_FUNCTION code_with_prototypes.bc -o code_to_parallelize.bc
RemoveFunction: Start
RemoveFunction:   Check if function "SIMONE_CAMPANONI_IS_GOING_TO_REMOVE_THIS_FUNCTION" exists
RemoveFunction:     The function exists
RemoveFunction:   Remove the function
RemoveFunction: Exit
NOELLE: DeadFunctions: Exit
noelle-parallelizer-loop code_to_parallelize.bc -o parallelized_unoptimized.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Parallelizer.so -parallelizer code_to_parallelize.bc -o parallelized_unoptimized.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Parallelizer.so -parallelizer code_to_parallelize.bc -o parallelized_unoptimized.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Parallelizer.so -parallelizer code_to_parallelize.bc -o parallelized_unoptimized.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
Parallelizer: Start
Parallelizer:  Analyzing the module code_to_parallelize.bc
Parallelizer:  Fetching the program loops
Noelle: Filter out cold code
Noelle:  Function "main"
Noelle:     Loop "  %exitcond8 = icmp eq i32 %.02, 7, !noelle.pdg.inst.id !1054" (5.096999e-08%)
Noelle:  Disable loop "0" as cold code
Noelle:     Loop "  %exitcond = icmp eq i32 %.1, 7, !noelle.pdg.inst.id !1073" (5.096999e-08%)
Noelle:  Disable loop "1" as cold code
Noelle:     Loop "  %exitcond1 = icmp eq i32 %.01, %70, !noelle.pdg.inst.id !1115" (6.805510e+01%)
Noelle:     Loop "  %exitcond.i = icmp eq i64 %indvars.iv15.i, 3, !noelle.pdg.inst.id !1126" (2.738686e-07%)
Noelle:  Disable loop "3" as cold code
Noelle:     Loop "  %81 = icmp slt i64 %indvars.iv13.i, %40, !noelle.pdg.inst.id !1135" (1.997330e+01%)
Noelle:     Loop "  %82 = icmp sgt i64 %indvars.iv, %49, !noelle.pdg.inst.id !1142" (1.997328e+01%)
Noelle:     Loop "  %83 = icmp slt i64 %indvars.iv7.i, %48, !noelle.pdg.inst.id !1149" (1.049606e+01%)
Noelle:     Loop "  %84 = icmp slt i64 %indvars.iv.i, %47, !noelle.pdg.inst.id !1156" (1.030428e+01%)
Noelle:     Loop "  br i1 false, label %.preheader.i.i..loopexit.i.i_crit_edge, label %100, !prof !1178, !noelle.loop.id !1139, !noelle.pdg.inst.id !1182" (4.984683e-04%)
Noelle:  Disable loop "8" as cold code
Noelle:     Loop "  br i1 false, label %101, label %.us-lcssa.us.loopexit1.i19.i.i, !prof !1178, !noelle.loop.id !1146, !noelle.pdg.inst.id !1185" (1.246163e-04%)
Noelle:  Disable loop "9" as cold code
Noelle:     Loop "  br i1 false, label %103, label %107, !noelle.loop.id !1187, !noelle.pdg.inst.id !1188" (0.000000e+00%)
Noelle:  Disable loop "10" as cold code
Noelle:     Loop "  br i1 false, label %105, label %106, !noelle.loop.id !1190, !noelle.pdg.inst.id !1191" (0.000000e+00%)
Noelle:  Disable loop "11" as cold code
Noelle:     Loop "  br i1 false, label %109, label %.us-lcssa.us.loopexit1.i.i.i, !noelle.loop.id !1198, !noelle.pdg.inst.id !1199" (3.042985e-09%)
Noelle:  Disable loop "12" as cold code
Noelle:     Loop "  br i1 false, label %111, label %115, !noelle.loop.id !1201, !noelle.pdg.inst.id !1202" (3.042985e-09%)
Noelle:  Disable loop "13" as cold code
Noelle:     Loop "  br i1 false, label %113, label %114, !noelle.loop.id !1153, !noelle.pdg.inst.id !1204" (3.042985e-09%)
Noelle:  Disable loop "14" as cold code
Noelle:     Loop "  br i1 false, label %.preheader1.i.i.preheader, label %cfftz.exit.i.loopexit, !noelle.loop.id !1213, !noelle.pdg.inst.id !1214" (0.000000e+00%)
Noelle:  Disable loop "15" as cold code
Noelle:     Loop "  br i1 false, label %116, label %117, !noelle.loop.id !1216, !noelle.pdg.inst.id !1217" (0.000000e+00%)
Noelle:  Disable loop "16" as cold code
Noelle:     Loop "  %119 = icmp slt i64 %indvars.iv11.i, %48, !noelle.pdg.inst.id !1223" (9.475207e+00%)
Noelle:     Loop "  %120 = icmp slt i64 %indvars.iv9.i, %47, !noelle.pdg.inst.id !1228" (9.283423e+00%)
Noelle:     Loop "  %exitcond.i2 = icmp eq i64 %indvars.iv15.i1, 3, !noelle.pdg.inst.id !1251" (2.738686e-07%)
Noelle:  Disable loop "19" as cold code
Noelle:     Loop "  %140 = icmp slt i64 %indvars.iv13.i4, %52, !noelle.pdg.inst.id !1259" (1.997322e+01%)
Noelle:     Loop "  %141 = icmp sgt i64 %indvars.iv60, %59, !noelle.pdg.inst.id !1264" (1.997320e+01%)
Noelle:     Loop "  %142 = icmp slt i64 %indvars.iv7.i7, %58, !noelle.pdg.inst.id !1269" (1.049602e+01%)
Noelle:     Loop "  %143 = icmp slt i64 %indvars.iv.i9, %47, !noelle.pdg.inst.id !1274" (1.030424e+01%)
Noelle:     Loop "  br i1 false, label %.preheader.i.i16..loopexit.i.i38_crit_edge, label %159, !prof !1178, !noelle.loop.id !1295, !noelle.pdg.inst.id !1296" (4.984652e-04%)
Noelle:  Disable loop "24" as cold code
Noelle:     Loop "  br i1 false, label %160, label %.us-lcssa.us.loopexit1.i19.i.i27, !prof !1178, !noelle.loop.id !1299, !noelle.pdg.inst.id !1300" (1.246155e-04%)
Noelle:  Disable loop "25" as cold code
Noelle:     Loop "  br i1 false, label %162, label %166, !noelle.loop.id !1302, !noelle.pdg.inst.id !1303" (0.000000e+00%)
Noelle:  Disable loop "26" as cold code
Noelle:     Loop "  br i1 false, label %164, label %165, !noelle.loop.id !1305, !noelle.pdg.inst.id !1306" (0.000000e+00%)
Noelle:  Disable loop "27" as cold code
Noelle:     Loop "  br i1 false, label %168, label %.us-lcssa.us.loopexit1.i.i.i37, !noelle.loop.id !1312, !noelle.pdg.inst.id !1313" (3.042985e-09%)
Noelle:  Disable loop "28" as cold code
Noelle:     Loop "  br i1 false, label %170, label %174, !noelle.loop.id !1315, !noelle.pdg.inst.id !1316" (3.042985e-09%)
Noelle:  Disable loop "29" as cold code
Noelle:     Loop "  br i1 false, label %172, label %173, !noelle.loop.id !1318, !noelle.pdg.inst.id !1319" (3.042985e-09%)
Noelle:  Disable loop "30" as cold code
Noelle:     Loop "  br i1 false, label %.preheader1.i.i41.preheader, label %cfftz.exit.i46.loopexit, !noelle.loop.id !1328, !noelle.pdg.inst.id !1329" (0.000000e+00%)
Noelle:  Disable loop "31" as cold code
Noelle:     Loop "  br i1 false, label %175, label %176, !noelle.loop.id !1331, !noelle.pdg.inst.id !1332" (0.000000e+00%)
Noelle:  Disable loop "32" as cold code
Noelle:     Loop "  %178 = icmp slt i64 %indvars.iv11.i47, %58, !noelle.pdg.inst.id !1338" (9.475171e+00%)
Noelle:     Loop "  %179 = icmp slt i64 %indvars.iv9.i49, %47, !noelle.pdg.inst.id !1343" (9.283387e+00%)
Noelle:     Loop "  %exitcond.i1 = icmp eq i64 %indvars.iv14.i, 3, !noelle.pdg.inst.id !1366" (2.738686e-07%)
Noelle:  Disable loop "35" as cold code
Noelle:     Loop "  %199 = icmp slt i64 %indvars.iv12.i, %62, !noelle.pdg.inst.id !1374" (1.737782e+01%)
Noelle:     Loop "  %200 = icmp sgt i64 %indvars.iv62, %69, !noelle.pdg.inst.id !1379" (1.737779e+01%)
Noelle:     Loop "  %201 = icmp slt i64 %indvars.iv6.i, %47, !noelle.pdg.inst.id !1385" (8.689389e+00%)
Noelle:     Loop "  %206 = icmp slt i64 %indvars.iv.i5, %68, !noelle.pdg.inst.id !1394" (8.680230e+00%)
Noelle:     Loop "  br i1 false, label %.preheader.i.i11..loopexit.i.i33_crit_edge, label %220, !prof !1410, !noelle.loop.id !1414, !noelle.pdg.inst.id !1415" (2.492341e-04%)
Noelle:  Disable loop "40" as cold code
Noelle:     Loop "  br i1 false, label %221, label %.us-lcssa.us.loopexit1.i19.i.i22, !prof !1410, !noelle.loop.id !1418, !noelle.pdg.inst.id !1419" (6.230815e-05%)
Noelle:  Disable loop "41" as cold code
Noelle:     Loop "  br i1 false, label %223, label %227, !noelle.loop.id !1421, !noelle.pdg.inst.id !1422" (0.000000e+00%)
Noelle:  Disable loop "42" as cold code
Noelle:     Loop "  br i1 false, label %225, label %226, !noelle.loop.id !1424, !noelle.pdg.inst.id !1425" (0.000000e+00%)
Noelle:  Disable loop "43" as cold code
Noelle:     Loop "  br i1 false, label %229, label %.us-lcssa.us.loopexit1.i.i.i32, !noelle.loop.id !1432, !noelle.pdg.inst.id !1433" (1.521492e-09%)
Noelle:  Disable loop "44" as cold code
Noelle:     Loop "  br i1 false, label %231, label %235, !noelle.loop.id !1435, !noelle.pdg.inst.id !1436" (1.521492e-09%)
Noelle:  Disable loop "45" as cold code
Noelle:     Loop "  br i1 false, label %233, label %234, !noelle.loop.id !1438, !noelle.pdg.inst.id !1439" (1.521492e-09%)
Noelle:  Disable loop "46" as cold code
Noelle:     Loop "  br i1 false, label %.preheader1.i.i36.preheader, label %cfftz.exit.i41.loopexit, !noelle.loop.id !1448, !noelle.pdg.inst.id !1449" (0.000000e+00%)
Noelle:  Disable loop "47" as cold code
Noelle:     Loop "  br i1 false, label %236, label %237, !noelle.loop.id !1451, !noelle.pdg.inst.id !1452" (0.000000e+00%)
Noelle:  Disable loop "48" as cold code
Noelle:     Loop "  %239 = icmp slt i64 %indvars.iv10.i, %47, !noelle.pdg.inst.id !1458" (8.687396e+00%)
Noelle:     Loop "  %243 = icmp slt i64 %indvars.iv8.i, %68, !noelle.pdg.inst.id !1464" (8.680230e+00%)
Noelle:  Function "fft"
Noelle:  Function "evolve"
Noelle:     Loop "  %16 = icmp slt i64 %indvars.iv5, %8, !noelle.pdg.inst.id !63" (1.073010e+01%)
Noelle:     Loop "  %17 = icmp slt i64 %indvars.iv3, %11, !noelle.pdg.inst.id !70" (1.073007e+01%)
Noelle:     Loop "  %18 = icmp slt i64 %indvars.iv, %14, !noelle.pdg.inst.id !77" (1.072408e+01%)
Noelle:  Function "cffts1"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv14, 3, !noelle.pdg.inst.id !368" (3.294031e-07%)
Noelle:  Disable loop "54" as cold code
Noelle:     Loop "  %43 = icmp slt i64 %indvars.iv12, %24, !noelle.pdg.inst.id !405" (1.000171e+01%)
Noelle:     Loop "  %44 = icmp sgt i64 %indvars.iv11, %37, !noelle.pdg.inst.id !412" (1.000171e+01%)
Noelle:     Loop "  %45 = icmp slt i64 %indvars.iv6, %36, !noelle.pdg.inst.id !419" (8.691114e-01%)
Noelle:     Loop "  %50 = icmp slt i64 %indvars.iv, %29, !noelle.pdg.inst.id !428" (8.681953e-01%)
Noelle:     Loop "  %65 = icmp slt i32 %21, %.0.i, !noelle.pdg.inst.id !455" (7.366971e+00%)
Noelle:     Loop "  %77 = icmp slt i64 %indvars.iv10.i4.i, %75, !noelle.pdg.inst.id !476" (4.098632e+00%)
Noelle:     Loop "  %89 = icmp slt i64 %indvars.iv8.i6.i, %74, !noelle.pdg.inst.id !490" (4.066661e+00%)
Noelle:     Loop "  %97 = icmp slt i64 %indvars.iv.i8.i, %36, !noelle.pdg.inst.id !502" (3.980516e+00%)
Noelle:     Loop "  %134 = icmp slt i64 %indvars.iv10.i.i, %132, !noelle.pdg.inst.id !546" (3.267374e+00%)
Noelle:     Loop "  %146 = icmp slt i64 %indvars.iv8.i.i, %131, !noelle.pdg.inst.id !560" (3.251407e+00%)
Noelle:     Loop "  %154 = icmp slt i64 %indvars.iv.i.i, %36, !noelle.pdg.inst.id !572" (3.184413e+00%)
Noelle:     Loop "  %180 = icmp slt i64 %indvars.iv5.i, %29, !noelle.pdg.inst.id !605" (8.966320e-01%)
Noelle:     Loop "  %181 = icmp slt i64 %indvars.iv.i, %36, !noelle.pdg.inst.id !611" (8.774685e-01%)
Noelle:     Loop "  %195 = icmp slt i64 %indvars.iv10, %36, !noelle.pdg.inst.id !630" (8.689119e-01%)
Noelle:     Loop "  %199 = icmp slt i64 %indvars.iv8, %29, !noelle.pdg.inst.id !636" (8.681953e-01%)
Noelle:  Function "cffts2"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3, !noelle.pdg.inst.id !368" (3.294031e-07%)
Noelle:  Disable loop "70" as cold code
Noelle:     Loop "  %43 = icmp slt i64 %indvars.iv13, %24, !noelle.pdg.inst.id !405" (8.553348e+00%)
Noelle:     Loop "  %44 = icmp sgt i64 %indvars.iv14, %41, !noelle.pdg.inst.id !412" (8.553346e+00%)
Noelle:     Loop "  %45 = icmp slt i64 %indvars.iv7, %31, !noelle.pdg.inst.id !419" (1.049807e+00%)
Noelle:     Loop "  %46 = icmp slt i64 %indvars.iv, %30, !noelle.pdg.inst.id !425" (1.030625e+00%)
Noelle:     Loop "  %63 = icmp slt i32 %21, %.0.i, !noelle.pdg.inst.id !455" (6.555687e+00%)
Noelle:     Loop "  %75 = icmp slt i64 %indvars.iv10.i4.i, %73, !noelle.pdg.inst.id !477" (3.286512e+00%)
Noelle:     Loop "  %87 = icmp slt i64 %indvars.iv8.i6.i, %72, !noelle.pdg.inst.id !491" (3.254579e+00%)
Noelle:     Loop "  %95 = icmp slt i64 %indvars.iv.i8.i, %30, !noelle.pdg.inst.id !503" (3.184407e+00%)
Noelle:     Loop "  %132 = icmp slt i64 %indvars.iv10.i.i, %130, !noelle.pdg.inst.id !546" (3.267442e+00%)
Noelle:     Loop "  %144 = icmp slt i64 %indvars.iv8.i.i, %129, !noelle.pdg.inst.id !560" (3.251401e+00%)
Noelle:     Loop "  %152 = icmp slt i64 %indvars.iv.i.i, %30, !noelle.pdg.inst.id !572" (3.184407e+00%)
Noelle:     Loop "  %178 = icmp slt i64 %indvars.iv5.i, %31, !noelle.pdg.inst.id !603" (0.000000e+00%)
Noelle:  Disable loop "82" as cold code
Noelle:     Loop "  %179 = icmp slt i64 %indvars.iv.i, %30, !noelle.pdg.inst.id !608" (0.000000e+00%)
Noelle:  Disable loop "83" as cold code
Noelle:     Loop "  %193 = icmp slt i64 %indvars.iv11, %31, !noelle.pdg.inst.id !626" (9.477015e-01%)
Noelle:     Loop "  %194 = icmp slt i64 %indvars.iv9, %30, !noelle.pdg.inst.id !631" (9.285194e-01%)
Noelle:  Function "cffts3"
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv15, 3, !noelle.pdg.inst.id !360" (3.415750e-07%)
Noelle:  Disable loop "86" as cold code
Noelle:     Loop "  %43 = icmp slt i64 %indvars.iv13, %24, !noelle.pdg.inst.id !397" (8.553348e+00%)
Noelle:     Loop "  %44 = icmp sgt i64 %indvars.iv12, %37, !noelle.pdg.inst.id !404" (8.553346e+00%)
Noelle:     Loop "  %45 = icmp slt i64 %indvars.iv7, %29, !noelle.pdg.inst.id !411" (1.049807e+00%)
Noelle:     Loop "  %46 = icmp slt i64 %indvars.iv, %35, !noelle.pdg.inst.id !417" (1.030625e+00%)
Noelle:     Loop "  %63 = icmp slt i32 %21, %.0.i, !noelle.pdg.inst.id !447" (6.555687e+00%)
Noelle:     Loop "  %75 = icmp slt i64 %indvars.iv10.i4.i, %73, !noelle.pdg.inst.id !469" (3.286512e+00%)
Noelle:     Loop "  %87 = icmp slt i64 %indvars.iv8.i6.i, %72, !noelle.pdg.inst.id !483" (3.254579e+00%)
Noelle:     Loop "  %95 = icmp slt i64 %indvars.iv.i8.i, %35, !noelle.pdg.inst.id !495" (3.184407e+00%)
Noelle:     Loop "  %132 = icmp slt i64 %indvars.iv10.i.i, %130, !noelle.pdg.inst.id !538" (3.267442e+00%)
Noelle:     Loop "  %144 = icmp slt i64 %indvars.iv8.i.i, %129, !noelle.pdg.inst.id !552" (3.251401e+00%)
Noelle:     Loop "  %152 = icmp slt i64 %indvars.iv.i.i, %35, !noelle.pdg.inst.id !564" (3.184407e+00%)
Noelle:     Loop "  %178 = icmp slt i64 %indvars.iv5.i, %29, !noelle.pdg.inst.id !595" (0.000000e+00%)
Noelle:  Disable loop "98" as cold code
Noelle:     Loop "  %179 = icmp slt i64 %indvars.iv.i, %35, !noelle.pdg.inst.id !600" (0.000000e+00%)
Noelle:  Disable loop "99" as cold code
Noelle:     Loop "  %193 = icmp slt i64 %indvars.iv11, %29, !noelle.pdg.inst.id !618" (9.477015e-01%)
Noelle:     Loop "  %194 = icmp slt i64 %indvars.iv9, %35, !noelle.pdg.inst.id !623" (9.285194e-01%)
Noelle:  Function "compute_initial_conditions"
Noelle:     Loop "  %34 = icmp slt i64 %indvars.iv8, %20, !noelle.pdg.inst.id !143" (4.085625e+00%)
Noelle:     Loop "  %35 = icmp sgt i64 %indvars.iv.i, %24, !noelle.pdg.inst.id !151" (3.063158e+00%)
Noelle:     Loop "  %60 = icmp slt i64 %indvars.iv6, %25, !noelle.pdg.inst.id !183" (1.022454e+00%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 512, !noelle.pdg.inst.id !192" (1.021455e+00%)
Noelle:  Function "compute_indexmap"
Noelle:     Loop "  %15 = icmp slt i64 %indvars.iv10, %4, !noelle.pdg.inst.id !77" (7.179418e-01%)
Noelle:     Loop "  %23 = icmp slt i64 %indvars.iv8, %8, !noelle.pdg.inst.id !91" (7.179324e-01%)
Noelle:     Loop "  %33 = icmp slt i64 %indvars.iv6, %12, !noelle.pdg.inst.id !105" (7.153375e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 1966081, !noelle.pdg.inst.id !126" (3.291316e-02%)
Noelle:  Disable loop "109" as cold code
Noelle:  Function "checksum"
Noelle:  Disable "checksum" as cold function
Noelle:  Function "fft_init"
Noelle:  Disable "fft_init" as cold function
Noelle:  Function "ipow46"
Noelle:  Disable "ipow46" as cold function
Noelle:  Function "ilog2"
Noelle:  Disable "ilog2" as cold function
Noelle:  Function "randlc"
Noelle:  Disable "randlc" as cold function
Noelle:  Function "setup"
Noelle:  Disable "setup" as cold function
Noelle:  Function "elapsed_time"
Noelle:  Disable "elapsed_time" as cold function
Noelle:  Function "timer_clear"
Noelle:  Disable "timer_clear" as cold function
Noelle:  Function "c_print_results"
Noelle:  Disable "c_print_results" as cold function
Noelle:  Function "wtime_"
Noelle:  Disable "wtime_" as cold function
Noelle:  Function "timer_stop"
Noelle:  Disable "timer_stop" as cold function
Noelle:  Function "timer_start"
Noelle:  Disable "timer_start" as cold function
Noelle:  Function "verify"
Noelle:  Disable "verify" as cold function
Noelle:  Function "timer_read"
Noelle:  Disable "timer_read" as cold function
Noelle:  Function "vranlc"
Noelle:  Disable "vranlc" as cold function
Parallelizer:    There are 70 loops in the program we are going to consider
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !363
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !362
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !363
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !362
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !363
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !362
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !363
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !362
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !363
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !362
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !363
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !362
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !363
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !362
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !363
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !362
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1048
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1047
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1048
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1047
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1048
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1047
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1048
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1047
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1048
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1047
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1048
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1047
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1048
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1047
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1048
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1047
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1048
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1047
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1048
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1047
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1048
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1047
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1048
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1047
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1048
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1047
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1048
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1047
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1048
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1047
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1048
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1047
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1048
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1047
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1048
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1047
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1048
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1047
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1048
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1047
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1048
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1047
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1048
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1047
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1048
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1047
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1048
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1047
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1048
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1047
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1048
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1047
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1048
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1047
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1048
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1047
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1048
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1047
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i8, align 1, !noelle.pdg.inst.id !1048
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i32, align 4, !noelle.pdg.inst.id !1047
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !363
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !362
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !363
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !362
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !363
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !362
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !363
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !362
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !363
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !362
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !363
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !362
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !363
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !362
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !363
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !361
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !362
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !355
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !353
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !354
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !355
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !353
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !354
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !355
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !353
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !354
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !355
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !353
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !354
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !355
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !353
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !354
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !355
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !353
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !354
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !355
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !353
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !354
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !355
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca [3 x i32], align 4, !noelle.pdg.inst.id !353
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !354
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8, !noelle.pdg.inst.id !111
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8, !noelle.pdg.inst.id !110
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca double, align 8, !noelle.pdg.inst.id !111
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca double, align 8, !noelle.pdg.inst.id !110
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "evolve"
Parallelizer: parallelizerLoop:   Loop 63 = "  %16 = icmp slt i64 %indvars.iv5, %8, !noelle.pdg.inst.id !63"
Parallelizer: parallelizerLoop:   Nesting level = 1
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 = i32 %2
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %8 = sext i32 %7 to i64, !noelle.pdg.inst.id !54
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %11 = sext i32 %10 to i64, !noelle.pdg.inst.id !57
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %14 = sext i32 %13 to i64, !noelle.pdg.inst.id !60
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "evolve"
Parallelizer: parallelizerLoop:   Loop 64 = "  %17 = icmp slt i64 %indvars.iv3, %11, !noelle.pdg.inst.id !70"
Parallelizer: parallelizerLoop:   Nesting level = 2
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 = i32 %2
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %indvars.iv5 = phi i64 [ %indvars.iv.next6, %35 ], [ 0, %5 ], !noelle.pdg.inst.id !62
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %11 = sext i32 %10 to i64, !noelle.pdg.inst.id !57
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %14 = sext i32 %13 to i64, !noelle.pdg.inst.id !60
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "evolve"
Parallelizer: parallelizerLoop:   Loop 65 = "  %18 = icmp slt i64 %indvars.iv, %14, !noelle.pdg.inst.id !77"
Parallelizer: parallelizerLoop:   Nesting level = 3
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 = i32 %2
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %indvars.iv5 = phi i64 [ %indvars.iv.next6, %35 ], [ 0, %5 ], !noelle.pdg.inst.id !62
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %14 = sext i32 %13 to i64, !noelle.pdg.inst.id !60
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %indvars.iv3 = phi i64 [ %indvars.iv.next4, %34 ], [ 0, %.preheader1.preheader ], !noelle.pdg.inst.id !69
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "cffts1"
Parallelizer: parallelizerLoop:   Loop 69 = "  %43 = icmp slt i64 %indvars.iv12, %24, !noelle.pdg.inst.id !405"
Parallelizer: parallelizerLoop:   Nesting level = 1
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !362
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !363
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %21 = load i32, i32* %20, align 4, !noelle.pdg.inst.id !50
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %24 = sext i32 %23 to i64, !noelle.pdg.inst.id !387
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %29 = sext i32 %28 to i64, !noelle.pdg.inst.id !390
Parallelizer: parallelizerLoop:   Environment:   Live-in 5 =   %32 = sext i32 %31 to i64, !noelle.pdg.inst.id !393
Parallelizer: parallelizerLoop:   Environment:   Live-in 6 =   %34 = icmp eq i32 %33, 1, !noelle.pdg.inst.id !395
Parallelizer: parallelizerLoop:   Environment:   Live-in 7 =   %36 = sext i32 %.pre to i64, !noelle.pdg.inst.id !397
Parallelizer: parallelizerLoop:   Environment:   Live-in 8 =   %37 = sext i32 %35 to i64, !noelle.pdg.inst.id !398
Parallelizer: parallelizerLoop:   Environment:   Live-in 9 =   %or.cond.i = or i1 %30, %41, !noelle.pdg.inst.id !402
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "cffts1"
Parallelizer: parallelizerLoop:   Loop 70 = "  %44 = icmp sgt i64 %indvars.iv11, %37, !noelle.pdg.inst.id !412"
Parallelizer: parallelizerLoop:   Nesting level = 2
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !362
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !363
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %21 = load i32, i32* %20, align 4, !noelle.pdg.inst.id !50
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %29 = sext i32 %28 to i64, !noelle.pdg.inst.id !390
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %32 = sext i32 %31 to i64, !noelle.pdg.inst.id !393
Parallelizer: parallelizerLoop:   Environment:   Live-in 5 =   %34 = icmp eq i32 %33, 1, !noelle.pdg.inst.id !395
Parallelizer: parallelizerLoop:   Environment:   Live-in 6 =   %36 = sext i32 %.pre to i64, !noelle.pdg.inst.id !397
Parallelizer: parallelizerLoop:   Environment:   Live-in 7 =   %37 = sext i32 %35 to i64, !noelle.pdg.inst.id !398
Parallelizer: parallelizerLoop:   Environment:   Live-in 8 =   %or.cond.i = or i1 %30, %41, !noelle.pdg.inst.id !402
Parallelizer: parallelizerLoop:   Environment:   Live-in 9 =   %indvars.iv12 = phi i64 [ %indvars.iv.next13, %213 ], [ 0, %17 ], !noelle.pdg.inst.id !404
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "cffts1"
Parallelizer: parallelizerLoop:   Loop 74 = "  %77 = icmp slt i64 %indvars.iv10.i4.i, %75, !noelle.pdg.inst.id !476"
Parallelizer: parallelizerLoop:   Nesting level = 4
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !362
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !363
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %32 = sext i32 %31 to i64, !noelle.pdg.inst.id !393
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %36 = sext i32 %.pre to i64, !noelle.pdg.inst.id !397
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %74 = sext i32 %.02.i.i to i64, !noelle.pdg.inst.id !471
Parallelizer: parallelizerLoop:   Environment:   Live-in 5 =   %75 = sext i32 %.03.i1.i to i64, !noelle.pdg.inst.id !472
Parallelizer: parallelizerLoop:   Environment:   Live-in 6 =   %76 = sext i32 %73 to i64, !noelle.pdg.inst.id !473
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "cffts1"
Parallelizer: parallelizerLoop:   Loop 77 = "  %134 = icmp slt i64 %indvars.iv10.i.i, %132, !noelle.pdg.inst.id !546"
Parallelizer: parallelizerLoop:   Nesting level = 4
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !362
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !363
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %32 = sext i32 %31 to i64, !noelle.pdg.inst.id !393
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %36 = sext i32 %.pre to i64, !noelle.pdg.inst.id !397
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %131 = sext i32 %124 to i64, !noelle.pdg.inst.id !541
Parallelizer: parallelizerLoop:   Environment:   Live-in 5 =   %132 = sext i32 %.03.i.i to i64, !noelle.pdg.inst.id !542
Parallelizer: parallelizerLoop:   Environment:   Live-in 6 =   %133 = sext i32 %130 to i64, !noelle.pdg.inst.id !543
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "main"
Parallelizer: parallelizerLoop:   Loop 2 = "  %exitcond1 = icmp eq i32 %.01, %70, !noelle.pdg.inst.id !1115"
Parallelizer: parallelizerLoop:   Nesting level = 1
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %33 = bitcast [512 x [18 x %struct.dcomplex]]* %5 to i8*, !noelle.pdg.inst.id !1085
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %34 = bitcast [512 x [18 x %struct.dcomplex]]* %3 to i8*, !noelle.pdg.inst.id !1086
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %35 = bitcast [512 x [18 x %struct.dcomplex]]* %4 to i8*, !noelle.pdg.inst.id !1087
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %40 = sext i32 %39 to i64, !noelle.pdg.inst.id !1091
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %47 = sext i32 %41 to i64, !noelle.pdg.inst.id !1095
Parallelizer: parallelizerLoop:   Environment:   Live-in 5 =   %48 = sext i32 %46 to i64, !noelle.pdg.inst.id !1096
Parallelizer: parallelizerLoop:   Environment:   Live-in 6 =   %49 = sext i32 %44 to i64, !noelle.pdg.inst.id !1097
Parallelizer: parallelizerLoop:   Environment:   Live-in 7 =   %52 = sext i32 %51 to i64, !noelle.pdg.inst.id !1099
Parallelizer: parallelizerLoop:   Environment:   Live-in 8 =   %58 = sext i32 %57 to i64, !noelle.pdg.inst.id !1103
Parallelizer: parallelizerLoop:   Environment:   Live-in 9 =   %59 = sext i32 %55 to i64, !noelle.pdg.inst.id !1104
Parallelizer: parallelizerLoop:   Environment:   Live-in 10 =   %62 = sext i32 %61 to i64, !noelle.pdg.inst.id !1106
Parallelizer: parallelizerLoop:   Environment:   Live-in 11 =   %68 = sext i32 %67 to i64, !noelle.pdg.inst.id !1110
Parallelizer: parallelizerLoop:   Environment:   Live-in 12 =   %69 = sext i32 %65 to i64, !noelle.pdg.inst.id !1111
Parallelizer: parallelizerLoop:   Environment:   Live-in 13 =   %70 = or i32 %37, 1, !noelle.pdg.inst.id !1112
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "main"
Parallelizer: parallelizerLoop:   Loop 4 = "  %81 = icmp slt i64 %indvars.iv13.i, %40, !noelle.pdg.inst.id !1135"
Parallelizer: parallelizerLoop:   Nesting level = 2
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %40 = sext i32 %39 to i64, !noelle.pdg.inst.id !1091
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %47 = sext i32 %41 to i64, !noelle.pdg.inst.id !1095
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %48 = sext i32 %46 to i64, !noelle.pdg.inst.id !1096
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %49 = sext i32 %44 to i64, !noelle.pdg.inst.id !1097
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "main"
Parallelizer: parallelizerLoop:   Loop 5 = "  %82 = icmp sgt i64 %indvars.iv, %49, !noelle.pdg.inst.id !1142"
Parallelizer: parallelizerLoop:   Nesting level = 3
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %47 = sext i32 %41 to i64, !noelle.pdg.inst.id !1095
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %48 = sext i32 %46 to i64, !noelle.pdg.inst.id !1096
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %49 = sext i32 %44 to i64, !noelle.pdg.inst.id !1097
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %indvars.iv13.i = phi i64 [ %indvars.iv.next14.i, %135 ], [ 0, %79 ], !noelle.pdg.inst.id !1134
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "main"
Parallelizer: parallelizerLoop:   Loop 20 = "  %140 = icmp slt i64 %indvars.iv13.i4, %52, !noelle.pdg.inst.id !1259"
Parallelizer: parallelizerLoop:   Nesting level = 2
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %47 = sext i32 %41 to i64, !noelle.pdg.inst.id !1095
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %52 = sext i32 %51 to i64, !noelle.pdg.inst.id !1099
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %58 = sext i32 %57 to i64, !noelle.pdg.inst.id !1103
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %59 = sext i32 %55 to i64, !noelle.pdg.inst.id !1104
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "main"
Parallelizer: parallelizerLoop:   Loop 21 = "  %141 = icmp sgt i64 %indvars.iv60, %59, !noelle.pdg.inst.id !1264"
Parallelizer: parallelizerLoop:   Nesting level = 3
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %47 = sext i32 %41 to i64, !noelle.pdg.inst.id !1095
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %58 = sext i32 %57 to i64, !noelle.pdg.inst.id !1103
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %59 = sext i32 %55 to i64, !noelle.pdg.inst.id !1104
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %indvars.iv13.i4 = phi i64 [ %indvars.iv.next14.i52, %194 ], [ 0, %138 ], !noelle.pdg.inst.id !1258
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "main"
Parallelizer: parallelizerLoop:   Loop 36 = "  %199 = icmp slt i64 %indvars.iv12.i, %62, !noelle.pdg.inst.id !1374"
Parallelizer: parallelizerLoop:   Nesting level = 2
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %47 = sext i32 %41 to i64, !noelle.pdg.inst.id !1095
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %62 = sext i32 %61 to i64, !noelle.pdg.inst.id !1106
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %68 = sext i32 %67 to i64, !noelle.pdg.inst.id !1110
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %69 = sext i32 %65 to i64, !noelle.pdg.inst.id !1111
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "main"
Parallelizer: parallelizerLoop:   Loop 37 = "  %200 = icmp sgt i64 %indvars.iv62, %69, !noelle.pdg.inst.id !1379"
Parallelizer: parallelizerLoop:   Nesting level = 3
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %47 = sext i32 %41 to i64, !noelle.pdg.inst.id !1095
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %68 = sext i32 %67 to i64, !noelle.pdg.inst.id !1110
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %69 = sext i32 %65 to i64, !noelle.pdg.inst.id !1111
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %indvars.iv12.i = phi i64 [ %indvars.iv.next13.i, %257 ], [ 0, %197 ], !noelle.pdg.inst.id !1373
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "main"
Parallelizer: parallelizerLoop:   Loop 6 = "  %83 = icmp slt i64 %indvars.iv7.i, %48, !noelle.pdg.inst.id !1149"
Parallelizer: parallelizerLoop:   Nesting level = 4
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %47 = sext i32 %41 to i64, !noelle.pdg.inst.id !1095
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %48 = sext i32 %46 to i64, !noelle.pdg.inst.id !1096
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %indvars.iv13.i = phi i64 [ %indvars.iv.next14.i, %135 ], [ 0, %79 ], !noelle.pdg.inst.id !1134
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %indvars.iv = phi i64 [ %indvars.iv.next, %134 ], [ 0, %.preheader19.preheader ], !noelle.pdg.inst.id !1141
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "main"
Parallelizer: parallelizerLoop:   Loop 22 = "  %142 = icmp slt i64 %indvars.iv7.i7, %58, !noelle.pdg.inst.id !1269"
Parallelizer: parallelizerLoop:   Nesting level = 4
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %47 = sext i32 %41 to i64, !noelle.pdg.inst.id !1095
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %58 = sext i32 %57 to i64, !noelle.pdg.inst.id !1103
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %indvars.iv13.i4 = phi i64 [ %indvars.iv.next14.i52, %194 ], [ 0, %138 ], !noelle.pdg.inst.id !1258
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %indvars.iv60 = phi i64 [ %indvars.iv.next61, %193 ], [ 0, %.preheader18.preheader ], !noelle.pdg.inst.id !1263
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "main"
Parallelizer: parallelizerLoop:   Loop 17 = "  %119 = icmp slt i64 %indvars.iv11.i, %48, !noelle.pdg.inst.id !1223"
Parallelizer: parallelizerLoop:   Nesting level = 4
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %5 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1046
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %47 = sext i32 %41 to i64, !noelle.pdg.inst.id !1095
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %48 = sext i32 %46 to i64, !noelle.pdg.inst.id !1096
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %indvars.iv13.i = phi i64 [ %indvars.iv.next14.i, %135 ], [ 0, %79 ], !noelle.pdg.inst.id !1134
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %indvars.iv = phi i64 [ %indvars.iv.next, %134 ], [ 0, %.preheader19.preheader ], !noelle.pdg.inst.id !1141
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "main"
Parallelizer: parallelizerLoop:   Loop 33 = "  %178 = icmp slt i64 %indvars.iv11.i47, %58, !noelle.pdg.inst.id !1338"
Parallelizer: parallelizerLoop:   Nesting level = 4
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %3 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1044
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %47 = sext i32 %41 to i64, !noelle.pdg.inst.id !1095
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %58 = sext i32 %57 to i64, !noelle.pdg.inst.id !1103
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %indvars.iv13.i4 = phi i64 [ %indvars.iv.next14.i52, %194 ], [ 0, %138 ], !noelle.pdg.inst.id !1258
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %indvars.iv60 = phi i64 [ %indvars.iv.next61, %193 ], [ 0, %.preheader18.preheader ], !noelle.pdg.inst.id !1263
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "main"
Parallelizer: parallelizerLoop:   Loop 38 = "  %201 = icmp slt i64 %indvars.iv6.i, %47, !noelle.pdg.inst.id !1385"
Parallelizer: parallelizerLoop:   Nesting level = 4
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %47 = sext i32 %41 to i64, !noelle.pdg.inst.id !1095
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %68 = sext i32 %67 to i64, !noelle.pdg.inst.id !1110
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %indvars.iv12.i = phi i64 [ %indvars.iv.next13.i, %257 ], [ 0, %197 ], !noelle.pdg.inst.id !1373
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %indvars.iv62 = phi i64 [ %indvars.iv.next63, %256 ], [ 0, %.preheader17.preheader ], !noelle.pdg.inst.id !1378
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "main"
Parallelizer: parallelizerLoop:   Loop 49 = "  %239 = icmp slt i64 %indvars.iv10.i, %47, !noelle.pdg.inst.id !1458"
Parallelizer: parallelizerLoop:   Nesting level = 4
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %47 = sext i32 %41 to i64, !noelle.pdg.inst.id !1095
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %68 = sext i32 %67 to i64, !noelle.pdg.inst.id !1110
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %indvars.iv12.i = phi i64 [ %indvars.iv.next13.i, %257 ], [ 0, %197 ], !noelle.pdg.inst.id !1373
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %indvars.iv62 = phi i64 [ %indvars.iv.next63, %256 ], [ 0, %.preheader17.preheader ], !noelle.pdg.inst.id !1378
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "main"
Parallelizer: parallelizerLoop:   Loop 39 = "  %206 = icmp slt i64 %indvars.iv.i5, %68, !noelle.pdg.inst.id !1394"
Parallelizer: parallelizerLoop:   Nesting level = 5
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %68 = sext i32 %67 to i64, !noelle.pdg.inst.id !1110
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %indvars.iv12.i = phi i64 [ %indvars.iv.next13.i, %257 ], [ 0, %197 ], !noelle.pdg.inst.id !1373
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %indvars.iv6.i = phi i64 [ %indvars.iv.next7.i, %218 ], [ 0, %.preheader.i4.preheader ], !noelle.pdg.inst.id !1384
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %204 = ashr exact i64 %sext, 32, !noelle.pdg.inst.id !1391
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "main"
Parallelizer: parallelizerLoop:   Loop 50 = "  %243 = icmp slt i64 %indvars.iv8.i, %68, !noelle.pdg.inst.id !1464"
Parallelizer: parallelizerLoop:   Nesting level = 5
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %4 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !1045
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %68 = sext i32 %67 to i64, !noelle.pdg.inst.id !1110
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %indvars.iv12.i = phi i64 [ %indvars.iv.next13.i, %257 ], [ 0, %197 ], !noelle.pdg.inst.id !1373
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %indvars.iv10.i = phi i64 [ %indvars.iv.next11.i, %255 ], [ 0, %cfftz.exit.i41 ], !noelle.pdg.inst.id !1457
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %241 = add nsw i64 %indvars.iv10.i, %indvars.iv62, !noelle.pdg.inst.id !1461
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "cffts3"
Parallelizer: parallelizerLoop:   Loop 101 = "  %43 = icmp slt i64 %indvars.iv13, %24, !noelle.pdg.inst.id !397"
Parallelizer: parallelizerLoop:   Nesting level = 1
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !354
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !355
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %21 = load i32, i32* %20, align 4, !noelle.pdg.inst.id !50
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %24 = sext i32 %23 to i64, !noelle.pdg.inst.id !379
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %29 = sext i32 %28 to i64, !noelle.pdg.inst.id !382
Parallelizer: parallelizerLoop:   Environment:   Live-in 5 =   %32 = sext i32 %31 to i64, !noelle.pdg.inst.id !385
Parallelizer: parallelizerLoop:   Environment:   Live-in 6 =   %34 = icmp eq i32 %33, 1, !noelle.pdg.inst.id !387
Parallelizer: parallelizerLoop:   Environment:   Live-in 7 =   %35 = sext i32 %.pre to i64, !noelle.pdg.inst.id !388
Parallelizer: parallelizerLoop:   Environment:   Live-in 8 =   %37 = sext i32 %36 to i64, !noelle.pdg.inst.id !390
Parallelizer: parallelizerLoop:   Environment:   Live-in 9 =   %or.cond.i = or i1 %30, %41, !noelle.pdg.inst.id !394
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "cffts3"
Parallelizer: parallelizerLoop:   Loop 102 = "  %44 = icmp sgt i64 %indvars.iv12, %37, !noelle.pdg.inst.id !404"
Parallelizer: parallelizerLoop:   Nesting level = 2
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !354
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !355
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %21 = load i32, i32* %20, align 4, !noelle.pdg.inst.id !50
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %29 = sext i32 %28 to i64, !noelle.pdg.inst.id !382
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %32 = sext i32 %31 to i64, !noelle.pdg.inst.id !385
Parallelizer: parallelizerLoop:   Environment:   Live-in 5 =   %34 = icmp eq i32 %33, 1, !noelle.pdg.inst.id !387
Parallelizer: parallelizerLoop:   Environment:   Live-in 6 =   %35 = sext i32 %.pre to i64, !noelle.pdg.inst.id !388
Parallelizer: parallelizerLoop:   Environment:   Live-in 7 =   %37 = sext i32 %36 to i64, !noelle.pdg.inst.id !390
Parallelizer: parallelizerLoop:   Environment:   Live-in 8 =   %or.cond.i = or i1 %30, %41, !noelle.pdg.inst.id !394
Parallelizer: parallelizerLoop:   Environment:   Live-in 9 =   %indvars.iv13 = phi i64 [ %indvars.iv.next14, %209 ], [ 0, %17 ], !noelle.pdg.inst.id !396
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "cffts3"
Parallelizer: parallelizerLoop:   Loop 106 = "  %75 = icmp slt i64 %indvars.iv10.i4.i, %73, !noelle.pdg.inst.id !469"
Parallelizer: parallelizerLoop:   Nesting level = 4
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !354
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !355
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %32 = sext i32 %31 to i64, !noelle.pdg.inst.id !385
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %35 = sext i32 %.pre to i64, !noelle.pdg.inst.id !388
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %72 = sext i32 %.02.i.i to i64, !noelle.pdg.inst.id !464
Parallelizer: parallelizerLoop:   Environment:   Live-in 5 =   %73 = sext i32 %.03.i1.i to i64, !noelle.pdg.inst.id !465
Parallelizer: parallelizerLoop:   Environment:   Live-in 6 =   %74 = sext i32 %71 to i64, !noelle.pdg.inst.id !466
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "cffts3"
Parallelizer: parallelizerLoop:   Loop 109 = "  %132 = icmp slt i64 %indvars.iv10.i.i, %130, !noelle.pdg.inst.id !538"
Parallelizer: parallelizerLoop:   Nesting level = 4
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !354
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !355
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %32 = sext i32 %31 to i64, !noelle.pdg.inst.id !385
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %35 = sext i32 %.pre to i64, !noelle.pdg.inst.id !388
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %129 = sext i32 %122 to i64, !noelle.pdg.inst.id !533
Parallelizer: parallelizerLoop:   Environment:   Live-in 5 =   %130 = sext i32 %.03.i.i to i64, !noelle.pdg.inst.id !534
Parallelizer: parallelizerLoop:   Environment:   Live-in 6 =   %131 = sext i32 %128 to i64, !noelle.pdg.inst.id !535
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "cffts2"
Parallelizer: parallelizerLoop:   Loop 85 = "  %43 = icmp slt i64 %indvars.iv13, %24, !noelle.pdg.inst.id !405"
Parallelizer: parallelizerLoop:   Nesting level = 1
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !362
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !363
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %21 = load i32, i32* %20, align 4, !noelle.pdg.inst.id !50
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %24 = sext i32 %23 to i64, !noelle.pdg.inst.id !387
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %30 = sext i32 %.pre to i64, !noelle.pdg.inst.id !391
Parallelizer: parallelizerLoop:   Environment:   Live-in 5 =   %31 = sext i32 %29 to i64, !noelle.pdg.inst.id !392
Parallelizer: parallelizerLoop:   Environment:   Live-in 6 =   %or.cond.i = or i1 %35, %36, !noelle.pdg.inst.id !397
Parallelizer: parallelizerLoop:   Environment:   Live-in 7 =   %38 = sext i32 %37 to i64, !noelle.pdg.inst.id !399
Parallelizer: parallelizerLoop:   Environment:   Live-in 8 =   %40 = icmp eq i32 %39, 1, !noelle.pdg.inst.id !401
Parallelizer: parallelizerLoop:   Environment:   Live-in 9 =   %41 = sext i32 %27 to i64, !noelle.pdg.inst.id !402
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "cffts2"
Parallelizer: parallelizerLoop:   Loop 86 = "  %44 = icmp sgt i64 %indvars.iv14, %41, !noelle.pdg.inst.id !412"
Parallelizer: parallelizerLoop:   Nesting level = 2
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !362
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !363
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %21 = load i32, i32* %20, align 4, !noelle.pdg.inst.id !50
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %30 = sext i32 %.pre to i64, !noelle.pdg.inst.id !391
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %31 = sext i32 %29 to i64, !noelle.pdg.inst.id !392
Parallelizer: parallelizerLoop:   Environment:   Live-in 5 =   %indvars.iv13 = phi i64 [ %indvars.iv.next14, %209 ], [ 0, %17 ], !noelle.pdg.inst.id !404
Parallelizer: parallelizerLoop:   Environment:   Live-in 6 =   %or.cond.i = or i1 %35, %36, !noelle.pdg.inst.id !397
Parallelizer: parallelizerLoop:   Environment:   Live-in 7 =   %38 = sext i32 %37 to i64, !noelle.pdg.inst.id !399
Parallelizer: parallelizerLoop:   Environment:   Live-in 8 =   %40 = icmp eq i32 %39, 1, !noelle.pdg.inst.id !401
Parallelizer: parallelizerLoop:   Environment:   Live-in 9 =   %41 = sext i32 %27 to i64, !noelle.pdg.inst.id !402
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "cffts2"
Parallelizer: parallelizerLoop:   Loop 90 = "  %75 = icmp slt i64 %indvars.iv10.i4.i, %73, !noelle.pdg.inst.id !477"
Parallelizer: parallelizerLoop:   Nesting level = 4
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !362
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !363
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %30 = sext i32 %.pre to i64, !noelle.pdg.inst.id !391
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %38 = sext i32 %37 to i64, !noelle.pdg.inst.id !399
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %72 = sext i32 %.02.i.i to i64, !noelle.pdg.inst.id !472
Parallelizer: parallelizerLoop:   Environment:   Live-in 5 =   %73 = sext i32 %.03.i1.i to i64, !noelle.pdg.inst.id !473
Parallelizer: parallelizerLoop:   Environment:   Live-in 6 =   %74 = sext i32 %71 to i64, !noelle.pdg.inst.id !474
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "cffts2"
Parallelizer: parallelizerLoop:   Loop 93 = "  %132 = icmp slt i64 %indvars.iv10.i.i, %130, !noelle.pdg.inst.id !546"
Parallelizer: parallelizerLoop:   Nesting level = 4
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %8 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !362
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %9 = alloca [512 x [18 x %struct.dcomplex]], align 16, !noelle.pdg.inst.id !363
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %30 = sext i32 %.pre to i64, !noelle.pdg.inst.id !391
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %38 = sext i32 %37 to i64, !noelle.pdg.inst.id !399
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %129 = sext i32 %122 to i64, !noelle.pdg.inst.id !541
Parallelizer: parallelizerLoop:   Environment:   Live-in 5 =   %130 = sext i32 %.03.i.i to i64, !noelle.pdg.inst.id !542
Parallelizer: parallelizerLoop:   Environment:   Live-in 6 =   %131 = sext i32 %128 to i64, !noelle.pdg.inst.id !543
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "compute_initial_conditions"
Parallelizer: parallelizerLoop:   Loop 57 = "  %34 = icmp slt i64 %indvars.iv8, %20, !noelle.pdg.inst.id !143"
Parallelizer: parallelizerLoop:   Nesting level = 1
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %20 = sext i32 %19 to i64, !noelle.pdg.inst.id !129
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %24 = sext i32 %23 to i64, !noelle.pdg.inst.id !132
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %25 = sext i32 %22 to i64, !noelle.pdg.inst.id !133
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %26 = zext i32 %19 to i64, !noelle.pdg.inst.id !134
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %29 = sitofp i32 %28 to double, !noelle.pdg.inst.id !137
Parallelizer: parallelizerLoop:   Environment:   Live-in 5 =   %31 = fsub double %17, %30, !noelle.pdg.inst.id !139
Parallelizer: parallelizerLoop:   Environment:   Live-in 6 =   %.promoted = load double, double* %3, align 8, !tbaa !116, !noelle.pdg.inst.id !51
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: Exit
noelle-meta-clean parallelized_unoptimized.bc parallelized_unoptimized.bc
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CleanMetadata.so -CleanMetadata -clean-loop-metadata=true -clean-prof-metadata=true -clean-pdg-metadata=true parallelized_unoptimized.bc -o parallelized_unoptimized.bc
noelle/core/Clean Loop Metadata
noelle/core/Clean PDG Metadata
noelle/core/Clean profiler metadata
opt --strip-named-metadata parallelized_unoptimized.bc -o parallelized_unoptimized.bc
clang -O3 -c -emit-llvm parallelized_unoptimized.bc -o baseline_parallelized.bc
clang -O3 -c -emit-llvm baseline_parallelized.bc -o baseline_parallelized.bc
cp baseline_parallelized.bc ft.B.bc
make[1]: Leaving directory '/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/NAS/benchmarks/ft.B'
