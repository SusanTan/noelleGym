make[1]: Entering directory '/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/basicmath'
./runEnablers.sh basicmath basicmath.bc large "-lm -lstdc++ -lpthread -ltermcap" -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier
/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/basicmath /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/basicmath
Cloning https://github.com/scampanoni/virgil.git
Cloning into 'threadpool'...
/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/basicmath

opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -tbaa -early-cse-memssa -licm -simplifycfg -simplifycfg-sink-common=false -instcombine -tailcallelim -loop-simplify -lcssa -licm -loop-unswitch -globalopt -instcombine -ipsccp -dce -gvn -dse -adce -loop-simplify -lcssa -indvars -loop-deletion -instcombine -indvars -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa --functionattrs --rpo-functionattrs basicmath.bc -o baseline.bc
/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/basicmath /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/basicmath
Running: ./baseline_prof > output_large.txt in /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/MiBench/automotive/basicmath
--------------------------------------------------------------------------------------
/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/basicmath
DONE
opt -pgo-test-profile-file=/tmp/tmp.4dSy90g1k2 -block-freq -pgo-instr-use baseline.bc -o baseline_pre.bc
opt --strip-debug --strip-debug-declare baseline_pre.bc -o baseline_pre.bc
noelle-deadcode baseline_pre.bc baseline_pre.bc
NOELLE: DeadFunctions: Start
noelle-fixedpoint baseline_pre.bc baseline_pre.bc "noelle-load" -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DeadFunction.so -noelle-dfe
NOELLE: FixedPoint: Start
NOELLE: FixedPoint:   Loader: noelle-load
NOELLE: FixedPoint:   Options: -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DeadFunction.so -noelle-dfe
NOELLE: FixedPoint:   Input: baseline_pre.bc
NOELLE: FixedPoint:   Output: baseline_pre.bc
NOELLE: FixedPoint:   Temporary input: /tmp/tmp.3t1aHUGKP7 (.ll version is /tmp/tmp.IriVgn2Ity)
NOELLE: FixedPoint:   Temporary output: /tmp/tmp.RbO3lCdRuf (.ll version is /tmp/tmp.lMb6xfYjdx)
NOELLE: FixedPoint:   Normalize the code
noelle-norm /tmp/tmp.3t1aHUGKP7 -o /tmp/tmp.RbO3lCdRuf
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.3t1aHUGKP7 -o /tmp/tmp.RbO3lCdRuf
NOELLE: FixedPoint:   Run until a fixed point is reached
NOELLE: FixedPoint:     Invocation 0
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DeadFunction.so -noelle-dfe /tmp/tmp.3t1aHUGKP7 -o /tmp/tmp.RbO3lCdRuf
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DeadFunction.so -noelle-dfe /tmp/tmp.3t1aHUGKP7 -o /tmp/tmp.RbO3lCdRuf
DeadFunctionEliminator: Start
DeadFunctionEliminator:   Inline functions that are invoked only by one call instruction and that do not escape into memory
DeadFunctionEliminator:   Get the islands
DeadFunctionEliminator:   Identify the islands reachable from the entry points
DeadFunctionEliminator:     Island
DeadFunctionEliminator:       main
DeadFunctionEliminator:       deg2rad
DeadFunctionEliminator:       llvm.lifetime.start.p0i8
DeadFunctionEliminator:       printf
DeadFunctionEliminator:       atan
DeadFunctionEliminator:       llvm.lifetime.end.p0i8
DeadFunctionEliminator:       rad2deg
DeadFunctionEliminator:       SolveCubic
DeadFunctionEliminator:       sqrt
DeadFunctionEliminator:       acos
DeadFunctionEliminator:       cos
DeadFunctionEliminator:       llvm.fabs.f64
DeadFunctionEliminator:       pow
DeadFunctionEliminator:       usqrt
DeadFunctionEliminator:       putchar
DeadFunctionEliminator:   Identify the functions that can be deleted
DeadFunctionEliminator: Exit
Noelle:  Function "main"
Noelle:     Loop "  %12 = load i32, i32* %2, align 4, !tbaa !30" (8.785996e-08%)
Noelle:     Loop "  %24 = load i32, i32* %2, align 4, !tbaa !30" (3.699367e-08%)
Noelle:     Loop "  %36 = load i32, i32* %2, align 4, !tbaa !30" (3.699367e-08%)
Noelle:     Loop "  %48 = load i32, i32* %2, align 4, !tbaa !30" (3.699367e-08%)
Noelle:     Loop "  %60 = load i32, i32* %2, align 4, !tbaa !30" (3.699367e-08%)
Noelle:     Loop "  %72 = load i32, i32* %2, align 4, !tbaa !30" (3.699367e-08%)
Noelle:     Loop "  %84 = load i32, i32* %2, align 4, !tbaa !30" (3.699367e-08%)
Noelle:     Loop "  %96 = load i32, i32* %2, align 4, !tbaa !30" (3.699367e-08%)
Noelle:     Loop "  %106 = fcmp olt double %.01, 1.000000e+03" (9.770877e+01%)
Noelle:     Loop "  %108 = fcmp ogt double %.02, 0.000000e+00" (9.770875e+01%)
Noelle:     Loop "  %110 = fcmp olt double %.03, 1.000000e+03" (9.770819e+01%)
Noelle:     Loop "  %112 = fcmp ogt double %.04, -5.000000e+00" (9.680322e+01%)
Noelle:     Loop "  %117 = load i32, i32* %2, align 4, !tbaa !30" (2.171297e+01%)
Noelle:     Loop "  %137 = icmp ult i64 %indvars.iv, 100000" (7.999882e-02%)
Noelle:     Loop "  %exitcond = icmp eq i64 %.0, 1072513385" (2.617614e-02%)
Noelle:     Loop "  %153 = fcmp ugt double %.05, 3.600000e+02" (8.275343e-01%)
Noelle:     Loop "  %165 = call double @atan(double 1.000000e+00) #9" (3.196623e-04%)
Noelle:  Function "SolveCubic"
Noelle:  Function "usqrt"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 32" (1.040640e-01%)
Noelle:  Function "deg2rad"
Noelle:  Function "rad2deg"
Noelle:  Function "main"
Noelle:     Loop "  %12 = load i32, i32* %2, align 4, !tbaa !30" (8.785996e-08%)
Noelle:     Loop "  %24 = load i32, i32* %2, align 4, !tbaa !30" (3.699367e-08%)
Noelle:     Loop "  %36 = load i32, i32* %2, align 4, !tbaa !30" (3.699367e-08%)
Noelle:     Loop "  %48 = load i32, i32* %2, align 4, !tbaa !30" (3.699367e-08%)
Noelle:     Loop "  %60 = load i32, i32* %2, align 4, !tbaa !30" (3.699367e-08%)
Noelle:     Loop "  %72 = load i32, i32* %2, align 4, !tbaa !30" (3.699367e-08%)
Noelle:     Loop "  %84 = load i32, i32* %2, align 4, !tbaa !30" (3.699367e-08%)
Noelle:     Loop "  %96 = load i32, i32* %2, align 4, !tbaa !30" (3.699367e-08%)
Noelle:     Loop "  %106 = fcmp olt double %.01, 1.000000e+03" (9.770877e+01%)
Noelle:     Loop "  %108 = fcmp ogt double %.02, 0.000000e+00" (9.770875e+01%)
Noelle:     Loop "  %110 = fcmp olt double %.03, 1.000000e+03" (9.770819e+01%)
Noelle:     Loop "  %112 = fcmp ogt double %.04, -5.000000e+00" (9.680322e+01%)
Noelle:     Loop "  %117 = load i32, i32* %2, align 4, !tbaa !30" (2.171297e+01%)
Noelle:     Loop "  %137 = icmp ult i64 %indvars.iv, 100000" (7.999882e-02%)
Noelle:     Loop "  %exitcond = icmp eq i64 %.0, 1072513385" (2.617614e-02%)
Noelle:     Loop "  %153 = fcmp ugt double %.05, 3.600000e+02" (8.275343e-01%)
Noelle:     Loop "  %165 = call double @atan(double 1.000000e+00) #9" (3.196623e-04%)
Noelle:  Function "SolveCubic"
Noelle:  Function "usqrt"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 32" (1.040640e-01%)
Noelle:  Function "deg2rad"
Noelle:  Function "rad2deg"
NOELLE: FixedPoint: Exit
NOELLE: DeadFunctions: Exit
noelle-simplification baseline_pre.bc -o baseline_pre.bc
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -tbaa -early-cse-memssa -licm -simplifycfg -simplifycfg-sink-common=false -instcombine -tailcallelim -loop-simplify -lcssa -licm -loop-unswitch -globalopt -instcombine -ipsccp -dce -gvn -dse -adce -loop-simplify -lcssa -indvars -loop-deletion -instcombine -indvars -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa --functionattrs --rpo-functionattrs baseline_pre.bc -o baseline_pre.bc
noelle-inline baseline_pre.bc "-noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier"
NOELLE: Inliner: Start
noelle-fixedpoint baseline_pre.bc baseline_pre.bc "noelle-parallel-load" -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier
NOELLE: FixedPoint: Start
NOELLE: FixedPoint:   Loader: noelle-parallel-load
NOELLE: FixedPoint:   Options: -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier
NOELLE: FixedPoint:   Input: baseline_pre.bc
NOELLE: FixedPoint:   Output: baseline_pre.bc
NOELLE: FixedPoint:   Temporary input: /tmp/tmp.RvOJsYjpgT (.ll version is /tmp/tmp.jxOkpYqhCg)
NOELLE: FixedPoint:   Temporary output: /tmp/tmp.q6mAmBf70o (.ll version is /tmp/tmp.cWTox5sUNZ)
NOELLE: FixedPoint:   Normalize the code
noelle-norm /tmp/tmp.RvOJsYjpgT -o /tmp/tmp.q6mAmBf70o
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.RvOJsYjpgT -o /tmp/tmp.q6mAmBf70o
NOELLE: FixedPoint:   Run until a fixed point is reached
NOELLE: FixedPoint:     Invocation 0
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.RvOJsYjpgT -o /tmp/tmp.q6mAmBf70o
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.RvOJsYjpgT -o /tmp/tmp.q6mAmBf70o
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.RvOJsYjpgT -o /tmp/tmp.q6mAmBf70o
Inliner: Start
Inliner:   Number of program instructions = 360
Inliner:   Profiles are available and will be used
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 9
DOALL:     	  call void @SolveCubic(double %.01, double %.02, double %.03, double %.04, i32* nonnull %2, double* nonnull %8)
DOALL:     	  %113 = load i32, i32* %2, align 4, !tbaa !30
DOALL:     	  %114 = sext i32 %113 to i64
DOALL:     	  %indvars.iv21 = phi i64 [ %indvars.iv.next22, %117 ], [ 0, %110 ]
DOALL:     	  %116 = icmp slt i64 %indvars.iv21, %114
DOALL:     	  br i1 %116, label %117, label %122, !prof !42
DOALL:     	  %118 = getelementptr inbounds [3 x double], [3 x double]* %1, i64 0, i64 %indvars.iv21
DOALL:     	  %119 = load double, double* %118, align 8, !tbaa !35
DOALL:     	  %indvars.iv.next22 = add nuw nsw i64 %indvars.iv21, 1
DOALL:     External nodes: 8
DOALL:     	  %.02 = phi double [ %127, %126 ], [ 1.000000e+01, %.preheader20.preheader ]
DOALL:     	  %.03 = phi double [ %125, %124 ], [ 5.000000e+00, %.preheader19.preheader ]
DOALL:     	  %.04 = phi double [ %123, %122 ], [ -1.000000e+00, %.preheader.preheader ]
DOALL:     	  br i1 %109, label %110, label %124, !prof !41
DOALL:     	  %120 = getelementptr [4 x i8], [4 x i8]* @.str.2, i64 0, i64 0
DOALL:     	  %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9
DOALL:     	  br label %115
DOALL:     	  %.01 = phi double [ 1.000000e+00, %104 ], [ %129, %128 ]
DOALL:     Edges: 35
DOALL:     Loop-carried data dependences
DOALL:         %119 = load double, double* %118, align 8, !tbaa !35 --->   call void @SolveCubic(double %.01, double %.02, double %.03, double %.04, i32* nonnull %2, double* nonnull %8) via memory
DOALL:         call void @SolveCubic(double %.01, double %.02, double %.03, double %.04, i32* nonnull %2, double* nonnull %8) --->   %119 = load double, double* %118, align 8, !tbaa !35 via memory
DOALL:         call void @SolveCubic(double %.01, double %.02, double %.03, double %.04, i32* nonnull %2, double* nonnull %8) --->   %113 = load i32, i32* %2, align 4, !tbaa !30 via memory
DOALL:         call void @SolveCubic(double %.01, double %.02, double %.03, double %.04, i32* nonnull %2, double* nonnull %8) --->   call void @SolveCubic(double %.01, double %.02, double %.03, double %.04, i32* nonnull %2, double* nonnull %8) via memory
DOALL:         %113 = load i32, i32* %2, align 4, !tbaa !30 --->   call void @SolveCubic(double %.01, double %.02, double %.03, double %.04, i32* nonnull %2, double* nonnull %8) via memory
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 3
DOALL:     	  %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9
DOALL:     	  %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9
DOALL:     	  %putchar18 = tail call i32 @putchar(i32 10)
DOALL:     External nodes: 5
DOALL:     	  br i1 %109, label %110, label %124, !prof !41
DOALL:     	  %111 = getelementptr [11 x i8], [11 x i8]* @.str.1, i64 0, i64 0
DOALL:     	  br i1 %116, label %117, label %122, !prof !42
DOALL:     	  %119 = load double, double* %118, align 8, !tbaa !35
DOALL:     	  %120 = getelementptr [4 x i8], [4 x i8]* @.str.2, i64 0, i64 0
DOALL:     Edges: 27
DOALL:     Loop-carried data dependences
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 --->   %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 via memory
DOALL:         %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 --->   %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 via memory
DOALL:         %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 --->   %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 via memory
DOALL:         %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 --->   %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 via memory
DOALL:         %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 --->   %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 via memory
DOALL:         %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 --->   %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 via memory
DOALL:         %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 --->   %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 via memory
DOALL:         %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 --->   %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 via memory
DOALL:         %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 --->   %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 via memory
DOALL:         %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 --->   %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 via memory
DOALL:         %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 3
DOALL:     	  %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9
DOALL:     	  %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9
DOALL:     	  %putchar18 = tail call i32 @putchar(i32 10)
DOALL:     External nodes: 5
DOALL:     	  br i1 %109, label %110, label %124, !prof !41
DOALL:     	  %111 = getelementptr [11 x i8], [11 x i8]* @.str.1, i64 0, i64 0
DOALL:     	  br i1 %116, label %117, label %122, !prof !42
DOALL:     	  %119 = load double, double* %118, align 8, !tbaa !35
DOALL:     	  %120 = getelementptr [4 x i8], [4 x i8]* @.str.2, i64 0, i64 0
DOALL:     Edges: 27
DOALL:     Loop-carried data dependences
DOALL:         %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 --->   %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 via memory
DOALL:         %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 --->   %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 via memory
DOALL:         %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 --->   %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 via memory
DOALL:         %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 --->   %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 via memory
DOALL:         %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 --->   %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 via memory
DOALL:         %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 --->   %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 via memory
DOALL:         %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 --->   %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 via memory
DOALL:         %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 --->   %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 via memory
DOALL:         %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 via memory
DOALL:         %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 --->   %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 via memory
DOALL:         %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 --->   %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 9
DOALL:     	  call void @SolveCubic(double %.01, double %.02, double %.03, double %.04, i32* nonnull %2, double* nonnull %8)
DOALL:     	  %113 = load i32, i32* %2, align 4, !tbaa !30
DOALL:     	  %114 = sext i32 %113 to i64
DOALL:     	  %indvars.iv21 = phi i64 [ %indvars.iv.next22, %117 ], [ 0, %110 ]
DOALL:     	  %116 = icmp slt i64 %indvars.iv21, %114
DOALL:     	  br i1 %116, label %117, label %122, !prof !42
DOALL:     	  %118 = getelementptr inbounds [3 x double], [3 x double]* %1, i64 0, i64 %indvars.iv21
DOALL:     	  %119 = load double, double* %118, align 8, !tbaa !35
DOALL:     	  %indvars.iv.next22 = add nuw nsw i64 %indvars.iv21, 1
DOALL:     External nodes: 7
DOALL:     	  %.02 = phi double [ %127, %126 ], [ 1.000000e+01, %.preheader20.preheader ]
DOALL:     	  %.03 = phi double [ %125, %124 ], [ 5.000000e+00, %.preheader19.preheader ]
DOALL:     	  %.04 = phi double [ %123, %122 ], [ -1.000000e+00, %.preheader.preheader ]
DOALL:     	  br i1 %109, label %110, label %124, !prof !41
DOALL:     	  %120 = getelementptr [4 x i8], [4 x i8]* @.str.2, i64 0, i64 0
DOALL:     	  %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9
DOALL:     	  br label %115
DOALL:     Edges: 34
DOALL:     Loop-carried data dependences
DOALL:         call void @SolveCubic(double %.01, double %.02, double %.03, double %.04, i32* nonnull %2, double* nonnull %8) --->   %119 = load double, double* %118, align 8, !tbaa !35 via memory
DOALL:         call void @SolveCubic(double %.01, double %.02, double %.03, double %.04, i32* nonnull %2, double* nonnull %8) --->   %113 = load i32, i32* %2, align 4, !tbaa !30 via memory
DOALL:         call void @SolveCubic(double %.01, double %.02, double %.03, double %.04, i32* nonnull %2, double* nonnull %8) --->   call void @SolveCubic(double %.01, double %.02, double %.03, double %.04, i32* nonnull %2, double* nonnull %8) via memory
DOALL:         %113 = load i32, i32* %2, align 4, !tbaa !30 --->   call void @SolveCubic(double %.01, double %.02, double %.03, double %.04, i32* nonnull %2, double* nonnull %8) via memory
DOALL:         %119 = load double, double* %118, align 8, !tbaa !35 --->   call void @SolveCubic(double %.01, double %.02, double %.03, double %.04, i32* nonnull %2, double* nonnull %8) via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 9
DOALL:     	  call void @SolveCubic(double %.01, double %.02, double %.03, double %.04, i32* nonnull %2, double* nonnull %8)
DOALL:     	  %113 = load i32, i32* %2, align 4, !tbaa !30
DOALL:     	  %114 = sext i32 %113 to i64
DOALL:     	  %indvars.iv21 = phi i64 [ %indvars.iv.next22, %117 ], [ 0, %110 ]
DOALL:     	  %116 = icmp slt i64 %indvars.iv21, %114
DOALL:     	  br i1 %116, label %117, label %122, !prof !42
DOALL:     	  %118 = getelementptr inbounds [3 x double], [3 x double]* %1, i64 0, i64 %indvars.iv21
DOALL:     	  %119 = load double, double* %118, align 8, !tbaa !35
DOALL:     	  %indvars.iv.next22 = add nuw nsw i64 %indvars.iv21, 1
DOALL:     External nodes: 6
DOALL:     	  %.03 = phi double [ %125, %124 ], [ 5.000000e+00, %.preheader19.preheader ]
DOALL:     	  %.04 = phi double [ %123, %122 ], [ -1.000000e+00, %.preheader.preheader ]
DOALL:     	  br i1 %109, label %110, label %124, !prof !41
DOALL:     	  %120 = getelementptr [4 x i8], [4 x i8]* @.str.2, i64 0, i64 0
DOALL:     	  %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9
DOALL:     	  br label %115
DOALL:     Edges: 33
DOALL:     Loop-carried data dependences
DOALL:         %119 = load double, double* %118, align 8, !tbaa !35 --->   call void @SolveCubic(double %.01, double %.02, double %.03, double %.04, i32* nonnull %2, double* nonnull %8) via memory
DOALL:         call void @SolveCubic(double %.01, double %.02, double %.03, double %.04, i32* nonnull %2, double* nonnull %8) --->   %119 = load double, double* %118, align 8, !tbaa !35 via memory
DOALL:         call void @SolveCubic(double %.01, double %.02, double %.03, double %.04, i32* nonnull %2, double* nonnull %8) --->   %113 = load i32, i32* %2, align 4, !tbaa !30 via memory
DOALL:         call void @SolveCubic(double %.01, double %.02, double %.03, double %.04, i32* nonnull %2, double* nonnull %8) --->   call void @SolveCubic(double %.01, double %.02, double %.03, double %.04, i32* nonnull %2, double* nonnull %8) via memory
DOALL:         %113 = load i32, i32* %2, align 4, !tbaa !30 --->   call void @SolveCubic(double %.01, double %.02, double %.03, double %.04, i32* nonnull %2, double* nonnull %8) via memory
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 3
DOALL:     	  %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9
DOALL:     	  %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9
DOALL:     	  %putchar18 = tail call i32 @putchar(i32 10)
DOALL:     External nodes: 5
DOALL:     	  br i1 %109, label %110, label %124, !prof !41
DOALL:     	  %111 = getelementptr [11 x i8], [11 x i8]* @.str.1, i64 0, i64 0
DOALL:     	  br i1 %116, label %117, label %122, !prof !42
DOALL:     	  %119 = load double, double* %118, align 8, !tbaa !35
DOALL:     	  %120 = getelementptr [4 x i8], [4 x i8]* @.str.2, i64 0, i64 0
DOALL:     Edges: 27
DOALL:     Loop-carried data dependences
DOALL:         %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 --->   %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 via memory
DOALL:         %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 --->   %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 via memory
DOALL:         %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 via memory
DOALL:         %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 --->   %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 via memory
DOALL:         %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 --->   %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 via memory
DOALL:         %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 --->   %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 via memory
DOALL:         %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 --->   %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 via memory
DOALL:         %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 --->   %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 via memory
DOALL:         %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 --->   %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 via memory
DOALL:         %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 --->   %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 via memory
DOALL:         %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 --->   %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 3
DOALL:     	  %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9
DOALL:     	  %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9
DOALL:     	  %putchar18 = tail call i32 @putchar(i32 10)
DOALL:     External nodes: 5
DOALL:     	  br i1 %109, label %110, label %124, !prof !41
DOALL:     	  %111 = getelementptr [11 x i8], [11 x i8]* @.str.1, i64 0, i64 0
DOALL:     	  br i1 %116, label %117, label %122, !prof !42
DOALL:     	  %119 = load double, double* %118, align 8, !tbaa !35
DOALL:     	  %120 = getelementptr [4 x i8], [4 x i8]* @.str.2, i64 0, i64 0
DOALL:     Edges: 27
DOALL:     Loop-carried data dependences
DOALL:         %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 --->   %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 via memory
DOALL:         %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 --->   %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 via memory
DOALL:         %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 --->   %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 via memory
DOALL:         %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 --->   %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 via memory
DOALL:         %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 --->   %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 via memory
DOALL:         %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 --->   %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 via memory
DOALL:         %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 --->   %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 via memory
DOALL:         %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 --->   %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 via memory
DOALL:         %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 --->   %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 via memory
DOALL:         %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 --->   %112 = tail call i32 (i8*, ...) @printf(i8* %111) #9 via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9 via memory
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 9
DOALL:     	  call void @SolveCubic(double %.01, double %.02, double %.03, double %.04, i32* nonnull %2, double* nonnull %8)
DOALL:     	  %113 = load i32, i32* %2, align 4, !tbaa !30
DOALL:     	  %114 = sext i32 %113 to i64
DOALL:     	  %indvars.iv21 = phi i64 [ %indvars.iv.next22, %117 ], [ 0, %110 ]
DOALL:     	  %116 = icmp slt i64 %indvars.iv21, %114
DOALL:     	  br i1 %116, label %117, label %122, !prof !42
DOALL:     	  %118 = getelementptr inbounds [3 x double], [3 x double]* %1, i64 0, i64 %indvars.iv21
DOALL:     	  %119 = load double, double* %118, align 8, !tbaa !35
DOALL:     	  %indvars.iv.next22 = add nuw nsw i64 %indvars.iv21, 1
DOALL:     External nodes: 5
DOALL:     	  %.04 = phi double [ %123, %122 ], [ -1.000000e+00, %.preheader.preheader ]
DOALL:     	  br i1 %109, label %110, label %124, !prof !41
DOALL:     	  %120 = getelementptr [4 x i8], [4 x i8]* @.str.2, i64 0, i64 0
DOALL:     	  %121 = tail call i32 (i8*, ...) @printf(i8* %120, double %119) #9
DOALL:     	  br label %115
DOALL:     Edges: 30
DOALL:     Loop-carried data dependences
DOALL:         %119 = load double, double* %118, align 8, !tbaa !35 --->   call void @SolveCubic(double %.01, double %.02, double %.03, double %.04, i32* nonnull %2, double* nonnull %8) via memory
DOALL:         call void @SolveCubic(double %.01, double %.02, double %.03, double %.04, i32* nonnull %2, double* nonnull %8) --->   %113 = load i32, i32* %2, align 4, !tbaa !30 via memory
DOALL:         call void @SolveCubic(double %.01, double %.02, double %.03, double %.04, i32* nonnull %2, double* nonnull %8) --->   %119 = load double, double* %118, align 8, !tbaa !35 via memory
DOALL:         call void @SolveCubic(double %.01, double %.02, double %.03, double %.04, i32* nonnull %2, double* nonnull %8) --->   call void @SolveCubic(double %.01, double %.02, double %.03, double %.04, i32* nonnull %2, double* nonnull %8) via memory
DOALL:         %113 = load i32, i32* %2, align 4, !tbaa !30 --->   call void @SolveCubic(double %.01, double %.02, double %.03, double %.04, i32* nonnull %2, double* nonnull %8) via memory
Inliner:   Inlining in: main (237 instructions. The inlining will add 89 instructions),   call void @SolveCubic(double %.01, double %.02, double %.03, double %.04, i32* nonnull %2, double* nonnull %8)
Inliner:   Inlined calls due to loop-carried data dependences
Inliner: Exit
Noelle:  Function "main"
Noelle:     Loop "  %14 = icmp slt i64 %indvars.iv37, %12" (7.129826e-08%)
Noelle:     Loop "  %26 = icmp slt i64 %indvars.iv35, %24" (2.851930e-08%)
Noelle:     Loop "  %38 = icmp slt i64 %indvars.iv33, %36" (2.851930e-08%)
Noelle:     Loop "  %50 = icmp slt i64 %indvars.iv31, %48" (2.851930e-08%)
Noelle:     Loop "  %62 = icmp slt i64 %indvars.iv29, %60" (2.851930e-08%)
Noelle:     Loop "  %74 = icmp slt i64 %indvars.iv27, %72" (2.851930e-08%)
Noelle:     Loop "  %86 = icmp slt i64 %indvars.iv25, %84" (2.851930e-08%)
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv23, %96" (2.851930e-08%)
Noelle:     Loop "  %106 = fcmp olt double %.01, 1.000000e+03" (9.764485e+01%)
Noelle:     Loop "  %107 = fcmp ogt double %.02, 0.000000e+00" (9.764483e+01%)
Noelle:     Loop "  %108 = fcmp olt double %.03, 1.000000e+03" (9.764425e+01%)
Noelle:     Loop "  %109 = fcmp ogt double %.04, -5.000000e+00" (9.671403e+01%)
Noelle:     Loop "  %116 = icmp slt i64 %indvars.iv21, %114" (1.673906e+01%)
Noelle:     Loop "  %134 = icmp ult i64 %indvars.iv, 100000" (8.223066e-02%)
Noelle:     Loop "  %exitcond = icmp eq i64 %.0, 1072513385" (2.690641e-02%)
Noelle:     Loop "  %150 = fcmp ugt double %.05, 3.600000e+02" (8.506213e-01%)
Noelle:     Loop "  %162 = tail call double @atan(double 1.000000e+00) #9" (3.285804e-04%)
Noelle:  Function "SolveCubic"
Noelle:  Function "usqrt"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 32" (1.069672e-01%)
Noelle:  Function "deg2rad"
Noelle:  Function "rad2deg"
Noelle:  Function "main"
Noelle:     Loop "  %14 = icmp slt i64 %indvars.iv37, %12" (4.418140e-08%)
Noelle:     Loop "  %26 = icmp slt i64 %indvars.iv35, %24" (1.767256e-08%)
Noelle:     Loop "  %38 = icmp slt i64 %indvars.iv33, %36" (1.767256e-08%)
Noelle:     Loop "  %50 = icmp slt i64 %indvars.iv31, %48" (1.767256e-08%)
Noelle:     Loop "  %62 = icmp slt i64 %indvars.iv29, %60" (1.767256e-08%)
Noelle:     Loop "  %74 = icmp slt i64 %indvars.iv27, %72" (1.767256e-08%)
Noelle:     Loop "  %86 = icmp slt i64 %indvars.iv25, %84" (1.767256e-08%)
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv23, %96" (1.767256e-08%)
Noelle:     Loop "  %106 = fcmp olt double %.01, 1.000000e+03" (5.964321e+01%)
Noelle:     Loop "  %107 = fcmp ogt double %.02, 0.000000e+00" (5.964320e+01%)
Noelle:     Loop "  %108 = fcmp olt double %.03, 1.000000e+03" (5.964284e+01%)
Noelle:     Loop "  %109 = fcmp ogt double %.04, -5.000000e+00" (5.906641e+01%)
Noelle:     Loop "  %197 = icmp slt i64 %indvars.iv21, %195" (1.037269e+01%)
Noelle:     Loop "  %215 = icmp ult i64 %indvars.iv, 100000" (5.095588e-02%)
Noelle:     Loop "  %exitcond = icmp eq i64 %.0, 1072513385" (1.667310e-02%)
Noelle:     Loop "  %231 = fcmp ugt double %.05, 3.600000e+02" (5.271046e-01%)
Noelle:     Loop "  %243 = tail call double @atan(double 1.000000e+00) #9" (2.036114e-04%)
Noelle:  Function "SolveCubic"
Noelle:  Function "usqrt"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 32" (6.628440e-02%)
Noelle:  Function "deg2rad"
Noelle:  Function "rad2deg"
NOELLE: FixedPoint:       There are 85 different instructions and 340 different loop instructions
NOELLE: FixedPoint:       Normalize the code
noelle-norm /tmp/tmp.q6mAmBf70o -o /tmp/tmp.q6mAmBf70o
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.q6mAmBf70o -o /tmp/tmp.q6mAmBf70o
NOELLE: FixedPoint:     Invocation 1
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.RvOJsYjpgT -o /tmp/tmp.q6mAmBf70o
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.RvOJsYjpgT -o /tmp/tmp.q6mAmBf70o
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.RvOJsYjpgT -o /tmp/tmp.q6mAmBf70o
Inliner: Start
Inliner:   Number of program instructions = 447
Inliner:   Profiles are available and will be used
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 5
DOALL:     	  store double %152, double* %8, align 8, !tbaa !35
DOALL:     	  store double %162, double* %163, align 8, !tbaa !35
DOALL:     	  store double %173, double* %174, align 8, !tbaa !35
DOALL:     	  store double %191, double* %8, align 8, !tbaa !35
DOALL:     	  %200 = load double, double* %199, align 8, !tbaa !35
DOALL:     External nodes: 10
DOALL:     	  br i1 %135, label %175, label %136, !prof !42
DOALL:     	  %152 = fptrunc x86_fp80 %151 to double
DOALL:     	  %162 = fptrunc x86_fp80 %161 to double
DOALL:     	  %163 = getelementptr inbounds double, double* %8, i64 1
DOALL:     	  %173 = fptrunc x86_fp80 %172 to double
DOALL:     	  %174 = getelementptr inbounds double, double* %8, i64 2
DOALL:     	  %191 = fptrunc x86_fp80 %190 to double
DOALL:     	  br i1 %197, label %198, label %203, !prof !44
DOALL:     	  %199 = getelementptr inbounds [3 x double], [3 x double]* %1, i64 0, i64 %indvars.iv21
DOALL:     	  %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9
DOALL:     Edges: 35
DOALL:     Loop-carried data dependences
DOALL:         store double %152, double* %8, align 8, !tbaa !35 --->   store double %191, double* %8, align 8, !tbaa !35 via memory
DOALL:         store double %152, double* %8, align 8, !tbaa !35 --->   store double %162, double* %163, align 8, !tbaa !35 via memory
DOALL:         store double %162, double* %163, align 8, !tbaa !35 --->   %200 = load double, double* %199, align 8, !tbaa !35 via memory
DOALL:         store double %162, double* %163, align 8, !tbaa !35 --->   store double %191, double* %8, align 8, !tbaa !35 via memory
DOALL:         store double %162, double* %163, align 8, !tbaa !35 --->   store double %152, double* %8, align 8, !tbaa !35 via memory
DOALL:         store double %152, double* %8, align 8, !tbaa !35 --->   store double %173, double* %174, align 8, !tbaa !35 via memory
DOALL:         store double %162, double* %163, align 8, !tbaa !35 --->   store double %162, double* %163, align 8, !tbaa !35 via memory
DOALL:         store double %173, double* %174, align 8, !tbaa !35 --->   %200 = load double, double* %199, align 8, !tbaa !35 via memory
DOALL:         store double %173, double* %174, align 8, !tbaa !35 --->   store double %191, double* %8, align 8, !tbaa !35 via memory
DOALL:         store double %173, double* %174, align 8, !tbaa !35 --->   store double %152, double* %8, align 8, !tbaa !35 via memory
DOALL:         store double %173, double* %174, align 8, !tbaa !35 --->   store double %173, double* %174, align 8, !tbaa !35 via memory
DOALL:         store double %191, double* %8, align 8, !tbaa !35 --->   store double %173, double* %174, align 8, !tbaa !35 via memory
DOALL:         store double %191, double* %8, align 8, !tbaa !35 --->   store double %191, double* %8, align 8, !tbaa !35 via memory
DOALL:         store double %191, double* %8, align 8, !tbaa !35 --->   store double %152, double* %8, align 8, !tbaa !35 via memory
DOALL:         store double %152, double* %8, align 8, !tbaa !35 --->   store double %152, double* %8, align 8, !tbaa !35 via memory
DOALL:         store double %152, double* %8, align 8, !tbaa !35 --->   %200 = load double, double* %199, align 8, !tbaa !35 via memory
DOALL:         store double %191, double* %8, align 8, !tbaa !35 --->   %200 = load double, double* %199, align 8, !tbaa !35 via memory
DOALL:         store double %191, double* %8, align 8, !tbaa !35 --->   store double %162, double* %163, align 8, !tbaa !35 via memory
DOALL:         %200 = load double, double* %199, align 8, !tbaa !35 --->   store double %173, double* %174, align 8, !tbaa !35 via memory
DOALL:         %200 = load double, double* %199, align 8, !tbaa !35 --->   store double %162, double* %163, align 8, !tbaa !35 via memory
DOALL:         %200 = load double, double* %199, align 8, !tbaa !35 --->   store double %191, double* %8, align 8, !tbaa !35 via memory
DOALL:         %200 = load double, double* %199, align 8, !tbaa !35 --->   store double %152, double* %8, align 8, !tbaa !35 via memory
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 3
DOALL:     	  %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9
DOALL:     	  %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9
DOALL:     	  %putchar18 = tail call i32 @putchar(i32 10)
DOALL:     External nodes: 5
DOALL:     	  br i1 %109, label %110, label %205, !prof !41
DOALL:     	  %192 = getelementptr [11 x i8], [11 x i8]* @.str.1, i64 0, i64 0
DOALL:     	  br i1 %197, label %198, label %203, !prof !44
DOALL:     	  %200 = load double, double* %199, align 8, !tbaa !35
DOALL:     	  %201 = getelementptr [4 x i8], [4 x i8]* @.str.2, i64 0, i64 0
DOALL:     Edges: 27
DOALL:     Loop-carried data dependences
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 --->   %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 via memory
DOALL:         %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 --->   %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 via memory
DOALL:         %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 --->   %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 via memory
DOALL:         %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 --->   %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 via memory
DOALL:         %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 --->   %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 via memory
DOALL:         %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 --->   %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 via memory
DOALL:         %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 --->   %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 via memory
DOALL:         %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 --->   %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 via memory
DOALL:         %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 --->   %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 via memory
DOALL:         %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 --->   %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 via memory
DOALL:         %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 3
DOALL:     	  store i32 3, i32* %2, align 4, !tbaa !30
DOALL:     	  store i32 1, i32* %2, align 4, !tbaa !30
DOALL:     	  %194 = load i32, i32* %2, align 4, !tbaa !30
DOALL:     External nodes: 3
DOALL:     	  br i1 %109, label %110, label %205, !prof !41
DOALL:     	  br i1 %135, label %175, label %136, !prof !42
DOALL:     	  %195 = sext i32 %194 to i64
DOALL:     Edges: 12
DOALL:     Loop-carried data dependences
DOALL:         store i32 3, i32* %2, align 4, !tbaa !30 --->   %194 = load i32, i32* %2, align 4, !tbaa !30 via memory
DOALL:         store i32 3, i32* %2, align 4, !tbaa !30 --->   store i32 3, i32* %2, align 4, !tbaa !30 via memory
DOALL:         store i32 3, i32* %2, align 4, !tbaa !30 --->   store i32 1, i32* %2, align 4, !tbaa !30 via memory
DOALL:         store i32 1, i32* %2, align 4, !tbaa !30 --->   %194 = load i32, i32* %2, align 4, !tbaa !30 via memory
DOALL:         store i32 1, i32* %2, align 4, !tbaa !30 --->   store i32 3, i32* %2, align 4, !tbaa !30 via memory
DOALL:         store i32 1, i32* %2, align 4, !tbaa !30 --->   store i32 1, i32* %2, align 4, !tbaa !30 via memory
DOALL:         %194 = load i32, i32* %2, align 4, !tbaa !30 --->   store i32 1, i32* %2, align 4, !tbaa !30 via memory
DOALL:         %194 = load i32, i32* %2, align 4, !tbaa !30 --->   store i32 3, i32* %2, align 4, !tbaa !30 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 3
DOALL:     	  %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9
DOALL:     	  %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9
DOALL:     	  %putchar18 = tail call i32 @putchar(i32 10)
DOALL:     External nodes: 5
DOALL:     	  br i1 %109, label %110, label %205, !prof !41
DOALL:     	  %192 = getelementptr [11 x i8], [11 x i8]* @.str.1, i64 0, i64 0
DOALL:     	  br i1 %197, label %198, label %203, !prof !44
DOALL:     	  %200 = load double, double* %199, align 8, !tbaa !35
DOALL:     	  %201 = getelementptr [4 x i8], [4 x i8]* @.str.2, i64 0, i64 0
DOALL:     Edges: 27
DOALL:     Loop-carried data dependences
DOALL:         %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 --->   %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 via memory
DOALL:         %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 --->   %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 via memory
DOALL:         %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 --->   %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 via memory
DOALL:         %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 --->   %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 via memory
DOALL:         %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 --->   %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 via memory
DOALL:         %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 --->   %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 via memory
DOALL:         %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 --->   %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 via memory
DOALL:         %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 --->   %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 via memory
DOALL:         %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 --->   %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 via memory
DOALL:         %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 --->   %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 via memory
DOALL:         %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 5
DOALL:     	  store double %152, double* %8, align 8, !tbaa !35
DOALL:     	  store double %162, double* %163, align 8, !tbaa !35
DOALL:     	  store double %173, double* %174, align 8, !tbaa !35
DOALL:     	  store double %191, double* %8, align 8, !tbaa !35
DOALL:     	  %200 = load double, double* %199, align 8, !tbaa !35
DOALL:     External nodes: 10
DOALL:     	  br i1 %135, label %175, label %136, !prof !42
DOALL:     	  %152 = fptrunc x86_fp80 %151 to double
DOALL:     	  %162 = fptrunc x86_fp80 %161 to double
DOALL:     	  %163 = getelementptr inbounds double, double* %8, i64 1
DOALL:     	  %173 = fptrunc x86_fp80 %172 to double
DOALL:     	  %174 = getelementptr inbounds double, double* %8, i64 2
DOALL:     	  %191 = fptrunc x86_fp80 %190 to double
DOALL:     	  br i1 %197, label %198, label %203, !prof !44
DOALL:     	  %199 = getelementptr inbounds [3 x double], [3 x double]* %1, i64 0, i64 %indvars.iv21
DOALL:     	  %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9
DOALL:     Edges: 35
DOALL:     Loop-carried data dependences
DOALL:         store double %152, double* %8, align 8, !tbaa !35 --->   %200 = load double, double* %199, align 8, !tbaa !35 via memory
DOALL:         store double %152, double* %8, align 8, !tbaa !35 --->   store double %173, double* %174, align 8, !tbaa !35 via memory
DOALL:         store double %152, double* %8, align 8, !tbaa !35 --->   store double %152, double* %8, align 8, !tbaa !35 via memory
DOALL:         store double %152, double* %8, align 8, !tbaa !35 --->   store double %191, double* %8, align 8, !tbaa !35 via memory
DOALL:         store double %152, double* %8, align 8, !tbaa !35 --->   store double %162, double* %163, align 8, !tbaa !35 via memory
DOALL:         store double %162, double* %163, align 8, !tbaa !35 --->   %200 = load double, double* %199, align 8, !tbaa !35 via memory
DOALL:         store double %162, double* %163, align 8, !tbaa !35 --->   store double %152, double* %8, align 8, !tbaa !35 via memory
DOALL:         store double %162, double* %163, align 8, !tbaa !35 --->   store double %191, double* %8, align 8, !tbaa !35 via memory
DOALL:         store double %162, double* %163, align 8, !tbaa !35 --->   store double %162, double* %163, align 8, !tbaa !35 via memory
DOALL:         store double %173, double* %174, align 8, !tbaa !35 --->   %200 = load double, double* %199, align 8, !tbaa !35 via memory
DOALL:         store double %173, double* %174, align 8, !tbaa !35 --->   store double %152, double* %8, align 8, !tbaa !35 via memory
DOALL:         store double %173, double* %174, align 8, !tbaa !35 --->   store double %191, double* %8, align 8, !tbaa !35 via memory
DOALL:         store double %173, double* %174, align 8, !tbaa !35 --->   store double %173, double* %174, align 8, !tbaa !35 via memory
DOALL:         store double %191, double* %8, align 8, !tbaa !35 --->   %200 = load double, double* %199, align 8, !tbaa !35 via memory
DOALL:         store double %191, double* %8, align 8, !tbaa !35 --->   store double %191, double* %8, align 8, !tbaa !35 via memory
DOALL:         store double %191, double* %8, align 8, !tbaa !35 --->   store double %173, double* %174, align 8, !tbaa !35 via memory
DOALL:         store double %191, double* %8, align 8, !tbaa !35 --->   store double %152, double* %8, align 8, !tbaa !35 via memory
DOALL:         store double %191, double* %8, align 8, !tbaa !35 --->   store double %162, double* %163, align 8, !tbaa !35 via memory
DOALL:         %200 = load double, double* %199, align 8, !tbaa !35 --->   store double %173, double* %174, align 8, !tbaa !35 via memory
DOALL:         %200 = load double, double* %199, align 8, !tbaa !35 --->   store double %162, double* %163, align 8, !tbaa !35 via memory
DOALL:         %200 = load double, double* %199, align 8, !tbaa !35 --->   store double %191, double* %8, align 8, !tbaa !35 via memory
DOALL:         %200 = load double, double* %199, align 8, !tbaa !35 --->   store double %152, double* %8, align 8, !tbaa !35 via memory
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 3
DOALL:     	  store i32 3, i32* %2, align 4, !tbaa !30
DOALL:     	  store i32 1, i32* %2, align 4, !tbaa !30
DOALL:     	  %194 = load i32, i32* %2, align 4, !tbaa !30
DOALL:     External nodes: 3
DOALL:     	  br i1 %109, label %110, label %205, !prof !41
DOALL:     	  br i1 %135, label %175, label %136, !prof !42
DOALL:     	  %195 = sext i32 %194 to i64
DOALL:     Edges: 12
DOALL:     Loop-carried data dependences
DOALL:         store i32 3, i32* %2, align 4, !tbaa !30 --->   store i32 3, i32* %2, align 4, !tbaa !30 via memory
DOALL:         store i32 3, i32* %2, align 4, !tbaa !30 --->   %194 = load i32, i32* %2, align 4, !tbaa !30 via memory
DOALL:         store i32 3, i32* %2, align 4, !tbaa !30 --->   store i32 1, i32* %2, align 4, !tbaa !30 via memory
DOALL:         store i32 1, i32* %2, align 4, !tbaa !30 --->   %194 = load i32, i32* %2, align 4, !tbaa !30 via memory
DOALL:         store i32 1, i32* %2, align 4, !tbaa !30 --->   store i32 3, i32* %2, align 4, !tbaa !30 via memory
DOALL:         store i32 1, i32* %2, align 4, !tbaa !30 --->   store i32 1, i32* %2, align 4, !tbaa !30 via memory
DOALL:         %194 = load i32, i32* %2, align 4, !tbaa !30 --->   store i32 1, i32* %2, align 4, !tbaa !30 via memory
DOALL:         %194 = load i32, i32* %2, align 4, !tbaa !30 --->   store i32 3, i32* %2, align 4, !tbaa !30 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 3
DOALL:     	  store i32 3, i32* %2, align 4, !tbaa !30
DOALL:     	  store i32 1, i32* %2, align 4, !tbaa !30
DOALL:     	  %194 = load i32, i32* %2, align 4, !tbaa !30
DOALL:     External nodes: 3
DOALL:     	  br i1 %109, label %110, label %205, !prof !41
DOALL:     	  br i1 %135, label %175, label %136, !prof !42
DOALL:     	  %195 = sext i32 %194 to i64
DOALL:     Edges: 12
DOALL:     Loop-carried data dependences
DOALL:         store i32 3, i32* %2, align 4, !tbaa !30 --->   %194 = load i32, i32* %2, align 4, !tbaa !30 via memory
DOALL:         store i32 3, i32* %2, align 4, !tbaa !30 --->   store i32 3, i32* %2, align 4, !tbaa !30 via memory
DOALL:         store i32 3, i32* %2, align 4, !tbaa !30 --->   store i32 1, i32* %2, align 4, !tbaa !30 via memory
DOALL:         store i32 1, i32* %2, align 4, !tbaa !30 --->   %194 = load i32, i32* %2, align 4, !tbaa !30 via memory
DOALL:         store i32 1, i32* %2, align 4, !tbaa !30 --->   store i32 3, i32* %2, align 4, !tbaa !30 via memory
DOALL:         store i32 1, i32* %2, align 4, !tbaa !30 --->   store i32 1, i32* %2, align 4, !tbaa !30 via memory
DOALL:         %194 = load i32, i32* %2, align 4, !tbaa !30 --->   store i32 1, i32* %2, align 4, !tbaa !30 via memory
DOALL:         %194 = load i32, i32* %2, align 4, !tbaa !30 --->   store i32 3, i32* %2, align 4, !tbaa !30 via memory
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 3
DOALL:     	  %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9
DOALL:     	  %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9
DOALL:     	  %putchar18 = tail call i32 @putchar(i32 10)
DOALL:     External nodes: 5
DOALL:     	  br i1 %109, label %110, label %205, !prof !41
DOALL:     	  %192 = getelementptr [11 x i8], [11 x i8]* @.str.1, i64 0, i64 0
DOALL:     	  br i1 %197, label %198, label %203, !prof !44
DOALL:     	  %200 = load double, double* %199, align 8, !tbaa !35
DOALL:     	  %201 = getelementptr [4 x i8], [4 x i8]* @.str.2, i64 0, i64 0
DOALL:     Edges: 27
DOALL:     Loop-carried data dependences
DOALL:         %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 --->   %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 via memory
DOALL:         %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 --->   %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 via memory
DOALL:         %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 --->   %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 via memory
DOALL:         %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 --->   %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 via memory
DOALL:         %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 --->   %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 via memory
DOALL:         %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 --->   %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 --->   %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 --->   %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 via memory
DOALL:         %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 --->   %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 via memory
DOALL:         %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 --->   %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 via memory
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 5
DOALL:     	  store double %152, double* %8, align 8, !tbaa !35
DOALL:     	  store double %162, double* %163, align 8, !tbaa !35
DOALL:     	  store double %173, double* %174, align 8, !tbaa !35
DOALL:     	  store double %191, double* %8, align 8, !tbaa !35
DOALL:     	  %200 = load double, double* %199, align 8, !tbaa !35
DOALL:     External nodes: 10
DOALL:     	  br i1 %135, label %175, label %136, !prof !42
DOALL:     	  %152 = fptrunc x86_fp80 %151 to double
DOALL:     	  %162 = fptrunc x86_fp80 %161 to double
DOALL:     	  %163 = getelementptr inbounds double, double* %8, i64 1
DOALL:     	  %173 = fptrunc x86_fp80 %172 to double
DOALL:     	  %174 = getelementptr inbounds double, double* %8, i64 2
DOALL:     	  %191 = fptrunc x86_fp80 %190 to double
DOALL:     	  br i1 %197, label %198, label %203, !prof !44
DOALL:     	  %199 = getelementptr inbounds [3 x double], [3 x double]* %1, i64 0, i64 %indvars.iv21
DOALL:     	  %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9
DOALL:     Edges: 35
DOALL:     Loop-carried data dependences
DOALL:         store double %152, double* %8, align 8, !tbaa !35 --->   %200 = load double, double* %199, align 8, !tbaa !35 via memory
DOALL:         store double %152, double* %8, align 8, !tbaa !35 --->   store double %191, double* %8, align 8, !tbaa !35 via memory
DOALL:         store double %152, double* %8, align 8, !tbaa !35 --->   store double %173, double* %174, align 8, !tbaa !35 via memory
DOALL:         store double %152, double* %8, align 8, !tbaa !35 --->   store double %152, double* %8, align 8, !tbaa !35 via memory
DOALL:         store double %152, double* %8, align 8, !tbaa !35 --->   store double %162, double* %163, align 8, !tbaa !35 via memory
DOALL:         store double %162, double* %163, align 8, !tbaa !35 --->   store double %191, double* %8, align 8, !tbaa !35 via memory
DOALL:         store double %162, double* %163, align 8, !tbaa !35 --->   %200 = load double, double* %199, align 8, !tbaa !35 via memory
DOALL:         %200 = load double, double* %199, align 8, !tbaa !35 --->   store double %191, double* %8, align 8, !tbaa !35 via memory
DOALL:         %200 = load double, double* %199, align 8, !tbaa !35 --->   store double %152, double* %8, align 8, !tbaa !35 via memory
DOALL:         store double %162, double* %163, align 8, !tbaa !35 --->   store double %152, double* %8, align 8, !tbaa !35 via memory
DOALL:         store double %162, double* %163, align 8, !tbaa !35 --->   store double %162, double* %163, align 8, !tbaa !35 via memory
DOALL:         store double %173, double* %174, align 8, !tbaa !35 --->   %200 = load double, double* %199, align 8, !tbaa !35 via memory
DOALL:         store double %173, double* %174, align 8, !tbaa !35 --->   store double %191, double* %8, align 8, !tbaa !35 via memory
DOALL:         store double %173, double* %174, align 8, !tbaa !35 --->   store double %152, double* %8, align 8, !tbaa !35 via memory
DOALL:         store double %173, double* %174, align 8, !tbaa !35 --->   store double %173, double* %174, align 8, !tbaa !35 via memory
DOALL:         store double %191, double* %8, align 8, !tbaa !35 --->   store double %173, double* %174, align 8, !tbaa !35 via memory
DOALL:         store double %191, double* %8, align 8, !tbaa !35 --->   store double %191, double* %8, align 8, !tbaa !35 via memory
DOALL:         store double %191, double* %8, align 8, !tbaa !35 --->   store double %152, double* %8, align 8, !tbaa !35 via memory
DOALL:         store double %191, double* %8, align 8, !tbaa !35 --->   %200 = load double, double* %199, align 8, !tbaa !35 via memory
DOALL:         store double %191, double* %8, align 8, !tbaa !35 --->   store double %162, double* %163, align 8, !tbaa !35 via memory
DOALL:         %200 = load double, double* %199, align 8, !tbaa !35 --->   store double %173, double* %174, align 8, !tbaa !35 via memory
DOALL:         %200 = load double, double* %199, align 8, !tbaa !35 --->   store double %162, double* %163, align 8, !tbaa !35 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 3
DOALL:     	  %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9
DOALL:     	  %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9
DOALL:     	  %putchar18 = tail call i32 @putchar(i32 10)
DOALL:     External nodes: 5
DOALL:     	  br i1 %109, label %110, label %205, !prof !41
DOALL:     	  %192 = getelementptr [11 x i8], [11 x i8]* @.str.1, i64 0, i64 0
DOALL:     	  br i1 %197, label %198, label %203, !prof !44
DOALL:     	  %200 = load double, double* %199, align 8, !tbaa !35
DOALL:     	  %201 = getelementptr [4 x i8], [4 x i8]* @.str.2, i64 0, i64 0
DOALL:     Edges: 27
DOALL:     Loop-carried data dependences
DOALL:         %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 --->   %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 via memory
DOALL:         %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 via memory
DOALL:         %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 --->   %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 via memory
DOALL:         %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 --->   %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 via memory
DOALL:         %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 --->   %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 via memory
DOALL:         %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 --->   %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 via memory
DOALL:         %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 --->   %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 via memory
DOALL:         %putchar18 = tail call i32 @putchar(i32 10) --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 --->   %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 via memory
DOALL:         %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 --->   %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 via memory
DOALL:         %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 --->   %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 via memory
DOALL:         %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 --->   %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 via memory
DOALL:         %193 = tail call i32 (i8*, ...) @printf(i8* %192) #9 --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:         %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9 --->   %putchar18 = tail call i32 @putchar(i32 10) via memory
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 5
DOALL:     	  store double %152, double* %8, align 8, !tbaa !35
DOALL:     	  store double %162, double* %163, align 8, !tbaa !35
DOALL:     	  store double %173, double* %174, align 8, !tbaa !35
DOALL:     	  store double %191, double* %8, align 8, !tbaa !35
DOALL:     	  %200 = load double, double* %199, align 8, !tbaa !35
DOALL:     External nodes: 10
DOALL:     	  br i1 %135, label %175, label %136, !prof !42
DOALL:     	  %152 = fptrunc x86_fp80 %151 to double
DOALL:     	  %162 = fptrunc x86_fp80 %161 to double
DOALL:     	  %163 = getelementptr inbounds double, double* %8, i64 1
DOALL:     	  %173 = fptrunc x86_fp80 %172 to double
DOALL:     	  %174 = getelementptr inbounds double, double* %8, i64 2
DOALL:     	  %191 = fptrunc x86_fp80 %190 to double
DOALL:     	  br i1 %197, label %198, label %203, !prof !44
DOALL:     	  %199 = getelementptr inbounds [3 x double], [3 x double]* %1, i64 0, i64 %indvars.iv21
DOALL:     	  %202 = tail call i32 (i8*, ...) @printf(i8* %201, double %200) #9
DOALL:     Edges: 35
DOALL:     Loop-carried data dependences
DOALL:         store double %152, double* %8, align 8, !tbaa !35 --->   store double %173, double* %174, align 8, !tbaa !35 via memory
DOALL:         store double %152, double* %8, align 8, !tbaa !35 --->   store double %162, double* %163, align 8, !tbaa !35 via memory
DOALL:         store double %152, double* %8, align 8, !tbaa !35 --->   %200 = load double, double* %199, align 8, !tbaa !35 via memory
DOALL:         store double %152, double* %8, align 8, !tbaa !35 --->   store double %191, double* %8, align 8, !tbaa !35 via memory
DOALL:         store double %152, double* %8, align 8, !tbaa !35 --->   store double %152, double* %8, align 8, !tbaa !35 via memory
DOALL:         store double %162, double* %163, align 8, !tbaa !35 --->   store double %191, double* %8, align 8, !tbaa !35 via memory
DOALL:         store double %162, double* %163, align 8, !tbaa !35 --->   %200 = load double, double* %199, align 8, !tbaa !35 via memory
DOALL:         store double %162, double* %163, align 8, !tbaa !35 --->   store double %152, double* %8, align 8, !tbaa !35 via memory
DOALL:         store double %162, double* %163, align 8, !tbaa !35 --->   store double %162, double* %163, align 8, !tbaa !35 via memory
DOALL:         store double %173, double* %174, align 8, !tbaa !35 --->   %200 = load double, double* %199, align 8, !tbaa !35 via memory
DOALL:         store double %173, double* %174, align 8, !tbaa !35 --->   store double %191, double* %8, align 8, !tbaa !35 via memory
DOALL:         store double %173, double* %174, align 8, !tbaa !35 --->   store double %152, double* %8, align 8, !tbaa !35 via memory
DOALL:         store double %173, double* %174, align 8, !tbaa !35 --->   store double %173, double* %174, align 8, !tbaa !35 via memory
DOALL:         store double %191, double* %8, align 8, !tbaa !35 --->   store double %173, double* %174, align 8, !tbaa !35 via memory
DOALL:         store double %191, double* %8, align 8, !tbaa !35 --->   store double %191, double* %8, align 8, !tbaa !35 via memory
DOALL:         store double %191, double* %8, align 8, !tbaa !35 --->   store double %152, double* %8, align 8, !tbaa !35 via memory
DOALL:         store double %191, double* %8, align 8, !tbaa !35 --->   %200 = load double, double* %199, align 8, !tbaa !35 via memory
DOALL:         store double %191, double* %8, align 8, !tbaa !35 --->   store double %162, double* %163, align 8, !tbaa !35 via memory
DOALL:         %200 = load double, double* %199, align 8, !tbaa !35 --->   store double %191, double* %8, align 8, !tbaa !35 via memory
DOALL:         %200 = load double, double* %199, align 8, !tbaa !35 --->   store double %173, double* %174, align 8, !tbaa !35 via memory
DOALL:         %200 = load double, double* %199, align 8, !tbaa !35 --->   store double %162, double* %163, align 8, !tbaa !35 via memory
DOALL:         %200 = load double, double* %199, align 8, !tbaa !35 --->   store double %152, double* %8, align 8, !tbaa !35 via memory
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 3
DOALL:     	  store i32 3, i32* %2, align 4, !tbaa !30
DOALL:     	  store i32 1, i32* %2, align 4, !tbaa !30
DOALL:     	  %194 = load i32, i32* %2, align 4, !tbaa !30
DOALL:     External nodes: 3
DOALL:     	  br i1 %109, label %110, label %205, !prof !41
DOALL:     	  br i1 %135, label %175, label %136, !prof !42
DOALL:     	  %195 = sext i32 %194 to i64
DOALL:     Edges: 12
DOALL:     Loop-carried data dependences
DOALL:         store i32 3, i32* %2, align 4, !tbaa !30 --->   %194 = load i32, i32* %2, align 4, !tbaa !30 via memory
DOALL:         store i32 3, i32* %2, align 4, !tbaa !30 --->   store i32 3, i32* %2, align 4, !tbaa !30 via memory
DOALL:         store i32 3, i32* %2, align 4, !tbaa !30 --->   store i32 1, i32* %2, align 4, !tbaa !30 via memory
DOALL:         store i32 1, i32* %2, align 4, !tbaa !30 --->   %194 = load i32, i32* %2, align 4, !tbaa !30 via memory
DOALL:         store i32 1, i32* %2, align 4, !tbaa !30 --->   store i32 3, i32* %2, align 4, !tbaa !30 via memory
DOALL:         store i32 1, i32* %2, align 4, !tbaa !30 --->   store i32 1, i32* %2, align 4, !tbaa !30 via memory
DOALL:         %194 = load i32, i32* %2, align 4, !tbaa !30 --->   store i32 3, i32* %2, align 4, !tbaa !30 via memory
DOALL:         %194 = load i32, i32* %2, align 4, !tbaa !30 --->   store i32 1, i32* %2, align 4, !tbaa !30 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
Inliner:   No remaining calls need to be inlined due to loop-carried data dependences
Inliner:   The code has not been modified
Inliner: Exit
Noelle:  Function "main"
Noelle:     Loop "  %14 = icmp slt i64 %indvars.iv37, %12" (4.418140e-08%)
Noelle:     Loop "  %26 = icmp slt i64 %indvars.iv35, %24" (1.767256e-08%)
Noelle:     Loop "  %38 = icmp slt i64 %indvars.iv33, %36" (1.767256e-08%)
Noelle:     Loop "  %50 = icmp slt i64 %indvars.iv31, %48" (1.767256e-08%)
Noelle:     Loop "  %62 = icmp slt i64 %indvars.iv29, %60" (1.767256e-08%)
Noelle:     Loop "  %74 = icmp slt i64 %indvars.iv27, %72" (1.767256e-08%)
Noelle:     Loop "  %86 = icmp slt i64 %indvars.iv25, %84" (1.767256e-08%)
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv23, %96" (1.767256e-08%)
Noelle:     Loop "  %106 = fcmp olt double %.01, 1.000000e+03" (5.964321e+01%)
Noelle:     Loop "  %107 = fcmp ogt double %.02, 0.000000e+00" (5.964320e+01%)
Noelle:     Loop "  %108 = fcmp olt double %.03, 1.000000e+03" (5.964284e+01%)
Noelle:     Loop "  %109 = fcmp ogt double %.04, -5.000000e+00" (5.906641e+01%)
Noelle:     Loop "  %197 = icmp slt i64 %indvars.iv21, %195" (1.037269e+01%)
Noelle:     Loop "  %215 = icmp ult i64 %indvars.iv, 100000" (5.095588e-02%)
Noelle:     Loop "  %exitcond = icmp eq i64 %.0, 1072513385" (1.667310e-02%)
Noelle:     Loop "  %231 = fcmp ugt double %.05, 3.600000e+02" (5.271046e-01%)
Noelle:     Loop "  %243 = tail call double @atan(double 1.000000e+00) #9" (2.036114e-04%)
Noelle:  Function "SolveCubic"
Noelle:  Function "usqrt"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 32" (6.628440e-02%)
Noelle:  Function "deg2rad"
Noelle:  Function "rad2deg"
Noelle:  Function "main"
Noelle:     Loop "  %14 = icmp slt i64 %indvars.iv37, %12" (4.418140e-08%)
Noelle:     Loop "  %26 = icmp slt i64 %indvars.iv35, %24" (1.767256e-08%)
Noelle:     Loop "  %38 = icmp slt i64 %indvars.iv33, %36" (1.767256e-08%)
Noelle:     Loop "  %50 = icmp slt i64 %indvars.iv31, %48" (1.767256e-08%)
Noelle:     Loop "  %62 = icmp slt i64 %indvars.iv29, %60" (1.767256e-08%)
Noelle:     Loop "  %74 = icmp slt i64 %indvars.iv27, %72" (1.767256e-08%)
Noelle:     Loop "  %86 = icmp slt i64 %indvars.iv25, %84" (1.767256e-08%)
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv23, %96" (1.767256e-08%)
Noelle:     Loop "  %106 = fcmp olt double %.01, 1.000000e+03" (5.964321e+01%)
Noelle:     Loop "  %107 = fcmp ogt double %.02, 0.000000e+00" (5.964320e+01%)
Noelle:     Loop "  %108 = fcmp olt double %.03, 1.000000e+03" (5.964284e+01%)
Noelle:     Loop "  %109 = fcmp ogt double %.04, -5.000000e+00" (5.906641e+01%)
Noelle:     Loop "  %197 = icmp slt i64 %indvars.iv21, %195" (1.037269e+01%)
Noelle:     Loop "  %215 = icmp ult i64 %indvars.iv, 100000" (5.095588e-02%)
Noelle:     Loop "  %exitcond = icmp eq i64 %.0, 1072513385" (1.667310e-02%)
Noelle:     Loop "  %231 = fcmp ugt double %.05, 3.600000e+02" (5.271046e-01%)
Noelle:     Loop "  %243 = tail call double @atan(double 1.000000e+00) #9" (2.036114e-04%)
Noelle:  Function "SolveCubic"
Noelle:  Function "usqrt"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 32" (6.628440e-02%)
Noelle:  Function "deg2rad"
Noelle:  Function "rad2deg"
NOELLE: FixedPoint: Exit
NOELLE: Inliner: Exit
noelle-simplification baseline_pre.bc -o baseline_pre.bc
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -tbaa -early-cse-memssa -licm -simplifycfg -simplifycfg-sink-common=false -instcombine -tailcallelim -loop-simplify -lcssa -licm -loop-unswitch -globalopt -instcombine -ipsccp -dce -gvn -dse -adce -loop-simplify -lcssa -indvars -loop-deletion -instcombine -indvars -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa --functionattrs --rpo-functionattrs baseline_pre.bc -o baseline_pre.bc
noelle-deadcode baseline_pre.bc baseline_pre.bc
NOELLE: DeadFunctions: Start
noelle-fixedpoint baseline_pre.bc baseline_pre.bc "noelle-load" -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DeadFunction.so -noelle-dfe
NOELLE: FixedPoint: Start
NOELLE: FixedPoint:   Loader: noelle-load
NOELLE: FixedPoint:   Options: -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DeadFunction.so -noelle-dfe
NOELLE: FixedPoint:   Input: baseline_pre.bc
NOELLE: FixedPoint:   Output: baseline_pre.bc
NOELLE: FixedPoint:   Temporary input: /tmp/tmp.m8pEvpOW5k (.ll version is /tmp/tmp.YMaJEh6Dow)
NOELLE: FixedPoint:   Temporary output: /tmp/tmp.MIPmCvWuri (.ll version is /tmp/tmp.GLNoGGH0CP)
NOELLE: FixedPoint:   Normalize the code
noelle-norm /tmp/tmp.m8pEvpOW5k -o /tmp/tmp.MIPmCvWuri
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.m8pEvpOW5k -o /tmp/tmp.MIPmCvWuri
NOELLE: FixedPoint:   Run until a fixed point is reached
NOELLE: FixedPoint:     Invocation 0
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DeadFunction.so -noelle-dfe /tmp/tmp.m8pEvpOW5k -o /tmp/tmp.MIPmCvWuri
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DeadFunction.so -noelle-dfe /tmp/tmp.m8pEvpOW5k -o /tmp/tmp.MIPmCvWuri
DeadFunctionEliminator: Start
DeadFunctionEliminator:   Inline functions that are invoked only by one call instruction and that do not escape into memory
DeadFunctionEliminator:   Get the islands
DeadFunctionEliminator:   Identify the islands reachable from the entry points
DeadFunctionEliminator:     Island
DeadFunctionEliminator:       main
DeadFunctionEliminator:       deg2rad
DeadFunctionEliminator:       llvm.lifetime.start.p0i8
DeadFunctionEliminator:       printf
DeadFunctionEliminator:       atan
DeadFunctionEliminator:       llvm.lifetime.end.p0i8
DeadFunctionEliminator:       rad2deg
DeadFunctionEliminator:       SolveCubic
DeadFunctionEliminator:       sqrt
DeadFunctionEliminator:       acos
DeadFunctionEliminator:       cos
DeadFunctionEliminator:       llvm.fabs.f64
DeadFunctionEliminator:       pow
DeadFunctionEliminator:       usqrt
DeadFunctionEliminator:       putchar
DeadFunctionEliminator:   Identify the functions that can be deleted
DeadFunctionEliminator: Exit
Noelle:  Function "main"
Noelle:     Loop "  %14 = icmp slt i64 %indvars.iv37, %12" (5.098792e-08%)
Noelle:     Loop "  %26 = icmp slt i64 %indvars.iv35, %24" (2.039517e-08%)
Noelle:     Loop "  %38 = icmp slt i64 %indvars.iv33, %36" (2.039517e-08%)
Noelle:     Loop "  %50 = icmp slt i64 %indvars.iv31, %48" (2.039517e-08%)
Noelle:     Loop "  %62 = icmp slt i64 %indvars.iv29, %60" (2.039517e-08%)
Noelle:     Loop "  %74 = icmp slt i64 %indvars.iv27, %72" (2.039517e-08%)
Noelle:     Loop "  %86 = icmp slt i64 %indvars.iv25, %84" (2.039517e-08%)
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv23, %96" (2.039517e-08%)
Noelle:     Loop "  %108 = fcmp olt double %.01, 1.000000e+03" (5.342590e+01%)
Noelle:     Loop "  %109 = fcmp ogt double %.02, 0.000000e+00" (5.342588e+01%)
Noelle:     Loop "  %118 = fcmp olt double %.03, 1.000000e+03" (5.342479e+01%)
Noelle:     Loop "  %131 = fcmp ogt double %.04, -5.000000e+00" (5.131858e+01%)
Noelle:     Loop "  %exitcond7 = icmp eq i64 %indvars.iv21, %195" (1.197070e+01%)
Noelle:     Loop "  %214 = icmp ult i64 %indvars.iv, 100000" (5.880608e-02%)
Noelle:     Loop "  %exitcond = icmp eq i64 %.0, 1072513385" (1.924173e-02%)
Noelle:     Loop "  %230 = fcmp ugt double %.05, 3.600000e+02" (6.083096e-01%)
Noelle:     Loop "  %242 = tail call double @atan(double 1.000000e+00) #9" (2.349795e-04%)
Noelle:  Function "SolveCubic"
Noelle:  Function "usqrt"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 32" (7.649608e-02%)
Noelle:  Function "deg2rad"
Noelle:  Function "rad2deg"
Noelle:  Function "main"
Noelle:     Loop "  %14 = icmp slt i64 %indvars.iv37, %12" (5.098792e-08%)
Noelle:     Loop "  %26 = icmp slt i64 %indvars.iv35, %24" (2.039517e-08%)
Noelle:     Loop "  %38 = icmp slt i64 %indvars.iv33, %36" (2.039517e-08%)
Noelle:     Loop "  %50 = icmp slt i64 %indvars.iv31, %48" (2.039517e-08%)
Noelle:     Loop "  %62 = icmp slt i64 %indvars.iv29, %60" (2.039517e-08%)
Noelle:     Loop "  %74 = icmp slt i64 %indvars.iv27, %72" (2.039517e-08%)
Noelle:     Loop "  %86 = icmp slt i64 %indvars.iv25, %84" (2.039517e-08%)
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv23, %96" (2.039517e-08%)
Noelle:     Loop "  %108 = fcmp olt double %.01, 1.000000e+03" (5.342590e+01%)
Noelle:     Loop "  %109 = fcmp ogt double %.02, 0.000000e+00" (5.342588e+01%)
Noelle:     Loop "  %118 = fcmp olt double %.03, 1.000000e+03" (5.342479e+01%)
Noelle:     Loop "  %131 = fcmp ogt double %.04, -5.000000e+00" (5.131858e+01%)
Noelle:     Loop "  %exitcond7 = icmp eq i64 %indvars.iv21, %195" (1.197070e+01%)
Noelle:     Loop "  %214 = icmp ult i64 %indvars.iv, 100000" (5.880608e-02%)
Noelle:     Loop "  %exitcond = icmp eq i64 %.0, 1072513385" (1.924173e-02%)
Noelle:     Loop "  %230 = fcmp ugt double %.05, 3.600000e+02" (6.083096e-01%)
Noelle:     Loop "  %242 = tail call double @atan(double 1.000000e+00) #9" (2.349795e-04%)
Noelle:  Function "SolveCubic"
Noelle:  Function "usqrt"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 32" (7.649608e-02%)
Noelle:  Function "deg2rad"
Noelle:  Function "rad2deg"
NOELLE: FixedPoint: Exit
NOELLE: DeadFunctions: Exit
noelle-simplification baseline_pre.bc -o baseline_pre.bc
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -tbaa -early-cse-memssa -licm -simplifycfg -simplifycfg-sink-common=false -instcombine -tailcallelim -loop-simplify -lcssa -licm -loop-unswitch -globalopt -instcombine -ipsccp -dce -gvn -dse -adce -loop-simplify -lcssa -indvars -loop-deletion -instcombine -indvars -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa --functionattrs --rpo-functionattrs baseline_pre.bc -o baseline_pre.bc
noelle-enable baseline_pre.bc baseline_pre.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier
NOELLE: Enablers: Start
noelle-fixedpoint baseline_pre.bc baseline_pre.bc "noelle-parallel-load" -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier
NOELLE: FixedPoint: Start
NOELLE: FixedPoint:   Loader: noelle-parallel-load
NOELLE: FixedPoint:   Options: -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier
NOELLE: FixedPoint:   Input: baseline_pre.bc
NOELLE: FixedPoint:   Output: baseline_pre.bc
NOELLE: FixedPoint:   Temporary input: /tmp/tmp.kem6a0IYPH (.ll version is /tmp/tmp.02B1sQMv37)
NOELLE: FixedPoint:   Temporary output: /tmp/tmp.4UAjlEdITx (.ll version is /tmp/tmp.f8jJasf5TU)
NOELLE: FixedPoint:   Normalize the code
noelle-norm /tmp/tmp.kem6a0IYPH -o /tmp/tmp.4UAjlEdITx
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.kem6a0IYPH -o /tmp/tmp.4UAjlEdITx
NOELLE: FixedPoint:   Run until a fixed point is reached
NOELLE: FixedPoint:     Invocation 0
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.kem6a0IYPH -o /tmp/tmp.4UAjlEdITx
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.kem6a0IYPH -o /tmp/tmp.4UAjlEdITx
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.kem6a0IYPH -o /tmp/tmp.4UAjlEdITx
EnablersManager: Start
Noelle: Filter out cold code
Noelle:  Function "main"
Noelle:     Loop "  %14 = icmp slt i64 %indvars.iv37, %12" (5.098792e-08%)
Noelle:  Disable loop "0" as cold code
Noelle:     Loop "  %26 = icmp slt i64 %indvars.iv35, %24" (2.039517e-08%)
Noelle:  Disable loop "1" as cold code
Noelle:     Loop "  %38 = icmp slt i64 %indvars.iv33, %36" (2.039517e-08%)
Noelle:  Disable loop "2" as cold code
Noelle:     Loop "  %50 = icmp slt i64 %indvars.iv31, %48" (2.039517e-08%)
Noelle:  Disable loop "3" as cold code
Noelle:     Loop "  %62 = icmp slt i64 %indvars.iv29, %60" (2.039517e-08%)
Noelle:  Disable loop "4" as cold code
Noelle:     Loop "  %74 = icmp slt i64 %indvars.iv27, %72" (2.039517e-08%)
Noelle:  Disable loop "5" as cold code
Noelle:     Loop "  %86 = icmp slt i64 %indvars.iv25, %84" (2.039517e-08%)
Noelle:  Disable loop "6" as cold code
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv23, %96" (2.039517e-08%)
Noelle:  Disable loop "7" as cold code
Noelle:     Loop "  %108 = fcmp olt double %.01, 1.000000e+03" (5.342590e+01%)
Noelle:     Loop "  %109 = fcmp ogt double %.02, 0.000000e+00" (5.342588e+01%)
Noelle:     Loop "  %118 = fcmp olt double %.03, 1.000000e+03" (5.342479e+01%)
Noelle:     Loop "  %131 = fcmp ogt double %.04, -5.000000e+00" (5.131858e+01%)
Noelle:     Loop "  %exitcond7 = icmp eq i64 %indvars.iv21, %195" (1.197070e+01%)
Noelle:     Loop "  %214 = icmp ult i64 %indvars.iv, 100000" (5.880608e-02%)
Noelle:  Disable loop "13" as cold code
Noelle:     Loop "  %exitcond = icmp eq i64 %.0, 1072513385" (1.924173e-02%)
Noelle:  Disable loop "14" as cold code
Noelle:     Loop "  %230 = fcmp ugt double %.05, 3.600000e+02" (6.083096e-01%)
Noelle:     Loop "  %242 = tail call double @atan(double 1.000000e+00) #9" (2.349795e-04%)
Noelle:  Disable loop "16" as cold code
Noelle:  Function "SolveCubic"
Noelle:  Function "usqrt"
Noelle:  Disable "usqrt" as cold function
EnablersManager:   Try to improve all 6 loops, one at a time
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %exitcond7 = icmp eq i64 %indvars.iv21, %195
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond7 = icmp eq i64 %indvars.iv21, %195"
LICM:     Invariant = "  %200 = getelementptr [4 x i8], [4 x i8]* @.str.2, i64 0, i64 0
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has been modified
LICM: Exit
EnablersManager:       Loop invariants have been extracted
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %131 = fcmp ogt double %.04, -5.000000e+00
EnablersManager:     The current loop belongs to the function main , which has already been modified.
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %118 = fcmp olt double %.03, 1.000000e+03
EnablersManager:     The current loop belongs to the function main , which has already been modified.
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %109 = fcmp ogt double %.02, 0.000000e+00
EnablersManager:     The current loop belongs to the function main , which has already been modified.
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %108 = fcmp olt double %.01, 1.000000e+03
EnablersManager:     The current loop belongs to the function main , which has already been modified.
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %230 = fcmp ugt double %.05, 3.600000e+02
EnablersManager:     The current loop belongs to the function main , which has already been modified.
EnablersManager: Exit
Noelle:  Function "main"
Noelle:     Loop "  %14 = icmp slt i64 %indvars.iv37, %12" (5.098792e-08%)
Noelle:     Loop "  %26 = icmp slt i64 %indvars.iv35, %24" (2.039517e-08%)
Noelle:     Loop "  %38 = icmp slt i64 %indvars.iv33, %36" (2.039517e-08%)
Noelle:     Loop "  %50 = icmp slt i64 %indvars.iv31, %48" (2.039517e-08%)
Noelle:     Loop "  %62 = icmp slt i64 %indvars.iv29, %60" (2.039517e-08%)
Noelle:     Loop "  %74 = icmp slt i64 %indvars.iv27, %72" (2.039517e-08%)
Noelle:     Loop "  %86 = icmp slt i64 %indvars.iv25, %84" (2.039517e-08%)
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv23, %96" (2.039517e-08%)
Noelle:     Loop "  %108 = fcmp olt double %.01, 1.000000e+03" (5.342590e+01%)
Noelle:     Loop "  %109 = fcmp ogt double %.02, 0.000000e+00" (5.342588e+01%)
Noelle:     Loop "  %118 = fcmp olt double %.03, 1.000000e+03" (5.342479e+01%)
Noelle:     Loop "  %131 = fcmp ogt double %.04, -5.000000e+00" (5.131858e+01%)
Noelle:     Loop "  %exitcond7 = icmp eq i64 %indvars.iv21, %195" (1.197070e+01%)
Noelle:     Loop "  %214 = icmp ult i64 %indvars.iv, 100000" (5.880608e-02%)
Noelle:     Loop "  %exitcond = icmp eq i64 %.0, 1072513385" (1.924173e-02%)
Noelle:     Loop "  %230 = fcmp ugt double %.05, 3.600000e+02" (6.083096e-01%)
Noelle:     Loop "  %242 = tail call double @atan(double 1.000000e+00) #9" (2.349795e-04%)
Noelle:  Function "SolveCubic"
Noelle:  Function "usqrt"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 32" (7.649608e-02%)
Noelle:  Function "deg2rad"
Noelle:  Function "rad2deg"
Noelle:  Function "main"
Noelle:     Loop "  %14 = icmp slt i64 %indvars.iv37, %12" (5.098793e-08%)
Noelle:     Loop "  %26 = icmp slt i64 %indvars.iv35, %24" (2.039517e-08%)
Noelle:     Loop "  %38 = icmp slt i64 %indvars.iv33, %36" (2.039517e-08%)
Noelle:     Loop "  %50 = icmp slt i64 %indvars.iv31, %48" (2.039517e-08%)
Noelle:     Loop "  %62 = icmp slt i64 %indvars.iv29, %60" (2.039517e-08%)
Noelle:     Loop "  %74 = icmp slt i64 %indvars.iv27, %72" (2.039517e-08%)
Noelle:     Loop "  %86 = icmp slt i64 %indvars.iv25, %84" (2.039517e-08%)
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv23, %96" (2.039517e-08%)
Noelle:     Loop "  %108 = fcmp olt double %.01, 1.000000e+03" (5.342589e+01%)
Noelle:     Loop "  %109 = fcmp ogt double %.02, 0.000000e+00" (5.342588e+01%)
Noelle:     Loop "  %118 = fcmp olt double %.03, 1.000000e+03" (5.342479e+01%)
Noelle:     Loop "  %131 = fcmp ogt double %.04, -5.000000e+00" (5.131858e+01%)
Noelle:     Loop "  %exitcond7 = icmp eq i64 %indvars.iv21, %195" (1.097314e+01%)
Noelle:     Loop "  %214 = icmp ult i64 %indvars.iv, 100000" (5.880608e-02%)
Noelle:     Loop "  %exitcond = icmp eq i64 %.0, 1072513385" (1.924174e-02%)
Noelle:     Loop "  %230 = fcmp ugt double %.05, 3.600000e+02" (6.083097e-01%)
Noelle:     Loop "  %242 = tail call double @atan(double 1.000000e+00) #9" (2.349796e-04%)
Noelle:  Function "SolveCubic"
Noelle:  Function "usqrt"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 32" (7.649609e-02%)
Noelle:  Function "deg2rad"
Noelle:  Function "rad2deg"
NOELLE: FixedPoint:       There are 0 different instructions and -1 different loop instructions
NOELLE: FixedPoint:       Normalize the code
noelle-norm /tmp/tmp.4UAjlEdITx -o /tmp/tmp.4UAjlEdITx
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.4UAjlEdITx -o /tmp/tmp.4UAjlEdITx
NOELLE: FixedPoint:     Invocation 1
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.kem6a0IYPH -o /tmp/tmp.4UAjlEdITx
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.kem6a0IYPH -o /tmp/tmp.4UAjlEdITx
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.kem6a0IYPH -o /tmp/tmp.4UAjlEdITx
EnablersManager: Start
Noelle: Filter out cold code
Noelle:  Function "main"
Noelle:     Loop "  %14 = icmp slt i64 %indvars.iv37, %12" (5.098793e-08%)
Noelle:  Disable loop "0" as cold code
Noelle:     Loop "  %26 = icmp slt i64 %indvars.iv35, %24" (2.039517e-08%)
Noelle:  Disable loop "1" as cold code
Noelle:     Loop "  %38 = icmp slt i64 %indvars.iv33, %36" (2.039517e-08%)
Noelle:  Disable loop "2" as cold code
Noelle:     Loop "  %50 = icmp slt i64 %indvars.iv31, %48" (2.039517e-08%)
Noelle:  Disable loop "3" as cold code
Noelle:     Loop "  %62 = icmp slt i64 %indvars.iv29, %60" (2.039517e-08%)
Noelle:  Disable loop "4" as cold code
Noelle:     Loop "  %74 = icmp slt i64 %indvars.iv27, %72" (2.039517e-08%)
Noelle:  Disable loop "5" as cold code
Noelle:     Loop "  %86 = icmp slt i64 %indvars.iv25, %84" (2.039517e-08%)
Noelle:  Disable loop "6" as cold code
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv23, %96" (2.039517e-08%)
Noelle:  Disable loop "7" as cold code
Noelle:     Loop "  %108 = fcmp olt double %.01, 1.000000e+03" (5.342589e+01%)
Noelle:     Loop "  %109 = fcmp ogt double %.02, 0.000000e+00" (5.342588e+01%)
Noelle:     Loop "  %118 = fcmp olt double %.03, 1.000000e+03" (5.342479e+01%)
Noelle:     Loop "  %131 = fcmp ogt double %.04, -5.000000e+00" (5.131858e+01%)
Noelle:     Loop "  %exitcond7 = icmp eq i64 %indvars.iv21, %195" (1.097314e+01%)
Noelle:     Loop "  %214 = icmp ult i64 %indvars.iv, 100000" (5.880608e-02%)
Noelle:  Disable loop "13" as cold code
Noelle:     Loop "  %exitcond = icmp eq i64 %.0, 1072513385" (1.924174e-02%)
Noelle:  Disable loop "14" as cold code
Noelle:     Loop "  %230 = fcmp ugt double %.05, 3.600000e+02" (6.083097e-01%)
Noelle:     Loop "  %242 = tail call double @atan(double 1.000000e+00) #9" (2.349796e-04%)
Noelle:  Disable loop "16" as cold code
Noelle:  Function "SolveCubic"
Noelle:  Function "usqrt"
Noelle:  Disable "usqrt" as cold function
EnablersManager:   Try to improve all 6 loops, one at a time
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %exitcond7 = icmp eq i64 %indvars.iv21, %195
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond7 = icmp eq i64 %indvars.iv21, %195"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond7, label %202, label %198, !prof !44
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %131 = fcmp ogt double %.04, -5.000000e+00
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %131 = fcmp ogt double %.04, -5.000000e+00"
LICM:     Invariant = "  %143 = tail call double @sqrt(double %128) #9
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %144 = fpext double %143 to x86_fp80
LICM:       Checking dependences
LICM:         Dependent instruction = "  %143 = tail call double @sqrt(double %128) #9
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %143 = tail call double @sqrt(double %128) #9
LICM:     Invariant = "  %148 = tail call double @sqrt(double %129) #9
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %149 = fmul double %148, -2.000000e+00
LICM:       Checking dependences
LICM:         Dependent instruction = "  %148 = tail call double @sqrt(double %129) #9
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %148 = tail call double @sqrt(double %129) #9
LICM:     Invariant = "  %156 = tail call double @sqrt(double %129) #9
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %157 = fmul double %156, -2.000000e+00
LICM:       Checking dependences
LICM:         Dependent instruction = "  %156 = tail call double @sqrt(double %129) #9
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %156 = tail call double @sqrt(double %129) #9
LICM:     Invariant = "  %158 = tail call double @atan(double 1.000000e+00) #9
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %166 = tail call double @sqrt(double %129) #9
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %167 = fmul double %166, -2.000000e+00
LICM:       Checking dependences
LICM:         Dependent instruction = "  %166 = tail call double @sqrt(double %129) #9
LICM:       The instruction is conditionally hoisted if the next invariants are hoisted as well:
LICM:         %166 = tail call double @sqrt(double %129) #9
LICM:     Invariant = "  %168 = tail call double @atan(double 1.000000e+00) #9
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %193 = getelementptr [11 x i8], [11 x i8]* @.str.1, i64 0, i64 0
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %196 = getelementptr [4 x i8], [4 x i8]* @.str.2, i64 0, i64 0
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:         Invariant   %144 = fpext double %143 to x86_fp80
LICM:           It can be hoisted
LICM:         Invariant   %149 = fmul double %148, -2.000000e+00
LICM:           It can be hoisted
LICM:         Invariant   %157 = fmul double %156, -2.000000e+00
LICM:           It can be hoisted
LICM:         Invariant   %167 = fmul double %166, -2.000000e+00
LICM:           It can be hoisted
LICM:   The loop has been modified
LICM: Exit
EnablersManager:       Loop invariants have been extracted
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %118 = fcmp olt double %.03, 1.000000e+03
EnablersManager:     The current loop belongs to the function main , which has already been modified.
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %109 = fcmp ogt double %.02, 0.000000e+00
EnablersManager:     The current loop belongs to the function main , which has already been modified.
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %108 = fcmp olt double %.01, 1.000000e+03
EnablersManager:     The current loop belongs to the function main , which has already been modified.
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %230 = fcmp ugt double %.05, 3.600000e+02
EnablersManager:     The current loop belongs to the function main , which has already been modified.
EnablersManager: Exit
Noelle:  Function "main"
Noelle:     Loop "  %14 = icmp slt i64 %indvars.iv37, %12" (5.098793e-08%)
Noelle:     Loop "  %26 = icmp slt i64 %indvars.iv35, %24" (2.039517e-08%)
Noelle:     Loop "  %38 = icmp slt i64 %indvars.iv33, %36" (2.039517e-08%)
Noelle:     Loop "  %50 = icmp slt i64 %indvars.iv31, %48" (2.039517e-08%)
Noelle:     Loop "  %62 = icmp slt i64 %indvars.iv29, %60" (2.039517e-08%)
Noelle:     Loop "  %74 = icmp slt i64 %indvars.iv27, %72" (2.039517e-08%)
Noelle:     Loop "  %86 = icmp slt i64 %indvars.iv25, %84" (2.039517e-08%)
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv23, %96" (2.039517e-08%)
Noelle:     Loop "  %108 = fcmp olt double %.01, 1.000000e+03" (5.342589e+01%)
Noelle:     Loop "  %109 = fcmp ogt double %.02, 0.000000e+00" (5.342588e+01%)
Noelle:     Loop "  %118 = fcmp olt double %.03, 1.000000e+03" (5.342479e+01%)
Noelle:     Loop "  %131 = fcmp ogt double %.04, -5.000000e+00" (5.131858e+01%)
Noelle:     Loop "  %exitcond7 = icmp eq i64 %indvars.iv21, %195" (1.097314e+01%)
Noelle:     Loop "  %214 = icmp ult i64 %indvars.iv, 100000" (5.880608e-02%)
Noelle:     Loop "  %exitcond = icmp eq i64 %.0, 1072513385" (1.924174e-02%)
Noelle:     Loop "  %230 = fcmp ugt double %.05, 3.600000e+02" (6.083097e-01%)
Noelle:     Loop "  %242 = tail call double @atan(double 1.000000e+00) #9" (2.349796e-04%)
Noelle:  Function "SolveCubic"
Noelle:  Function "usqrt"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 32" (7.649609e-02%)
Noelle:  Function "deg2rad"
Noelle:  Function "rad2deg"
Noelle:  Function "main"
Noelle:     Loop "  %14 = icmp slt i64 %indvars.iv37, %12" (5.132932e-08%)
Noelle:     Loop "  %26 = icmp slt i64 %indvars.iv35, %24" (2.053173e-08%)
Noelle:     Loop "  %38 = icmp slt i64 %indvars.iv33, %36" (2.053173e-08%)
Noelle:     Loop "  %50 = icmp slt i64 %indvars.iv31, %48" (2.053173e-08%)
Noelle:     Loop "  %62 = icmp slt i64 %indvars.iv29, %60" (2.053173e-08%)
Noelle:     Loop "  %74 = icmp slt i64 %indvars.iv27, %72" (2.053173e-08%)
Noelle:     Loop "  %86 = icmp slt i64 %indvars.iv25, %84" (2.053173e-08%)
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv23, %96" (2.053173e-08%)
Noelle:     Loop "  %108 = fcmp olt double %.01, 1.000000e+03" (5.311406e+01%)
Noelle:     Loop "  %109 = fcmp ogt double %.02, 0.000000e+00" (5.311404e+01%)
Noelle:     Loop "  %118 = fcmp olt double %.03, 1.000000e+03" (5.311294e+01%)
Noelle:     Loop "  %143 = fcmp ogt double %.04, -5.000000e+00" (4.965366e+01%)
Noelle:     Loop "  %exitcond7 = icmp eq i64 %indvars.iv21, %196" (1.104661e+01%)
Noelle:     Loop "  %214 = icmp ult i64 %indvars.iv, 100000" (5.919982e-02%)
Noelle:     Loop "  %exitcond = icmp eq i64 %.0, 1072513385" (1.937057e-02%)
Noelle:     Loop "  %230 = fcmp ugt double %.05, 3.600000e+02" (6.123826e-01%)
Noelle:     Loop "  %242 = tail call double @atan(double 1.000000e+00) #9" (2.365529e-04%)
Noelle:  Function "SolveCubic"
Noelle:  Function "usqrt"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 32" (7.700826e-02%)
Noelle:  Function "deg2rad"
Noelle:  Function "rad2deg"
NOELLE: FixedPoint:       There are 0 different instructions and -12 different loop instructions
NOELLE: FixedPoint:       Normalize the code
noelle-norm /tmp/tmp.4UAjlEdITx -o /tmp/tmp.4UAjlEdITx
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.4UAjlEdITx -o /tmp/tmp.4UAjlEdITx
NOELLE: FixedPoint:     Invocation 2
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.kem6a0IYPH -o /tmp/tmp.4UAjlEdITx
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.kem6a0IYPH -o /tmp/tmp.4UAjlEdITx
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.kem6a0IYPH -o /tmp/tmp.4UAjlEdITx
EnablersManager: Start
Noelle: Filter out cold code
Noelle:  Function "main"
Noelle:     Loop "  %14 = icmp slt i64 %indvars.iv37, %12" (5.132932e-08%)
Noelle:  Disable loop "0" as cold code
Noelle:     Loop "  %26 = icmp slt i64 %indvars.iv35, %24" (2.053173e-08%)
Noelle:  Disable loop "1" as cold code
Noelle:     Loop "  %38 = icmp slt i64 %indvars.iv33, %36" (2.053173e-08%)
Noelle:  Disable loop "2" as cold code
Noelle:     Loop "  %50 = icmp slt i64 %indvars.iv31, %48" (2.053173e-08%)
Noelle:  Disable loop "3" as cold code
Noelle:     Loop "  %62 = icmp slt i64 %indvars.iv29, %60" (2.053173e-08%)
Noelle:  Disable loop "4" as cold code
Noelle:     Loop "  %74 = icmp slt i64 %indvars.iv27, %72" (2.053173e-08%)
Noelle:  Disable loop "5" as cold code
Noelle:     Loop "  %86 = icmp slt i64 %indvars.iv25, %84" (2.053173e-08%)
Noelle:  Disable loop "6" as cold code
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv23, %96" (2.053173e-08%)
Noelle:  Disable loop "7" as cold code
Noelle:     Loop "  %108 = fcmp olt double %.01, 1.000000e+03" (5.311406e+01%)
Noelle:     Loop "  %109 = fcmp ogt double %.02, 0.000000e+00" (5.311404e+01%)
Noelle:     Loop "  %118 = fcmp olt double %.03, 1.000000e+03" (5.311294e+01%)
Noelle:     Loop "  %143 = fcmp ogt double %.04, -5.000000e+00" (4.965366e+01%)
Noelle:     Loop "  %exitcond7 = icmp eq i64 %indvars.iv21, %196" (1.104661e+01%)
Noelle:     Loop "  %214 = icmp ult i64 %indvars.iv, 100000" (5.919982e-02%)
Noelle:  Disable loop "13" as cold code
Noelle:     Loop "  %exitcond = icmp eq i64 %.0, 1072513385" (1.937057e-02%)
Noelle:  Disable loop "14" as cold code
Noelle:     Loop "  %230 = fcmp ugt double %.05, 3.600000e+02" (6.123826e-01%)
Noelle:     Loop "  %242 = tail call double @atan(double 1.000000e+00) #9" (2.365529e-04%)
Noelle:  Disable loop "16" as cold code
Noelle:  Function "SolveCubic"
Noelle:  Function "usqrt"
Noelle:  Disable "usqrt" as cold function
EnablersManager:   Try to improve all 6 loops, one at a time
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %exitcond7 = icmp eq i64 %indvars.iv21, %196
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond7 = icmp eq i64 %indvars.iv21, %196"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond7, label %202, label %198, !prof !44
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %143 = fcmp ogt double %.04, -5.000000e+00
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %143 = fcmp ogt double %.04, -5.000000e+00"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %143, label %144, label %204, !prof !41
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %118 = fcmp olt double %.03, 1.000000e+03
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %118 = fcmp olt double %.03, 1.000000e+03"
LICM:     Invariant = "  %136 = getelementptr [11 x i8], [11 x i8]* @.str.1, i64 0, i64 0
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %137 = getelementptr [4 x i8], [4 x i8]* @.str.2, i64 0, i64 0
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %138 = tail call double @atan(double 1.000000e+00) #9
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %141 = tail call double @atan(double 1.000000e+00) #9
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has been modified
LICM: Exit
EnablersManager:       Loop invariants have been extracted
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %109 = fcmp ogt double %.02, 0.000000e+00
EnablersManager:     The current loop belongs to the function main , which has already been modified.
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %108 = fcmp olt double %.01, 1.000000e+03
EnablersManager:     The current loop belongs to the function main , which has already been modified.
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %230 = fcmp ugt double %.05, 3.600000e+02
EnablersManager:     The current loop belongs to the function main , which has already been modified.
EnablersManager: Exit
Noelle:  Function "main"
Noelle:     Loop "  %14 = icmp slt i64 %indvars.iv37, %12" (5.132932e-08%)
Noelle:     Loop "  %26 = icmp slt i64 %indvars.iv35, %24" (2.053173e-08%)
Noelle:     Loop "  %38 = icmp slt i64 %indvars.iv33, %36" (2.053173e-08%)
Noelle:     Loop "  %50 = icmp slt i64 %indvars.iv31, %48" (2.053173e-08%)
Noelle:     Loop "  %62 = icmp slt i64 %indvars.iv29, %60" (2.053173e-08%)
Noelle:     Loop "  %74 = icmp slt i64 %indvars.iv27, %72" (2.053173e-08%)
Noelle:     Loop "  %86 = icmp slt i64 %indvars.iv25, %84" (2.053173e-08%)
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv23, %96" (2.053173e-08%)
Noelle:     Loop "  %108 = fcmp olt double %.01, 1.000000e+03" (5.311406e+01%)
Noelle:     Loop "  %109 = fcmp ogt double %.02, 0.000000e+00" (5.311404e+01%)
Noelle:     Loop "  %118 = fcmp olt double %.03, 1.000000e+03" (5.311294e+01%)
Noelle:     Loop "  %143 = fcmp ogt double %.04, -5.000000e+00" (4.965366e+01%)
Noelle:     Loop "  %exitcond7 = icmp eq i64 %indvars.iv21, %196" (1.104661e+01%)
Noelle:     Loop "  %214 = icmp ult i64 %indvars.iv, 100000" (5.919982e-02%)
Noelle:     Loop "  %exitcond = icmp eq i64 %.0, 1072513385" (1.937057e-02%)
Noelle:     Loop "  %230 = fcmp ugt double %.05, 3.600000e+02" (6.123826e-01%)
Noelle:     Loop "  %242 = tail call double @atan(double 1.000000e+00) #9" (2.365529e-04%)
Noelle:  Function "SolveCubic"
Noelle:  Function "usqrt"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 32" (7.700826e-02%)
Noelle:  Function "deg2rad"
Noelle:  Function "rad2deg"
Noelle:  Function "main"
Noelle:     Loop "  %14 = icmp slt i64 %indvars.iv37, %12" (5.155930e-08%)
Noelle:     Loop "  %26 = icmp slt i64 %indvars.iv35, %24" (2.062372e-08%)
Noelle:     Loop "  %38 = icmp slt i64 %indvars.iv33, %36" (2.062372e-08%)
Noelle:     Loop "  %50 = icmp slt i64 %indvars.iv31, %48" (2.062372e-08%)
Noelle:     Loop "  %62 = icmp slt i64 %indvars.iv29, %60" (2.062372e-08%)
Noelle:     Loop "  %74 = icmp slt i64 %indvars.iv27, %72" (2.062372e-08%)
Noelle:     Loop "  %86 = icmp slt i64 %indvars.iv25, %84" (2.062372e-08%)
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv23, %96" (2.062372e-08%)
Noelle:     Loop "  %108 = fcmp olt double %.01, 1.000000e+03" (5.290399e+01%)
Noelle:     Loop "  %109 = fcmp ogt double %.02, 0.000000e+00" (5.290397e+01%)
Noelle:     Loop "  %122 = fcmp olt double %.03, 1.000000e+03" (5.290259e+01%)
Noelle:     Loop "  %143 = fcmp ogt double %.04, -5.000000e+00" (4.987613e+01%)
Noelle:     Loop "  %exitcond7 = icmp eq i64 %indvars.iv21, %196" (1.109610e+01%)
Noelle:     Loop "  %214 = icmp ult i64 %indvars.iv, 100000" (5.946506e-02%)
Noelle:     Loop "  %exitcond = icmp eq i64 %.0, 1072513385" (1.945736e-02%)
Noelle:     Loop "  %230 = fcmp ugt double %.05, 3.600000e+02" (6.151264e-01%)
Noelle:     Loop "  %242 = tail call double @atan(double 1.000000e+00) #9" (2.376127e-04%)
Noelle:  Function "SolveCubic"
Noelle:  Function "usqrt"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 32" (7.735330e-02%)
Noelle:  Function "deg2rad"
Noelle:  Function "rad2deg"
NOELLE: FixedPoint:       There are 0 different instructions and -4 different loop instructions
NOELLE: FixedPoint:       Normalize the code
noelle-norm /tmp/tmp.4UAjlEdITx -o /tmp/tmp.4UAjlEdITx
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.4UAjlEdITx -o /tmp/tmp.4UAjlEdITx
NOELLE: FixedPoint:     Invocation 3
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.kem6a0IYPH -o /tmp/tmp.4UAjlEdITx
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.kem6a0IYPH -o /tmp/tmp.4UAjlEdITx
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.kem6a0IYPH -o /tmp/tmp.4UAjlEdITx
EnablersManager: Start
Noelle: Filter out cold code
Noelle:  Function "main"
Noelle:     Loop "  %14 = icmp slt i64 %indvars.iv37, %12" (5.155930e-08%)
Noelle:  Disable loop "0" as cold code
Noelle:     Loop "  %26 = icmp slt i64 %indvars.iv35, %24" (2.062372e-08%)
Noelle:  Disable loop "1" as cold code
Noelle:     Loop "  %38 = icmp slt i64 %indvars.iv33, %36" (2.062372e-08%)
Noelle:  Disable loop "2" as cold code
Noelle:     Loop "  %50 = icmp slt i64 %indvars.iv31, %48" (2.062372e-08%)
Noelle:  Disable loop "3" as cold code
Noelle:     Loop "  %62 = icmp slt i64 %indvars.iv29, %60" (2.062372e-08%)
Noelle:  Disable loop "4" as cold code
Noelle:     Loop "  %74 = icmp slt i64 %indvars.iv27, %72" (2.062372e-08%)
Noelle:  Disable loop "5" as cold code
Noelle:     Loop "  %86 = icmp slt i64 %indvars.iv25, %84" (2.062372e-08%)
Noelle:  Disable loop "6" as cold code
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv23, %96" (2.062372e-08%)
Noelle:  Disable loop "7" as cold code
Noelle:     Loop "  %108 = fcmp olt double %.01, 1.000000e+03" (5.290399e+01%)
Noelle:     Loop "  %109 = fcmp ogt double %.02, 0.000000e+00" (5.290397e+01%)
Noelle:     Loop "  %122 = fcmp olt double %.03, 1.000000e+03" (5.290259e+01%)
Noelle:     Loop "  %143 = fcmp ogt double %.04, -5.000000e+00" (4.987613e+01%)
Noelle:     Loop "  %exitcond7 = icmp eq i64 %indvars.iv21, %196" (1.109610e+01%)
Noelle:     Loop "  %214 = icmp ult i64 %indvars.iv, 100000" (5.946506e-02%)
Noelle:  Disable loop "13" as cold code
Noelle:     Loop "  %exitcond = icmp eq i64 %.0, 1072513385" (1.945736e-02%)
Noelle:  Disable loop "14" as cold code
Noelle:     Loop "  %230 = fcmp ugt double %.05, 3.600000e+02" (6.151264e-01%)
Noelle:     Loop "  %242 = tail call double @atan(double 1.000000e+00) #9" (2.376127e-04%)
Noelle:  Disable loop "16" as cold code
Noelle:  Function "SolveCubic"
Noelle:  Function "usqrt"
Noelle:  Disable "usqrt" as cold function
EnablersManager:   Try to improve all 6 loops, one at a time
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %exitcond7 = icmp eq i64 %indvars.iv21, %196
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond7 = icmp eq i64 %indvars.iv21, %196"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond7, label %202, label %198, !prof !44
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %143 = fcmp ogt double %.04, -5.000000e+00
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %143 = fcmp ogt double %.04, -5.000000e+00"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %143, label %144, label %204, !prof !41
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %122 = fcmp olt double %.03, 1.000000e+03
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %122 = fcmp olt double %.03, 1.000000e+03"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %122, label %.preheader.preheader, label %206, !prof !40
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %109 = fcmp ogt double %.02, 0.000000e+00
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %109 = fcmp ogt double %.02, 0.000000e+00"
LICM:     Invariant = "  %118 = getelementptr [11 x i8], [11 x i8]* @.str.1, i64 0, i64 0
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %119 = getelementptr [4 x i8], [4 x i8]* @.str.2, i64 0, i64 0
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %120 = tail call double @atan(double 1.000000e+00) #9
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %121 = tail call double @atan(double 1.000000e+00) #9
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has been modified
LICM: Exit
EnablersManager:       Loop invariants have been extracted
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %108 = fcmp olt double %.01, 1.000000e+03
EnablersManager:     The current loop belongs to the function main , which has already been modified.
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %230 = fcmp ugt double %.05, 3.600000e+02
EnablersManager:     The current loop belongs to the function main , which has already been modified.
EnablersManager: Exit
Noelle:  Function "main"
Noelle:     Loop "  %14 = icmp slt i64 %indvars.iv37, %12" (5.155930e-08%)
Noelle:     Loop "  %26 = icmp slt i64 %indvars.iv35, %24" (2.062372e-08%)
Noelle:     Loop "  %38 = icmp slt i64 %indvars.iv33, %36" (2.062372e-08%)
Noelle:     Loop "  %50 = icmp slt i64 %indvars.iv31, %48" (2.062372e-08%)
Noelle:     Loop "  %62 = icmp slt i64 %indvars.iv29, %60" (2.062372e-08%)
Noelle:     Loop "  %74 = icmp slt i64 %indvars.iv27, %72" (2.062372e-08%)
Noelle:     Loop "  %86 = icmp slt i64 %indvars.iv25, %84" (2.062372e-08%)
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv23, %96" (2.062372e-08%)
Noelle:     Loop "  %108 = fcmp olt double %.01, 1.000000e+03" (5.290399e+01%)
Noelle:     Loop "  %109 = fcmp ogt double %.02, 0.000000e+00" (5.290397e+01%)
Noelle:     Loop "  %122 = fcmp olt double %.03, 1.000000e+03" (5.290259e+01%)
Noelle:     Loop "  %143 = fcmp ogt double %.04, -5.000000e+00" (4.987613e+01%)
Noelle:     Loop "  %exitcond7 = icmp eq i64 %indvars.iv21, %196" (1.109610e+01%)
Noelle:     Loop "  %214 = icmp ult i64 %indvars.iv, 100000" (5.946506e-02%)
Noelle:     Loop "  %exitcond = icmp eq i64 %.0, 1072513385" (1.945736e-02%)
Noelle:     Loop "  %230 = fcmp ugt double %.05, 3.600000e+02" (6.151264e-01%)
Noelle:     Loop "  %242 = tail call double @atan(double 1.000000e+00) #9" (2.376127e-04%)
Noelle:  Function "SolveCubic"
Noelle:  Function "usqrt"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 32" (7.735330e-02%)
Noelle:  Function "deg2rad"
Noelle:  Function "rad2deg"
Noelle:  Function "main"
Noelle:     Loop "  %14 = icmp slt i64 %indvars.iv37, %12" (5.155943e-08%)
Noelle:     Loop "  %26 = icmp slt i64 %indvars.iv35, %24" (2.062377e-08%)
Noelle:     Loop "  %38 = icmp slt i64 %indvars.iv33, %36" (2.062377e-08%)
Noelle:     Loop "  %50 = icmp slt i64 %indvars.iv31, %48" (2.062377e-08%)
Noelle:     Loop "  %62 = icmp slt i64 %indvars.iv29, %60" (2.062377e-08%)
Noelle:     Loop "  %74 = icmp slt i64 %indvars.iv27, %72" (2.062377e-08%)
Noelle:     Loop "  %86 = icmp slt i64 %indvars.iv25, %84" (2.062377e-08%)
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv23, %96" (2.062377e-08%)
Noelle:     Loop "  %108 = fcmp olt double %.01, 1.000000e+03" (5.290386e+01%)
Noelle:     Loop "  %113 = fcmp ogt double %.02, 0.000000e+00" (5.290384e+01%)
Noelle:     Loop "  %122 = fcmp olt double %.03, 1.000000e+03" (5.290273e+01%)
Noelle:     Loop "  %143 = fcmp ogt double %.04, -5.000000e+00" (4.987627e+01%)
Noelle:     Loop "  %exitcond7 = icmp eq i64 %indvars.iv21, %196" (1.109613e+01%)
Noelle:     Loop "  %214 = icmp ult i64 %indvars.iv, 100000" (5.946522e-02%)
Noelle:     Loop "  %exitcond = icmp eq i64 %.0, 1072513385" (1.945741e-02%)
Noelle:     Loop "  %230 = fcmp ugt double %.05, 3.600000e+02" (6.151280e-01%)
Noelle:     Loop "  %242 = tail call double @atan(double 1.000000e+00) #9" (2.376134e-04%)
Noelle:  Function "SolveCubic"
Noelle:  Function "usqrt"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 32" (7.735351e-02%)
Noelle:  Function "deg2rad"
Noelle:  Function "rad2deg"
NOELLE: FixedPoint:       There are 0 different instructions and -4 different loop instructions
NOELLE: FixedPoint:       Normalize the code
noelle-norm /tmp/tmp.4UAjlEdITx -o /tmp/tmp.4UAjlEdITx
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.4UAjlEdITx -o /tmp/tmp.4UAjlEdITx
NOELLE: FixedPoint:     Invocation 4
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.kem6a0IYPH -o /tmp/tmp.4UAjlEdITx
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.kem6a0IYPH -o /tmp/tmp.4UAjlEdITx
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.kem6a0IYPH -o /tmp/tmp.4UAjlEdITx
EnablersManager: Start
Noelle: Filter out cold code
Noelle:  Function "main"
Noelle:     Loop "  %14 = icmp slt i64 %indvars.iv37, %12" (5.155943e-08%)
Noelle:  Disable loop "0" as cold code
Noelle:     Loop "  %26 = icmp slt i64 %indvars.iv35, %24" (2.062377e-08%)
Noelle:  Disable loop "1" as cold code
Noelle:     Loop "  %38 = icmp slt i64 %indvars.iv33, %36" (2.062377e-08%)
Noelle:  Disable loop "2" as cold code
Noelle:     Loop "  %50 = icmp slt i64 %indvars.iv31, %48" (2.062377e-08%)
Noelle:  Disable loop "3" as cold code
Noelle:     Loop "  %62 = icmp slt i64 %indvars.iv29, %60" (2.062377e-08%)
Noelle:  Disable loop "4" as cold code
Noelle:     Loop "  %74 = icmp slt i64 %indvars.iv27, %72" (2.062377e-08%)
Noelle:  Disable loop "5" as cold code
Noelle:     Loop "  %86 = icmp slt i64 %indvars.iv25, %84" (2.062377e-08%)
Noelle:  Disable loop "6" as cold code
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv23, %96" (2.062377e-08%)
Noelle:  Disable loop "7" as cold code
Noelle:     Loop "  %108 = fcmp olt double %.01, 1.000000e+03" (5.290386e+01%)
Noelle:     Loop "  %113 = fcmp ogt double %.02, 0.000000e+00" (5.290384e+01%)
Noelle:     Loop "  %122 = fcmp olt double %.03, 1.000000e+03" (5.290273e+01%)
Noelle:     Loop "  %143 = fcmp ogt double %.04, -5.000000e+00" (4.987627e+01%)
Noelle:     Loop "  %exitcond7 = icmp eq i64 %indvars.iv21, %196" (1.109613e+01%)
Noelle:     Loop "  %214 = icmp ult i64 %indvars.iv, 100000" (5.946522e-02%)
Noelle:  Disable loop "13" as cold code
Noelle:     Loop "  %exitcond = icmp eq i64 %.0, 1072513385" (1.945741e-02%)
Noelle:  Disable loop "14" as cold code
Noelle:     Loop "  %230 = fcmp ugt double %.05, 3.600000e+02" (6.151280e-01%)
Noelle:     Loop "  %242 = tail call double @atan(double 1.000000e+00) #9" (2.376134e-04%)
Noelle:  Disable loop "16" as cold code
Noelle:  Function "SolveCubic"
Noelle:  Function "usqrt"
Noelle:  Disable "usqrt" as cold function
EnablersManager:   Try to improve all 6 loops, one at a time
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %exitcond7 = icmp eq i64 %indvars.iv21, %196
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond7 = icmp eq i64 %indvars.iv21, %196"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond7, label %202, label %198, !prof !44
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %143 = fcmp ogt double %.04, -5.000000e+00
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %143 = fcmp ogt double %.04, -5.000000e+00"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %143, label %144, label %204, !prof !41
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %122 = fcmp olt double %.03, 1.000000e+03
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %122 = fcmp olt double %.03, 1.000000e+03"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %122, label %.preheader.preheader, label %206, !prof !40
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %113 = fcmp ogt double %.02, 0.000000e+00
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %113 = fcmp ogt double %.02, 0.000000e+00"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %113, label %.preheader19.preheader, label %208, !prof !39
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %108 = fcmp olt double %.01, 1.000000e+03
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %108 = fcmp olt double %.01, 1.000000e+03"
LICM:     Invariant = "  %109 = getelementptr [11 x i8], [11 x i8]* @.str.1, i64 0, i64 0
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %110 = getelementptr [4 x i8], [4 x i8]* @.str.2, i64 0, i64 0
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %111 = tail call double @atan(double 1.000000e+00) #9
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %112 = tail call double @atan(double 1.000000e+00) #9
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has been modified
LICM: Exit
EnablersManager:       Loop invariants have been extracted
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %230 = fcmp ugt double %.05, 3.600000e+02
EnablersManager:     The current loop belongs to the function main , which has already been modified.
EnablersManager: Exit
Noelle:  Function "main"
Noelle:     Loop "  %14 = icmp slt i64 %indvars.iv37, %12" (5.155943e-08%)
Noelle:     Loop "  %26 = icmp slt i64 %indvars.iv35, %24" (2.062377e-08%)
Noelle:     Loop "  %38 = icmp slt i64 %indvars.iv33, %36" (2.062377e-08%)
Noelle:     Loop "  %50 = icmp slt i64 %indvars.iv31, %48" (2.062377e-08%)
Noelle:     Loop "  %62 = icmp slt i64 %indvars.iv29, %60" (2.062377e-08%)
Noelle:     Loop "  %74 = icmp slt i64 %indvars.iv27, %72" (2.062377e-08%)
Noelle:     Loop "  %86 = icmp slt i64 %indvars.iv25, %84" (2.062377e-08%)
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv23, %96" (2.062377e-08%)
Noelle:     Loop "  %108 = fcmp olt double %.01, 1.000000e+03" (5.290386e+01%)
Noelle:     Loop "  %113 = fcmp ogt double %.02, 0.000000e+00" (5.290384e+01%)
Noelle:     Loop "  %122 = fcmp olt double %.03, 1.000000e+03" (5.290273e+01%)
Noelle:     Loop "  %143 = fcmp ogt double %.04, -5.000000e+00" (4.987627e+01%)
Noelle:     Loop "  %exitcond7 = icmp eq i64 %indvars.iv21, %196" (1.109613e+01%)
Noelle:     Loop "  %214 = icmp ult i64 %indvars.iv, 100000" (5.946522e-02%)
Noelle:     Loop "  %exitcond = icmp eq i64 %.0, 1072513385" (1.945741e-02%)
Noelle:     Loop "  %230 = fcmp ugt double %.05, 3.600000e+02" (6.151280e-01%)
Noelle:     Loop "  %242 = tail call double @atan(double 1.000000e+00) #9" (2.376134e-04%)
Noelle:  Function "SolveCubic"
Noelle:  Function "usqrt"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 32" (7.735351e-02%)
Noelle:  Function "deg2rad"
Noelle:  Function "rad2deg"
Noelle:  Function "main"
Noelle:     Loop "  %14 = icmp slt i64 %indvars.iv37, %12" (5.155944e-08%)
Noelle:     Loop "  %26 = icmp slt i64 %indvars.iv35, %24" (2.062378e-08%)
Noelle:     Loop "  %38 = icmp slt i64 %indvars.iv33, %36" (2.062378e-08%)
Noelle:     Loop "  %50 = icmp slt i64 %indvars.iv31, %48" (2.062378e-08%)
Noelle:     Loop "  %62 = icmp slt i64 %indvars.iv29, %60" (2.062378e-08%)
Noelle:     Loop "  %74 = icmp slt i64 %indvars.iv27, %72" (2.062378e-08%)
Noelle:     Loop "  %86 = icmp slt i64 %indvars.iv25, %84" (2.062378e-08%)
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv23, %96" (2.062378e-08%)
Noelle:     Loop "  %112 = fcmp olt double %.01, 1.000000e+03" (5.290386e+01%)
Noelle:     Loop "  %113 = fcmp ogt double %.02, 0.000000e+00" (5.290384e+01%)
Noelle:     Loop "  %122 = fcmp olt double %.03, 1.000000e+03" (5.290274e+01%)
Noelle:     Loop "  %143 = fcmp ogt double %.04, -5.000000e+00" (4.987627e+01%)
Noelle:     Loop "  %exitcond7 = icmp eq i64 %indvars.iv21, %196" (1.109613e+01%)
Noelle:     Loop "  %214 = icmp ult i64 %indvars.iv, 100000" (5.946523e-02%)
Noelle:     Loop "  %exitcond = icmp eq i64 %.0, 1072513385" (1.945741e-02%)
Noelle:     Loop "  %230 = fcmp ugt double %.05, 3.600000e+02" (6.151280e-01%)
Noelle:     Loop "  %242 = tail call double @atan(double 1.000000e+00) #9" (2.376134e-04%)
Noelle:  Function "SolveCubic"
Noelle:  Function "usqrt"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 32" (7.735351e-02%)
Noelle:  Function "deg2rad"
Noelle:  Function "rad2deg"
NOELLE: FixedPoint:       There are 0 different instructions and -4 different loop instructions
NOELLE: FixedPoint:       Normalize the code
noelle-norm /tmp/tmp.4UAjlEdITx -o /tmp/tmp.4UAjlEdITx
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.4UAjlEdITx -o /tmp/tmp.4UAjlEdITx
NOELLE: FixedPoint:     Invocation 5
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.kem6a0IYPH -o /tmp/tmp.4UAjlEdITx
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.kem6a0IYPH -o /tmp/tmp.4UAjlEdITx
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.kem6a0IYPH -o /tmp/tmp.4UAjlEdITx
EnablersManager: Start
Noelle: Filter out cold code
Noelle:  Function "main"
Noelle:     Loop "  %14 = icmp slt i64 %indvars.iv37, %12" (5.155944e-08%)
Noelle:  Disable loop "0" as cold code
Noelle:     Loop "  %26 = icmp slt i64 %indvars.iv35, %24" (2.062378e-08%)
Noelle:  Disable loop "1" as cold code
Noelle:     Loop "  %38 = icmp slt i64 %indvars.iv33, %36" (2.062378e-08%)
Noelle:  Disable loop "2" as cold code
Noelle:     Loop "  %50 = icmp slt i64 %indvars.iv31, %48" (2.062378e-08%)
Noelle:  Disable loop "3" as cold code
Noelle:     Loop "  %62 = icmp slt i64 %indvars.iv29, %60" (2.062378e-08%)
Noelle:  Disable loop "4" as cold code
Noelle:     Loop "  %74 = icmp slt i64 %indvars.iv27, %72" (2.062378e-08%)
Noelle:  Disable loop "5" as cold code
Noelle:     Loop "  %86 = icmp slt i64 %indvars.iv25, %84" (2.062378e-08%)
Noelle:  Disable loop "6" as cold code
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv23, %96" (2.062378e-08%)
Noelle:  Disable loop "7" as cold code
Noelle:     Loop "  %112 = fcmp olt double %.01, 1.000000e+03" (5.290386e+01%)
Noelle:     Loop "  %113 = fcmp ogt double %.02, 0.000000e+00" (5.290384e+01%)
Noelle:     Loop "  %122 = fcmp olt double %.03, 1.000000e+03" (5.290274e+01%)
Noelle:     Loop "  %143 = fcmp ogt double %.04, -5.000000e+00" (4.987627e+01%)
Noelle:     Loop "  %exitcond7 = icmp eq i64 %indvars.iv21, %196" (1.109613e+01%)
Noelle:     Loop "  %214 = icmp ult i64 %indvars.iv, 100000" (5.946523e-02%)
Noelle:  Disable loop "13" as cold code
Noelle:     Loop "  %exitcond = icmp eq i64 %.0, 1072513385" (1.945741e-02%)
Noelle:  Disable loop "14" as cold code
Noelle:     Loop "  %230 = fcmp ugt double %.05, 3.600000e+02" (6.151280e-01%)
Noelle:     Loop "  %242 = tail call double @atan(double 1.000000e+00) #9" (2.376134e-04%)
Noelle:  Disable loop "16" as cold code
Noelle:  Function "SolveCubic"
Noelle:  Function "usqrt"
Noelle:  Disable "usqrt" as cold function
EnablersManager:   Try to improve all 6 loops, one at a time
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %exitcond7 = icmp eq i64 %indvars.iv21, %196
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond7 = icmp eq i64 %indvars.iv21, %196"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond7, label %202, label %198, !prof !44
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %143 = fcmp ogt double %.04, -5.000000e+00
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %143 = fcmp ogt double %.04, -5.000000e+00"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %143, label %144, label %204, !prof !41
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %122 = fcmp olt double %.03, 1.000000e+03
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %122 = fcmp olt double %.03, 1.000000e+03"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %122, label %.preheader.preheader, label %206, !prof !40
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %113 = fcmp ogt double %.02, 0.000000e+00
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %113 = fcmp ogt double %.02, 0.000000e+00"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %113, label %.preheader19.preheader, label %208, !prof !39
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %112 = fcmp olt double %.01, 1.000000e+03
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %112 = fcmp olt double %.01, 1.000000e+03"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %112, label %.preheader20.preheader, label %210, !prof !38
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %230 = fcmp ugt double %.05, 3.600000e+02
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %230 = fcmp ugt double %.05, 3.600000e+02"
LICM:     Invariant = "  %232 = tail call double @atan(double 1.000000e+00) #9
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %235 = getelementptr [31 x i8], [31 x i8]* @.str.8, i64 0, i64 0
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has been modified
LICM: Exit
EnablersManager:       Loop invariants have been extracted
EnablersManager: Exit
Noelle:  Function "main"
Noelle:     Loop "  %14 = icmp slt i64 %indvars.iv37, %12" (5.155944e-08%)
Noelle:     Loop "  %26 = icmp slt i64 %indvars.iv35, %24" (2.062378e-08%)
Noelle:     Loop "  %38 = icmp slt i64 %indvars.iv33, %36" (2.062378e-08%)
Noelle:     Loop "  %50 = icmp slt i64 %indvars.iv31, %48" (2.062378e-08%)
Noelle:     Loop "  %62 = icmp slt i64 %indvars.iv29, %60" (2.062378e-08%)
Noelle:     Loop "  %74 = icmp slt i64 %indvars.iv27, %72" (2.062378e-08%)
Noelle:     Loop "  %86 = icmp slt i64 %indvars.iv25, %84" (2.062378e-08%)
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv23, %96" (2.062378e-08%)
Noelle:     Loop "  %112 = fcmp olt double %.01, 1.000000e+03" (5.290386e+01%)
Noelle:     Loop "  %113 = fcmp ogt double %.02, 0.000000e+00" (5.290384e+01%)
Noelle:     Loop "  %122 = fcmp olt double %.03, 1.000000e+03" (5.290274e+01%)
Noelle:     Loop "  %143 = fcmp ogt double %.04, -5.000000e+00" (4.987627e+01%)
Noelle:     Loop "  %exitcond7 = icmp eq i64 %indvars.iv21, %196" (1.109613e+01%)
Noelle:     Loop "  %214 = icmp ult i64 %indvars.iv, 100000" (5.946523e-02%)
Noelle:     Loop "  %exitcond = icmp eq i64 %.0, 1072513385" (1.945741e-02%)
Noelle:     Loop "  %230 = fcmp ugt double %.05, 3.600000e+02" (6.151280e-01%)
Noelle:     Loop "  %242 = tail call double @atan(double 1.000000e+00) #9" (2.376134e-04%)
Noelle:  Function "SolveCubic"
Noelle:  Function "usqrt"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 32" (7.735351e-02%)
Noelle:  Function "deg2rad"
Noelle:  Function "rad2deg"
Noelle:  Function "main"
Noelle:     Loop "  %14 = icmp slt i64 %indvars.iv37, %12" (5.162295e-08%)
Noelle:     Loop "  %26 = icmp slt i64 %indvars.iv35, %24" (2.064918e-08%)
Noelle:     Loop "  %38 = icmp slt i64 %indvars.iv33, %36" (2.064918e-08%)
Noelle:     Loop "  %50 = icmp slt i64 %indvars.iv31, %48" (2.064918e-08%)
Noelle:     Loop "  %62 = icmp slt i64 %indvars.iv29, %60" (2.064918e-08%)
Noelle:     Loop "  %74 = icmp slt i64 %indvars.iv27, %72" (2.064918e-08%)
Noelle:     Loop "  %86 = icmp slt i64 %indvars.iv25, %84" (2.064918e-08%)
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv23, %96" (2.064918e-08%)
Noelle:     Loop "  %112 = fcmp olt double %.01, 1.000000e+03" (5.296902e+01%)
Noelle:     Loop "  %113 = fcmp ogt double %.02, 0.000000e+00" (5.296901e+01%)
Noelle:     Loop "  %122 = fcmp olt double %.03, 1.000000e+03" (5.296790e+01%)
Noelle:     Loop "  %143 = fcmp ogt double %.04, -5.000000e+00" (4.993771e+01%)
Noelle:     Loop "  %exitcond7 = icmp eq i64 %indvars.iv21, %196" (1.110980e+01%)
Noelle:     Loop "  %214 = icmp ult i64 %indvars.iv, 100000" (5.953847e-02%)
Noelle:     Loop "  %exitcond = icmp eq i64 %.0, 1072513385" (1.948138e-02%)
Noelle:     Loop "  %232 = fcmp ugt double %.05, 3.600000e+02" (4.927086e-01%)
Noelle:     Loop "  %242 = tail call double @atan(double 1.000000e+00) #9" (2.379061e-04%)
Noelle:  Function "SolveCubic"
Noelle:  Function "usqrt"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 32" (7.744879e-02%)
Noelle:  Function "deg2rad"
Noelle:  Function "rad2deg"
NOELLE: FixedPoint:       There are 0 different instructions and -2 different loop instructions
NOELLE: FixedPoint:       Normalize the code
noelle-norm /tmp/tmp.4UAjlEdITx -o /tmp/tmp.4UAjlEdITx
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.4UAjlEdITx -o /tmp/tmp.4UAjlEdITx
NOELLE: FixedPoint:     Invocation 6
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.kem6a0IYPH -o /tmp/tmp.4UAjlEdITx
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.kem6a0IYPH -o /tmp/tmp.4UAjlEdITx
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.kem6a0IYPH -o /tmp/tmp.4UAjlEdITx
EnablersManager: Start
Noelle: Filter out cold code
Noelle:  Function "main"
Noelle:     Loop "  %14 = icmp slt i64 %indvars.iv37, %12" (5.162295e-08%)
Noelle:  Disable loop "0" as cold code
Noelle:     Loop "  %26 = icmp slt i64 %indvars.iv35, %24" (2.064918e-08%)
Noelle:  Disable loop "1" as cold code
Noelle:     Loop "  %38 = icmp slt i64 %indvars.iv33, %36" (2.064918e-08%)
Noelle:  Disable loop "2" as cold code
Noelle:     Loop "  %50 = icmp slt i64 %indvars.iv31, %48" (2.064918e-08%)
Noelle:  Disable loop "3" as cold code
Noelle:     Loop "  %62 = icmp slt i64 %indvars.iv29, %60" (2.064918e-08%)
Noelle:  Disable loop "4" as cold code
Noelle:     Loop "  %74 = icmp slt i64 %indvars.iv27, %72" (2.064918e-08%)
Noelle:  Disable loop "5" as cold code
Noelle:     Loop "  %86 = icmp slt i64 %indvars.iv25, %84" (2.064918e-08%)
Noelle:  Disable loop "6" as cold code
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv23, %96" (2.064918e-08%)
Noelle:  Disable loop "7" as cold code
Noelle:     Loop "  %112 = fcmp olt double %.01, 1.000000e+03" (5.296902e+01%)
Noelle:     Loop "  %113 = fcmp ogt double %.02, 0.000000e+00" (5.296901e+01%)
Noelle:     Loop "  %122 = fcmp olt double %.03, 1.000000e+03" (5.296790e+01%)
Noelle:     Loop "  %143 = fcmp ogt double %.04, -5.000000e+00" (4.993771e+01%)
Noelle:     Loop "  %exitcond7 = icmp eq i64 %indvars.iv21, %196" (1.110980e+01%)
Noelle:     Loop "  %214 = icmp ult i64 %indvars.iv, 100000" (5.953847e-02%)
Noelle:  Disable loop "13" as cold code
Noelle:     Loop "  %exitcond = icmp eq i64 %.0, 1072513385" (1.948138e-02%)
Noelle:  Disable loop "14" as cold code
Noelle:     Loop "  %232 = fcmp ugt double %.05, 3.600000e+02" (4.927086e-01%)
Noelle:     Loop "  %242 = tail call double @atan(double 1.000000e+00) #9" (2.379061e-04%)
Noelle:  Disable loop "16" as cold code
Noelle:  Function "SolveCubic"
Noelle:  Function "usqrt"
Noelle:  Disable "usqrt" as cold function
EnablersManager:   Try to improve all 6 loops, one at a time
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %exitcond7 = icmp eq i64 %indvars.iv21, %196
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond7 = icmp eq i64 %indvars.iv21, %196"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond7, label %202, label %198, !prof !44
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %143 = fcmp ogt double %.04, -5.000000e+00
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %143 = fcmp ogt double %.04, -5.000000e+00"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %143, label %144, label %204, !prof !41
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %122 = fcmp olt double %.03, 1.000000e+03
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %122 = fcmp olt double %.03, 1.000000e+03"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %122, label %.preheader.preheader, label %206, !prof !40
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %113 = fcmp ogt double %.02, 0.000000e+00
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %113 = fcmp ogt double %.02, 0.000000e+00"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %113, label %.preheader19.preheader, label %208, !prof !39
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %112 = fcmp olt double %.01, 1.000000e+03
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %112 = fcmp olt double %.01, 1.000000e+03"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %112, label %.preheader20.preheader, label %210, !prof !38
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %232 = fcmp ugt double %.05, 3.600000e+02
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %232 = fcmp ugt double %.05, 3.600000e+02"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %232, label %238, label %233, !prof !49
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager: Exit
Noelle:  Function "main"
Noelle:     Loop "  %14 = icmp slt i64 %indvars.iv37, %12" (5.162295e-08%)
Noelle:     Loop "  %26 = icmp slt i64 %indvars.iv35, %24" (2.064918e-08%)
Noelle:     Loop "  %38 = icmp slt i64 %indvars.iv33, %36" (2.064918e-08%)
Noelle:     Loop "  %50 = icmp slt i64 %indvars.iv31, %48" (2.064918e-08%)
Noelle:     Loop "  %62 = icmp slt i64 %indvars.iv29, %60" (2.064918e-08%)
Noelle:     Loop "  %74 = icmp slt i64 %indvars.iv27, %72" (2.064918e-08%)
Noelle:     Loop "  %86 = icmp slt i64 %indvars.iv25, %84" (2.064918e-08%)
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv23, %96" (2.064918e-08%)
Noelle:     Loop "  %112 = fcmp olt double %.01, 1.000000e+03" (5.296902e+01%)
Noelle:     Loop "  %113 = fcmp ogt double %.02, 0.000000e+00" (5.296901e+01%)
Noelle:     Loop "  %122 = fcmp olt double %.03, 1.000000e+03" (5.296790e+01%)
Noelle:     Loop "  %143 = fcmp ogt double %.04, -5.000000e+00" (4.993771e+01%)
Noelle:     Loop "  %exitcond7 = icmp eq i64 %indvars.iv21, %196" (1.110980e+01%)
Noelle:     Loop "  %214 = icmp ult i64 %indvars.iv, 100000" (5.953847e-02%)
Noelle:     Loop "  %exitcond = icmp eq i64 %.0, 1072513385" (1.948138e-02%)
Noelle:     Loop "  %232 = fcmp ugt double %.05, 3.600000e+02" (4.927086e-01%)
Noelle:     Loop "  %242 = tail call double @atan(double 1.000000e+00) #9" (2.379061e-04%)
Noelle:  Function "SolveCubic"
Noelle:  Function "usqrt"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 32" (7.744879e-02%)
Noelle:  Function "deg2rad"
Noelle:  Function "rad2deg"
Noelle:  Function "main"
Noelle:     Loop "  %14 = icmp slt i64 %indvars.iv37, %12" (5.162295e-08%)
Noelle:     Loop "  %26 = icmp slt i64 %indvars.iv35, %24" (2.064918e-08%)
Noelle:     Loop "  %38 = icmp slt i64 %indvars.iv33, %36" (2.064918e-08%)
Noelle:     Loop "  %50 = icmp slt i64 %indvars.iv31, %48" (2.064918e-08%)
Noelle:     Loop "  %62 = icmp slt i64 %indvars.iv29, %60" (2.064918e-08%)
Noelle:     Loop "  %74 = icmp slt i64 %indvars.iv27, %72" (2.064918e-08%)
Noelle:     Loop "  %86 = icmp slt i64 %indvars.iv25, %84" (2.064918e-08%)
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv23, %96" (2.064918e-08%)
Noelle:     Loop "  %112 = fcmp olt double %.01, 1.000000e+03" (5.296902e+01%)
Noelle:     Loop "  %113 = fcmp ogt double %.02, 0.000000e+00" (5.296901e+01%)
Noelle:     Loop "  %122 = fcmp olt double %.03, 1.000000e+03" (5.296790e+01%)
Noelle:     Loop "  %143 = fcmp ogt double %.04, -5.000000e+00" (4.993771e+01%)
Noelle:     Loop "  %exitcond7 = icmp eq i64 %indvars.iv21, %196" (1.110980e+01%)
Noelle:     Loop "  %214 = icmp ult i64 %indvars.iv, 100000" (5.953847e-02%)
Noelle:     Loop "  %exitcond = icmp eq i64 %.0, 1072513385" (1.948138e-02%)
Noelle:     Loop "  %232 = fcmp ugt double %.05, 3.600000e+02" (4.927086e-01%)
Noelle:     Loop "  %242 = tail call double @atan(double 1.000000e+00) #9" (2.379061e-04%)
Noelle:  Function "SolveCubic"
Noelle:  Function "usqrt"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 32" (7.744879e-02%)
Noelle:  Function "deg2rad"
Noelle:  Function "rad2deg"
NOELLE: FixedPoint: Exit
NOELLE: Enablers: Exit
noelle-simplification baseline_pre.bc -o baseline_pre.bc
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -tbaa -early-cse-memssa -licm -simplifycfg -simplifycfg-sink-common=false -instcombine -tailcallelim -loop-simplify -lcssa -licm -loop-unswitch -globalopt -instcombine -ipsccp -dce -gvn -dse -adce -loop-simplify -lcssa -indvars -loop-deletion -instcombine -indvars -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa --functionattrs --rpo-functionattrs baseline_pre.bc -o baseline_pre.bc
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CleanMetadata.so -CleanMetadata -clean-loop-metadata=true -clean-prof-metadata=true -clean-pdg-metadata=true baseline_pre.bc -o baseline_pre.bc
noelle/core/Clean Loop Metadata
noelle/core/Clean PDG Metadata
noelle/core/Clean profiler metadata
opt --strip-named-metadata baseline_pre.bc -o baseline_pre.bc
/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/basicmath /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/basicmath
Running: ./baseline_pre_prof > output_large.txt in /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/MiBench/automotive/basicmath
--------------------------------------------------------------------------------------
/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/basicmath
DONE
opt -pgo-test-profile-file=/tmp/tmp.gzSIG8V1xC -block-freq -pgo-instr-use baseline_pre.bc -o baseline_with_metadata.bc
noelle-load -PDGAnalysis -noelle-pdg-verbose=3 -noelle-pdg-embed baseline_with_metadata.bc -o baseline_with_metadata.bc
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -PDGAnalysis -noelle-pdg-verbose=3 -noelle-pdg-embed baseline_with_metadata.bc -o baseline_with_metadata.bc
PDGAnalysis: Construct PDG from Analysis
Embed PDG as metadata
noelle-parallelizer baseline_with_metadata.bc -o baseline_parallelized.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
noelle-meta-loop-embed baseline_with_metadata.bc -o afterLoopMetadata.bc
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopMetadata.so -LoopMetadata baseline_with_metadata.bc -o afterLoopMetadata.bc
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopMetadata.so -LoopMetadata baseline_with_metadata.bc -o afterLoopMetadata.bc
noelle-parallelization-planner afterLoopMetadata.bc -o baseline_with_parallel_plan.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Planner.so -planner afterLoopMetadata.bc -o baseline_with_parallel_plan.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Planner.so -planner afterLoopMetadata.bc -o baseline_with_parallel_plan.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Planner.so -planner afterLoopMetadata.bc -o baseline_with_parallel_plan.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
Planner: Start
Planner:  Fetching the program loops
Noelle: Filter out cold code
Noelle:  Function "main"
Noelle:     Loop "  %14 = icmp slt i64 %indvars.iv37, %12, !noelle.pdg.inst.id !3388" (9.280922e-08%)
Noelle:  Disable loop "0" as cold code
Noelle:     Loop "  %26 = icmp slt i64 %indvars.iv35, %24, !noelle.pdg.inst.id !3402" (3.712369e-08%)
Noelle:  Disable loop "1" as cold code
Noelle:     Loop "  %38 = icmp slt i64 %indvars.iv33, %36, !noelle.pdg.inst.id !3414" (3.712369e-08%)
Noelle:  Disable loop "2" as cold code
Noelle:     Loop "  %50 = icmp slt i64 %indvars.iv31, %48, !noelle.pdg.inst.id !3425" (3.712369e-08%)
Noelle:  Disable loop "3" as cold code
Noelle:     Loop "  %62 = icmp slt i64 %indvars.iv29, %60, !noelle.pdg.inst.id !3436" (3.712369e-08%)
Noelle:  Disable loop "4" as cold code
Noelle:     Loop "  %74 = icmp slt i64 %indvars.iv27, %72, !noelle.pdg.inst.id !3447" (3.712369e-08%)
Noelle:  Disable loop "5" as cold code
Noelle:     Loop "  %86 = icmp slt i64 %indvars.iv25, %84, !noelle.pdg.inst.id !3458" (3.712369e-08%)
Noelle:  Disable loop "6" as cold code
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv23, %96, !noelle.pdg.inst.id !3469" (3.712369e-08%)
Noelle:  Disable loop "7" as cold code
Noelle:     Loop "  %110 = fcmp olt double %.01, 1.000000e+03, !noelle.pdg.inst.id !3483" (9.886077e+01%)
Noelle:     Loop "  %111 = fcmp ogt double %.02, 0.000000e+00, !noelle.pdg.inst.id !3490" (9.886074e+01%)
Noelle:     Loop "  %120 = fcmp olt double %.03, 1.000000e+03, !noelle.pdg.inst.id !3505" (9.885875e+01%)
Noelle:     Loop "  %141 = fcmp ogt double %.04, -5.000000e+00, !noelle.pdg.inst.id !3531" (9.341099e+01%)
Noelle:     Loop "  %exitcond7 = icmp eq i64 %indvars.iv21, %195, !noelle.pdg.inst.id !3591" (2.178930e+01%)
Noelle:     Loop "  %214 = icmp ult i64 %indvars.iv, 100000, !noelle.pdg.inst.id !3615" (1.070400e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %.0, 1072513385, !noelle.pdg.inst.id !3627" (3.502418e-02%)
Noelle:  Disable loop "14" as cold code
Noelle:     Loop "  %231 = fcmp ugt double %.05, 3.600000e+02, !noelle.pdg.inst.id !3638" (9.965314e-01%)
Noelle:     Loop "  %242 = tail call double @atan(double 1.000000e+00) #9, !noelle.pdg.inst.id !3650" (4.277144e-04%)
Noelle:  Disable loop "16" as cold code
Noelle:  Function "usqrt"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 32, !noelle.pdg.inst.id !37" (1.392397e-01%)
Noelle:  Function "SolveCubic"
Noelle:  Disable "SolveCubic" as cold function
Noelle:  Function "deg2rad"
Noelle:  Disable "deg2rad" as cold function
Noelle:  Function "rad2deg"
Noelle:  Disable "rad2deg" as cold function
Planner:    There are 8 loops in the program we are going to consider
Planner:  Filter out loops not worth considering
Planner:    Loop 17 has 6.780000e+02 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 11 has 4.630015e+02 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 12 has 1.200011e+01 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:  There are 3 loop nesting trees in the program
Planner:    ID: 15 (1)
Planner:      Function: "main"
Planner:      Loop: "  %231 = fcmp ugt double %.05, 3.600000e+02, !noelle.pdg.inst.id !3638"
Planner:      Loop nesting level: 1
Planner:      Hotness = 9.965314e-01 %
Planner:      Average instructions per invocation = 3.221225e+08 %
Planner:      Average iterations per invocation = 3.579139e+07 %
Planner:    
Planner:    ID: 8 (1)
Planner:      Function: "main"
Planner:      Loop: "  %110 = fcmp olt double %.01, 1.000000e+03, !noelle.pdg.inst.id !3483"
Planner:      Loop nesting level: 1
Planner:      Hotness = 9.886077e+01 %
Planner:      Average instructions per invocation = 3.195613e+10 %
Planner:      Average iterations per invocation = 9.990000e+02 %
Planner:    
Planner:      ID: 9 (2)
Planner:        Function: "main"
Planner:        Loop: "  %111 = fcmp ogt double %.02, 0.000000e+00, !noelle.pdg.inst.id !3490"
Planner:        Loop nesting level: 2
Planner:        Hotness = 9.886074e+01 %
Planner:        Average instructions per invocation = 3.198811e+07 %
Planner:        Average iterations per invocation = 4.099900e+01 %
Planner:      
Planner:        ID: 10 (3)
Planner:          Function: "main"
Planner:          Loop: "  %120 = fcmp olt double %.03, 1.000000e+03, !noelle.pdg.inst.id !3505"
Planner:          Loop nesting level: 3
Planner:          Hotness = 9.885875e+01 %
Planner:          Average instructions per invocation = 7.996865e+05 %
Planner:          Average iterations per invocation = 1.633000e+03 %
Planner:        
Planner:    ID: 13 (1)
Planner:      Function: "main"
Planner:      Loop: "  %214 = icmp ult i64 %indvars.iv, 100000, !noelle.pdg.inst.id !3615"
Planner:      Loop nesting level: 1
Planner:      Hotness = 1.070400e-01 %
Planner:      Average instructions per invocation = 3.460000e+07 %
Planner:      Average iterations per invocation = 5.000000e+04 %
Planner:    
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4, !noelle.pdg.inst.id !3370
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16, !noelle.pdg.inst.id !3368
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4, !noelle.pdg.inst.id !3369
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4, !noelle.pdg.inst.id !3370
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16, !noelle.pdg.inst.id !3368
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4, !noelle.pdg.inst.id !3369
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
Planner: LoopSelector:  Loop 15 saves only 8.858057e-01 when parallelized. Skip it
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4, !noelle.pdg.inst.id !3370
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16, !noelle.pdg.inst.id !3368
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4, !noelle.pdg.inst.id !3369
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4, !noelle.pdg.inst.id !3370
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16, !noelle.pdg.inst.id !3368
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4, !noelle.pdg.inst.id !3369
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4, !noelle.pdg.inst.id !3370
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16, !noelle.pdg.inst.id !3368
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4, !noelle.pdg.inst.id !3369
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4, !noelle.pdg.inst.id !3370
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16, !noelle.pdg.inst.id !3368
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4, !noelle.pdg.inst.id !3369
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4, !noelle.pdg.inst.id !3370
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16, !noelle.pdg.inst.id !3368
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4, !noelle.pdg.inst.id !3369
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4, !noelle.pdg.inst.id !3370
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16, !noelle.pdg.inst.id !3368
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4, !noelle.pdg.inst.id !3369
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
Planner: LoopSelector: Start
Planner: LoopSelector:   Order of loops and their maximum savings
Planner: LoopSelector:    Loop 8
Planner: LoopSelector:      Function: "main"
Planner: LoopSelector:      Loop nesting level: 1
Planner: LoopSelector:      "  %110 = fcmp olt double %.01, 1.000000e+03, !noelle.pdg.inst.id !3483"
Planner: LoopSelector:      Coverage: 9.886077e+01%
Planner: LoopSelector:      Whole-program savings = 9.341347e+01%
Planner: LoopSelector:      Loop savings = 9.448993e+01%
Planner: LoopSelector:    Loop 9
Planner: LoopSelector:      Function: "main"
Planner: LoopSelector:      Loop nesting level: 2
Planner: LoopSelector:      "  %111 = fcmp ogt double %.02, 0.000000e+00, !noelle.pdg.inst.id !3490"
Planner: LoopSelector:      Coverage: 9.886074e+01%
Planner: LoopSelector:      Whole-program savings = 9.341345e+01%
Planner: LoopSelector:      Loop savings = 9.448993e+01%
Planner: LoopSelector:    Loop 10
Planner: LoopSelector:      Function: "main"
Planner: LoopSelector:      Loop nesting level: 3
Planner: LoopSelector:      "  %120 = fcmp olt double %.03, 1.000000e+03, !noelle.pdg.inst.id !3505"
Planner: LoopSelector:      Coverage: 9.885875e+01%
Planner: LoopSelector:      Whole-program savings = 9.341146e+01%
Planner: LoopSelector:      Loop savings = 9.448982e+01%
Planner: LoopSelector: End
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4, !noelle.pdg.inst.id !3370
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16, !noelle.pdg.inst.id !3368
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4, !noelle.pdg.inst.id !3369
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4, !noelle.pdg.inst.id !3370
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16, !noelle.pdg.inst.id !3368
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4, !noelle.pdg.inst.id !3369
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
Planner: LoopSelector:  Loop 13 saves only 1.237466e-03 when parallelized. Skip it
Planner:   Maximum time saved = 9.341347e+01% (30195320619)
Planner:   Maximum time saved with DOALL only = 0.000000e+00% (0)
Planner: Exit
noelle-rm-function -function-name=SIMONE_CAMPANONI_IS_GOING_TO_REMOVE_THIS_FUNCTION code_with_prototypes.bc -o code_to_parallelize.bc
NOELLE: DeadFunctions: Start
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/RemoveFunction.so -noelle-rm-function -function-name=SIMONE_CAMPANONI_IS_GOING_TO_REMOVE_THIS_FUNCTION code_with_prototypes.bc -o code_to_parallelize.bc
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/RemoveFunction.so -noelle-rm-function -function-name=SIMONE_CAMPANONI_IS_GOING_TO_REMOVE_THIS_FUNCTION code_with_prototypes.bc -o code_to_parallelize.bc
RemoveFunction: Start
RemoveFunction:   Check if function "SIMONE_CAMPANONI_IS_GOING_TO_REMOVE_THIS_FUNCTION" exists
RemoveFunction:     The function exists
RemoveFunction:   Remove the function
RemoveFunction: Exit
NOELLE: DeadFunctions: Exit
noelle-parallelizer-loop code_to_parallelize.bc -o parallelized_unoptimized.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Parallelizer.so -parallelizer code_to_parallelize.bc -o parallelized_unoptimized.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Parallelizer.so -parallelizer code_to_parallelize.bc -o parallelized_unoptimized.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Parallelizer.so -parallelizer code_to_parallelize.bc -o parallelized_unoptimized.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
Parallelizer: Start
Parallelizer:  Analyzing the module code_to_parallelize.bc
Parallelizer:  Fetching the program loops
Noelle: Filter out cold code
Noelle:  Function "main"
Noelle:     Loop "  %14 = icmp slt i64 %indvars.iv37, %12, !noelle.pdg.inst.id !3390" (9.280922e-08%)
Noelle:  Disable loop "0" as cold code
Noelle:     Loop "  %26 = icmp slt i64 %indvars.iv35, %24, !noelle.pdg.inst.id !3404" (3.712369e-08%)
Noelle:  Disable loop "1" as cold code
Noelle:     Loop "  %38 = icmp slt i64 %indvars.iv33, %36, !noelle.pdg.inst.id !3416" (3.712369e-08%)
Noelle:  Disable loop "2" as cold code
Noelle:     Loop "  %50 = icmp slt i64 %indvars.iv31, %48, !noelle.pdg.inst.id !3427" (3.712369e-08%)
Noelle:  Disable loop "3" as cold code
Noelle:     Loop "  %62 = icmp slt i64 %indvars.iv29, %60, !noelle.pdg.inst.id !3438" (3.712369e-08%)
Noelle:  Disable loop "4" as cold code
Noelle:     Loop "  %74 = icmp slt i64 %indvars.iv27, %72, !noelle.pdg.inst.id !3449" (3.712369e-08%)
Noelle:  Disable loop "5" as cold code
Noelle:     Loop "  %86 = icmp slt i64 %indvars.iv25, %84, !noelle.pdg.inst.id !3460" (3.712369e-08%)
Noelle:  Disable loop "6" as cold code
Noelle:     Loop "  %98 = icmp slt i64 %indvars.iv23, %96, !noelle.pdg.inst.id !3471" (3.712369e-08%)
Noelle:  Disable loop "7" as cold code
Noelle:     Loop "  %110 = fcmp olt double %.01, 1.000000e+03, !noelle.pdg.inst.id !3485" (9.886077e+01%)
Noelle:     Loop "  %111 = fcmp ogt double %.02, 0.000000e+00, !noelle.pdg.inst.id !3492" (9.886074e+01%)
Noelle:     Loop "  %120 = fcmp olt double %.03, 1.000000e+03, !noelle.pdg.inst.id !3507" (9.885875e+01%)
Noelle:     Loop "  %141 = fcmp ogt double %.04, -5.000000e+00, !noelle.pdg.inst.id !3533" (9.341099e+01%)
Noelle:     Loop "  %exitcond7 = icmp eq i64 %indvars.iv21, %195, !noelle.pdg.inst.id !3593" (2.178930e+01%)
Noelle:     Loop "  %214 = icmp ult i64 %indvars.iv, 100000, !noelle.pdg.inst.id !3617" (1.070400e-01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %.0, 1072513385, !noelle.pdg.inst.id !3629" (3.502418e-02%)
Noelle:  Disable loop "14" as cold code
Noelle:     Loop "  %231 = fcmp ugt double %.05, 3.600000e+02, !noelle.pdg.inst.id !3640" (9.965314e-01%)
Noelle:     Loop "  %242 = tail call double @atan(double 1.000000e+00) #10, !noelle.pdg.inst.id !3652" (4.277144e-04%)
Noelle:  Disable loop "16" as cold code
Noelle:  Function "usqrt"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 32, !noelle.pdg.inst.id !39" (1.392397e-01%)
Noelle:  Function "SolveCubic"
Noelle:  Disable "SolveCubic" as cold function
Noelle:  Function "deg2rad"
Noelle:  Disable "deg2rad" as cold function
Noelle:  Function "rad2deg"
Noelle:  Disable "rad2deg" as cold function
Parallelizer:    There are 8 loops in the program we are going to consider
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4, !noelle.pdg.inst.id !3372
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16, !noelle.pdg.inst.id !3370
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4, !noelle.pdg.inst.id !3371
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4, !noelle.pdg.inst.id !3372
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16, !noelle.pdg.inst.id !3370
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4, !noelle.pdg.inst.id !3371
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4, !noelle.pdg.inst.id !3372
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16, !noelle.pdg.inst.id !3370
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4, !noelle.pdg.inst.id !3371
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4, !noelle.pdg.inst.id !3372
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16, !noelle.pdg.inst.id !3370
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4, !noelle.pdg.inst.id !3371
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4, !noelle.pdg.inst.id !3372
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16, !noelle.pdg.inst.id !3370
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4, !noelle.pdg.inst.id !3371
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.int_sqrt, align 4, !noelle.pdg.inst.id !3372
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca [3 x double], align 16, !noelle.pdg.inst.id !3370
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4, !noelle.pdg.inst.id !3371
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "main"
Parallelizer: parallelizerLoop:   Loop 8 = "  %110 = fcmp olt double %.01, 1.000000e+03, !noelle.pdg.inst.id !3485"
Parallelizer: parallelizerLoop:   Nesting level = 1
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %1 = alloca [3 x double], align 16, !noelle.pdg.inst.id !3370
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %8 = getelementptr inbounds [3 x double], [3 x double]* %1, i64 0, i64 0, !noelle.pdg.inst.id !3381
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %95 = load i32, i32* %2, align 4, !tbaa !3383, !noelle.pdg.inst.id !181
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %105 = getelementptr inbounds [3 x double], [3 x double]* %1, i64 0, i64 1, !noelle.pdg.inst.id !3478
Parallelizer: parallelizerLoop:   Environment:   Live-in 5 =   %106 = getelementptr inbounds [3 x double], [3 x double]* %1, i64 0, i64 2, !noelle.pdg.inst.id !3479
Parallelizer: parallelizerLoop:   Environment:   Live-out 3 =   %.lcssa2.lcssa3.lcssa5 = phi i32 [ %95, %104 ], [ %.lcssa2.lcssa3.lcssa, %208 ], !noelle.pdg.inst.id !3483
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "main"
Parallelizer: parallelizerLoop:   Loop 9 = "  %111 = fcmp ogt double %.02, 0.000000e+00, !noelle.pdg.inst.id !3492"
Parallelizer: parallelizerLoop:   Nesting level = 2
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %1 = alloca [3 x double], align 16, !noelle.pdg.inst.id !3370
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %8 = getelementptr inbounds [3 x double], [3 x double]* %1, i64 0, i64 0, !noelle.pdg.inst.id !3381
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %105 = getelementptr inbounds [3 x double], [3 x double]* %1, i64 0, i64 1, !noelle.pdg.inst.id !3478
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %106 = getelementptr inbounds [3 x double], [3 x double]* %1, i64 0, i64 2, !noelle.pdg.inst.id !3479
Parallelizer: parallelizerLoop:   Environment:   Live-in 5 =   %.lcssa2.lcssa3.lcssa5 = phi i32 [ %95, %104 ], [ %.lcssa2.lcssa3.lcssa, %208 ], !noelle.pdg.inst.id !3483
Parallelizer: parallelizerLoop:   Environment:   Live-in 6 =   %.01 = phi double [ 1.000000e+00, %104 ], [ %209, %208 ], !noelle.pdg.inst.id !3484
Parallelizer: parallelizerLoop:   Environment:   Live-out 2 =   %.lcssa2.lcssa3 = phi i32 [ %.lcssa2.lcssa, %206 ], [ %.lcssa2.lcssa3.lcssa5, %.preheader20.preheader ], !noelle.pdg.inst.id !3490
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "main"
Parallelizer: parallelizerLoop:   Loop 10 = "  %120 = fcmp olt double %.03, 1.000000e+03, !noelle.pdg.inst.id !3507"
Parallelizer: parallelizerLoop:   Nesting level = 3
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %1 = alloca [3 x double], align 16, !noelle.pdg.inst.id !3370
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %8 = getelementptr inbounds [3 x double], [3 x double]* %1, i64 0, i64 0, !noelle.pdg.inst.id !3381
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %105 = getelementptr inbounds [3 x double], [3 x double]* %1, i64 0, i64 1, !noelle.pdg.inst.id !3478
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %106 = getelementptr inbounds [3 x double], [3 x double]* %1, i64 0, i64 2, !noelle.pdg.inst.id !3479
Parallelizer: parallelizerLoop:   Environment:   Live-in 5 =   %.01 = phi double [ 1.000000e+00, %104 ], [ %209, %208 ], !noelle.pdg.inst.id !3484
Parallelizer: parallelizerLoop:   Environment:   Live-in 6 =   %.lcssa2.lcssa3 = phi i32 [ %.lcssa2.lcssa, %206 ], [ %.lcssa2.lcssa3.lcssa5, %.preheader20.preheader ], !noelle.pdg.inst.id !3490
Parallelizer: parallelizerLoop:   Environment:   Live-in 7 =   %114 = fmul x86_fp80 %113, %113, !noelle.pdg.inst.id !3498
Parallelizer: parallelizerLoop:   Environment:   Live-in 8 =   %117 = fmul x86_fp80 %116, %113, !noelle.pdg.inst.id !3501
Parallelizer: parallelizerLoop:   Environment:   Live-in 9 =   %118 = fmul x86_fp80 %113, 0xK40029000000000000000, !noelle.pdg.inst.id !3502
Parallelizer: parallelizerLoop:   Environment:   Live-in 10 =   %119 = fdiv x86_fp80 %113, 0xK4000C000000000000000, !noelle.pdg.inst.id !3503
Parallelizer: parallelizerLoop:   Environment:   Live-out 2 =   %.lcssa2 = phi i32 [ %.lcssa, %204 ], [ %.lcssa2.lcssa3, %.preheader19.preheader ], !noelle.pdg.inst.id !3505
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: Exit
noelle-meta-clean parallelized_unoptimized.bc parallelized_unoptimized.bc
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CleanMetadata.so -CleanMetadata -clean-loop-metadata=true -clean-prof-metadata=true -clean-pdg-metadata=true parallelized_unoptimized.bc -o parallelized_unoptimized.bc
noelle/core/Clean Loop Metadata
noelle/core/Clean PDG Metadata
noelle/core/Clean profiler metadata
opt --strip-named-metadata parallelized_unoptimized.bc -o parallelized_unoptimized.bc
clang -O3 -c -emit-llvm parallelized_unoptimized.bc -o baseline_parallelized.bc
clang -O3 -c -emit-llvm baseline_parallelized.bc -o baseline_parallelized.bc
cp baseline_parallelized.bc basicmath.bc
make[1]: Leaving directory '/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/basicmath'
