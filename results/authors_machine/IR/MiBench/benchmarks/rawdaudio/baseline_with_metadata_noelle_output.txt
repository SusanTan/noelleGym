make[1]: Entering directory '/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/rawdaudio'
./runEnablers.sh rawdaudio rawdaudio.bc large "-lm -lstdc++ -lpthread -ltermcap" -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier
/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/rawdaudio /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/rawdaudio
Cloning https://github.com/scampanoni/virgil.git
Cloning into 'threadpool'...
/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/rawdaudio

opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -tbaa -early-cse-memssa -licm -simplifycfg -simplifycfg-sink-common=false -instcombine -tailcallelim -loop-simplify -lcssa -licm -loop-unswitch -globalopt -instcombine -ipsccp -dce -gvn -dse -adce -loop-simplify -lcssa -indvars -loop-deletion -instcombine -indvars -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa --functionattrs --rpo-functionattrs rawdaudio.bc -o baseline.bc
/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/rawdaudio /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/rawdaudio
WARNING: ./runme_rawdaudio.sh not found. Going up one dir.
Running: ./baseline_prof < data/very_large.adpcm > output_very_large.pcm in /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/MiBench/telecomm/adpcm
Final valprev=0, index=0
--------------------------------------------------------------------------------------
/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/rawdaudio
DONE
opt -pgo-test-profile-file=/tmp/tmp.B9VUFrH4Yi -block-freq -pgo-instr-use baseline.bc -o baseline_pre.bc
opt --strip-debug --strip-debug-declare baseline_pre.bc -o baseline_pre.bc
noelle-deadcode baseline_pre.bc baseline_pre.bc
NOELLE: DeadFunctions: Start
noelle-fixedpoint baseline_pre.bc baseline_pre.bc "noelle-load" -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DeadFunction.so -noelle-dfe
NOELLE: FixedPoint: Start
NOELLE: FixedPoint:   Loader: noelle-load
NOELLE: FixedPoint:   Options: -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DeadFunction.so -noelle-dfe
NOELLE: FixedPoint:   Input: baseline_pre.bc
NOELLE: FixedPoint:   Output: baseline_pre.bc
NOELLE: FixedPoint:   Temporary input: /tmp/tmp.bt9oqxFzMK (.ll version is /tmp/tmp.fhpQRHydbd)
NOELLE: FixedPoint:   Temporary output: /tmp/tmp.yd38XBUPxK (.ll version is /tmp/tmp.imc09cBHSq)
NOELLE: FixedPoint:   Normalize the code
noelle-norm /tmp/tmp.bt9oqxFzMK -o /tmp/tmp.yd38XBUPxK
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.bt9oqxFzMK -o /tmp/tmp.yd38XBUPxK
NOELLE: FixedPoint:   Run until a fixed point is reached
NOELLE: FixedPoint:     Invocation 0
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DeadFunction.so -noelle-dfe /tmp/tmp.bt9oqxFzMK -o /tmp/tmp.yd38XBUPxK
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DeadFunction.so -noelle-dfe /tmp/tmp.bt9oqxFzMK -o /tmp/tmp.yd38XBUPxK
DeadFunctionEliminator: Start
DeadFunctionEliminator:   Inline functions that are invoked only by one call instruction and that do not escape into memory
DeadFunctionEliminator:   Get the islands
DeadFunctionEliminator:   Identify the islands reachable from the entry points
DeadFunctionEliminator:     Island
DeadFunctionEliminator:       main
DeadFunctionEliminator:       perror
DeadFunctionEliminator:       exit
DeadFunctionEliminator:       fprintf
DeadFunctionEliminator:       adpcm_decoder
DeadFunctionEliminator:   Identify the functions that can be deleted
DeadFunctionEliminator: Exit
Noelle:  Function "main"
Noelle:     Loop "  %4 = getelementptr [500 x i8], [500 x i8]* @abuf, i64 0, i64 0" (9.863586e+01%)
Noelle:  Function "adpcm_decoder"
Noelle:     Loop "  %34 = load i32, i32* %7, align 4" (7.404263e+01%)
Noelle:  Function "adpcm_coder"
Noelle:     Loop "  %36 = load i32, i32* %7, align 4" (0.000000e+00%)
Noelle:  Function "main"
Noelle:     Loop "  %4 = getelementptr [500 x i8], [500 x i8]* @abuf, i64 0, i64 0" (9.863586e+01%)
Noelle:  Function "adpcm_decoder"
Noelle:     Loop "  %34 = load i32, i32* %7, align 4" (7.404263e+01%)
Noelle:  Function "adpcm_coder"
Noelle:     Loop "  %36 = load i32, i32* %7, align 4" (0.000000e+00%)
NOELLE: FixedPoint: Exit
NOELLE: DeadFunctions: Exit
noelle-simplification baseline_pre.bc -o baseline_pre.bc
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -tbaa -early-cse-memssa -licm -simplifycfg -simplifycfg-sink-common=false -instcombine -tailcallelim -loop-simplify -lcssa -licm -loop-unswitch -globalopt -instcombine -ipsccp -dce -gvn -dse -adce -loop-simplify -lcssa -indvars -loop-deletion -instcombine -indvars -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa --functionattrs --rpo-functionattrs baseline_pre.bc -o baseline_pre.bc
noelle-inline baseline_pre.bc "-noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier"
NOELLE: Inliner: Start
noelle-fixedpoint baseline_pre.bc baseline_pre.bc "noelle-parallel-load" -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier
NOELLE: FixedPoint: Start
NOELLE: FixedPoint:   Loader: noelle-parallel-load
NOELLE: FixedPoint:   Options: -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier
NOELLE: FixedPoint:   Input: baseline_pre.bc
NOELLE: FixedPoint:   Output: baseline_pre.bc
NOELLE: FixedPoint:   Temporary input: /tmp/tmp.ikjMEsr6Lk (.ll version is /tmp/tmp.DXAQizXY6B)
NOELLE: FixedPoint:   Temporary output: /tmp/tmp.jleIF1pXF1 (.ll version is /tmp/tmp.AvlAMF2rJU)
NOELLE: FixedPoint:   Normalize the code
noelle-norm /tmp/tmp.ikjMEsr6Lk -o /tmp/tmp.jleIF1pXF1
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.ikjMEsr6Lk -o /tmp/tmp.jleIF1pXF1
NOELLE: FixedPoint:   Run until a fixed point is reached
NOELLE: FixedPoint:     Invocation 0
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.ikjMEsr6Lk -o /tmp/tmp.jleIF1pXF1
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.ikjMEsr6Lk -o /tmp/tmp.jleIF1pXF1
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.ikjMEsr6Lk -o /tmp/tmp.jleIF1pXF1
Inliner: Start
Inliner:   Number of program instructions = 442
Inliner:   Profiles are available and will be used
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca i32, align 4
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca i32, align 4
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i32, align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %15 = alloca i32, align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i32, align 4
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %11 = alloca i32, align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i16*, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca i8*, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i32, align 4
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca %struct.adpcm_state*, align 8
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i8*, align 8
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca i16*, align 8
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i32, align 4
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca i32, align 4
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
Inliner:   Inlining in: main (40 instructions. The inlining will add 177 instructions),   call void @adpcm_decoder(i8* %17, i16* %18, i32 %16, %struct.adpcm_state* @state)
Inliner:   Inlined calls due to loop-carried data dependences
Inliner: Exit
Noelle:  Function "main"
Noelle:     Loop "  %4 = getelementptr [500 x i8], [500 x i8]* @abuf, i64 0, i64 0" (9.863586e+01%)
Noelle:  Function "adpcm_decoder"
Noelle:     Loop "  %34 = load i32, i32* %7, align 4" (7.404263e+01%)
Noelle:  Function "adpcm_coder"
Noelle:     Loop "  %36 = load i32, i32* %7, align 4" (0.000000e+00%)
Noelle:  Function "main"
Noelle:     Loop "  %18 = getelementptr [500 x i8], [500 x i8]* @abuf, i64 0, i64 0" (9.994261e+01%)
Noelle:     Loop "  %62 = load i32, i32* %3, align 4" (9.982741e+01%)
Noelle:  Function "adpcm_decoder"
Noelle:     Loop "  %34 = load i32, i32* %7, align 4" (5.736376e-02%)
Noelle:  Function "adpcm_coder"
Noelle:     Loop "  %36 = load i32, i32* %7, align 4" (0.000000e+00%)
NOELLE: FixedPoint:       There are 210 different instructions and 303 different loop instructions
NOELLE: FixedPoint:       Normalize the code
noelle-norm /tmp/tmp.jleIF1pXF1 -o /tmp/tmp.jleIF1pXF1
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.jleIF1pXF1 -o /tmp/tmp.jleIF1pXF1
NOELLE: FixedPoint:     Invocation 1
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.ikjMEsr6Lk -o /tmp/tmp.jleIF1pXF1
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.ikjMEsr6Lk -o /tmp/tmp.jleIF1pXF1
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.ikjMEsr6Lk -o /tmp/tmp.jleIF1pXF1
Inliner: Start
Inliner:   Number of program instructions = 672
Inliner:   Profiles are available and will be used
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i32, align 4
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i32, align 4
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i32, align 4
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i16*, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i32, align 4
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca i8*, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca i8*, align 8
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca i32, align 4
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %struct.adpcm_state*, align 8
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i16*, align 8
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca i32, align 4
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i32, align 4
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %14 = alloca i32, align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i32, align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %13 = alloca i32, align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %12 = alloca i32, align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %11 = alloca i32, align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca i32, align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca i32, align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i32, align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca i32, align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca i32, align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i16*, align 8
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %2 = alloca i16*, align 8 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i32, align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %7 = alloca i32, align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca i8*, align 8
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %1 = alloca i8*, align 8 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca i8*, align 8
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %5 = alloca i8*, align 8 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca i32, align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca i32, align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %struct.adpcm_state*, align 8
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca %struct.adpcm_state*, align 8 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i16*, align 8
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca i16*, align 8 can be cloned
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 1
DOALL:     	  %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182)
DOALL:     External nodes: 9
DOALL:     	  br i1 %26, label %27, label %28, !prof !31
DOALL:     	  %51 = load i16, i16* %50, align 2
DOALL:     	  %55 = load i8, i8* %54, align 2
DOALL:     	  %73 = load i8, i8* %71, align 1
DOALL:     	  store i16 %154, i16* %155, align 2
DOALL:     	  store i16 %160, i16* %162, align 2
DOALL:     	  store i8 %164, i8* %166, align 2
DOALL:     	  %182 = mul nsw i32 %181, 4
DOALL:     	  %183 = getelementptr [1000 x i16], [1000 x i16]* @sbuf, i64 0, i64 0
DOALL:     Edges: 12
DOALL:     Loop-carried data dependences
DOALL:         %73 = load i8, i8* %71, align 1 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:         %55 = load i8, i8* %54, align 2 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:         store i8 %164, i8* %166, align 2 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:         %51 = load i16, i16* %50, align 2 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:         store i16 %160, i16* %162, align 2 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:         store i8 %164, i8* %166, align 2 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:         store i16 %154, i16* %155, align 2 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:         store i16 %160, i16* %162, align 2 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:         store i16 %154, i16* %155, align 2 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:         store i8 %164, i8* %166, align 2 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:         store i8 %164, i8* %166, align 2 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:         %73 = load i8, i8* %71, align 1 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:         store i16 %160, i16* %162, align 2 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:         store i16 %160, i16* %162, align 2 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:         store i16 %154, i16* %155, align 2 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:         store i16 %154, i16* %155, align 2 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:         %51 = load i16, i16* %50, align 2 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:         %55 = load i8, i8* %54, align 2 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 154
DOALL:     	  %76 = ashr i32 %75, 4
DOALL:     	  %21 = icmp slt i32 %20, 0
DOALL:     	  %26 = icmp eq i32 %25, 0
DOALL:     	  %30 = mul nsw i32 %29, 2
DOALL:     	  %63 = icmp sgt i32 %62, 0
DOALL:     	  %66 = icmp ne i32 %65, 0
DOALL:     	  %69 = and i32 %68, 15
DOALL:     	  %18 = getelementptr [500 x i8], [500 x i8]* @abuf, i64 0, i64 0
DOALL:     	  %19 = call i32 (i32, i8*, i32, ...) bitcast (i32 (...)* @read to i32 (i32, i8*, i32, ...)*)(i32 0, i8* %18, i32 500)
DOALL:     	  br i1 %113, label %114, label %._crit_edge3.i, !prof !37
DOALL:     	  %115 = load i32, i32* %9, align 4
DOALL:     	  %116 = ashr i32 %115, 1
DOALL:     	  %117 = load i32, i32* %11, align 4
DOALL:     	  %118 = add nsw i32 %117, %116
DOALL:     	  store i32 %118, i32* %11, align 4
DOALL:     	  %120 = load i32, i32* %8, align 4
DOALL:     	  %121 = and i32 %120, 1
DOALL:     	  %122 = icmp ne i32 %121, 0
DOALL:     	  br i1 %122, label %123, label %._crit_edge4.i, !prof !38
DOALL:     	  %124 = load i32, i32* %9, align 4
DOALL:     	  %125 = ashr i32 %124, 2
DOALL:     	  %126 = load i32, i32* %11, align 4
DOALL:     	  %127 = add nsw i32 %126, %125
DOALL:     	  store i32 %127, i32* %11, align 4
DOALL:     	  %129 = load i32, i32* %7, align 4
DOALL:     	  %130 = icmp ne i32 %129, 0
DOALL:     	  br i1 %130, label %131, label %135, !prof !39
DOALL:     	  %132 = load i32, i32* %11, align 4
DOALL:     	  %133 = load i32, i32* %10, align 4
DOALL:     	  %134 = sub nsw i32 %133, %132
DOALL:     	  store i32 %134, i32* %10, align 4
DOALL:     	  %136 = load i32, i32* %11, align 4
DOALL:     	  %137 = load i32, i32* %10, align 4
DOALL:     	  %138 = add nsw i32 %137, %136
DOALL:     	  store i32 %138, i32* %10, align 4
DOALL:     	  %140 = load i32, i32* %10, align 4
DOALL:     	  %141 = icmp sgt i32 %140, 32767
DOALL:     	  br i1 %141, label %142, label %143, !prof !40
DOALL:     	  store i32 32767, i32* %10, align 4
DOALL:     	  store i32 %19, i32* %16, align 4
DOALL:     	  %20 = load i32, i32* %16, align 4
DOALL:     	  br i1 %21, label %22, label %24, !prof !30
DOALL:     	  %25 = load i32, i32* %16, align 4
DOALL:     	  br i1 %26, label %27, label %28, !prof !31
DOALL:     	  %29 = load i32, i32* %16, align 4
DOALL:     	  %31 = getelementptr [500 x i8], [500 x i8]* @abuf, i64 0, i64 0
DOALL:     	  %32 = getelementptr [1000 x i16], [1000 x i16]* @sbuf, i64 0, i64 0
DOALL:     	  store i8* %31, i8** %1, align 8
DOALL:     	  store i16* %32, i16** %2, align 8
DOALL:     	  store i32 %30, i32* %3, align 4
DOALL:     	  store %struct.adpcm_state* @state, %struct.adpcm_state** %4, align 8
DOALL:     	  %47 = load i16*, i16** %2, align 8
DOALL:     	  store i16* %47, i16** %6, align 8
DOALL:     	  %48 = load i8*, i8** %1, align 8
DOALL:     	  store i8* %48, i8** %5, align 8
DOALL:     	  %49 = load %struct.adpcm_state*, %struct.adpcm_state** %4, align 8
DOALL:     	  %50 = getelementptr inbounds %struct.adpcm_state, %struct.adpcm_state* %49, i32 0, i32 0
DOALL:     	  %51 = load i16, i16* %50, align 2
DOALL:     	  %52 = sext i16 %51 to i32
DOALL:     	  store i32 %52, i32* %10, align 4
DOALL:     	  %53 = load %struct.adpcm_state*, %struct.adpcm_state** %4, align 8
DOALL:     	  %54 = getelementptr inbounds %struct.adpcm_state, %struct.adpcm_state* %53, i32 0, i32 1
DOALL:     	  %55 = load i8, i8* %54, align 2
DOALL:     	  %56 = sext i8 %55 to i32
DOALL:     	  store i32 %56, i32* %12, align 4
DOALL:     	  %57 = load i32, i32* %12, align 4
DOALL:     	  %58 = sext i32 %57 to i64
DOALL:     	  %59 = getelementptr inbounds [89 x i32], [89 x i32]* @stepsizeTable, i64 0, i64 %58
DOALL:     	  %60 = load i32, i32* %59, align 4
DOALL:     	  store i32 %60, i32* %9, align 4
DOALL:     	  store i32 0, i32* %14, align 4
DOALL:     	  %62 = load i32, i32* %3, align 4
DOALL:     	  br i1 %63, label %64, label %adpcm_decoder.exit, !prof !32
DOALL:     	  %65 = load i32, i32* %14, align 4
DOALL:     	  br i1 %66, label %67, label %70, !prof !33
DOALL:     	  %68 = load i32, i32* %13, align 4
DOALL:     	  store i32 %69, i32* %8, align 4
DOALL:     	  %71 = load i8*, i8** %5, align 8
DOALL:     	  %72 = getelementptr inbounds i8, i8* %71, i32 1
DOALL:     	  store i8* %72, i8** %5, align 8
DOALL:     	  %73 = load i8, i8* %71, align 1
DOALL:     	  %74 = sext i8 %73 to i32
DOALL:     	  store i32 %74, i32* %13, align 4
DOALL:     	  %75 = load i32, i32* %13, align 4
DOALL:     	  %77 = and i32 %76, 15
DOALL:     	  store i32 %77, i32* %8, align 4
DOALL:     	  %79 = load i32, i32* %14, align 4
DOALL:     	  %80 = icmp ne i32 %79, 0
DOALL:     	  %81 = xor i1 %80, true
DOALL:     	  %82 = zext i1 %81 to i32
DOALL:     	  store i32 %82, i32* %14, align 4
DOALL:     	  %83 = load i32, i32* %8, align 4
DOALL:     	  %84 = sext i32 %83 to i64
DOALL:     	  %85 = getelementptr inbounds [16 x i32], [16 x i32]* @indexTable, i64 0, i64 %84
DOALL:     	  %86 = load i32, i32* %85, align 4
DOALL:     	  %87 = load i32, i32* %12, align 4
DOALL:     	  %88 = add nsw i32 %87, %86
DOALL:     	  store i32 %88, i32* %12, align 4
DOALL:     	  %89 = load i32, i32* %12, align 4
DOALL:     	  %90 = icmp slt i32 %89, 0
DOALL:     	  br i1 %90, label %91, label %._crit_edge.i, !prof !34
DOALL:     	  store i32 0, i32* %12, align 4
DOALL:     	  %93 = load i32, i32* %12, align 4
DOALL:     	  %94 = icmp sgt i32 %93, 88
DOALL:     	  br i1 %94, label %95, label %._crit_edge1.i, !prof !35
DOALL:     	  store i32 88, i32* %12, align 4
DOALL:     	  %97 = load i32, i32* %8, align 4
DOALL:     	  %98 = and i32 %97, 8
DOALL:     	  store i32 %98, i32* %7, align 4
DOALL:     	  %99 = load i32, i32* %8, align 4
DOALL:     	  %100 = and i32 %99, 7
DOALL:     	  store i32 %100, i32* %8, align 4
DOALL:     	  %101 = load i32, i32* %9, align 4
DOALL:     	  %102 = ashr i32 %101, 3
DOALL:     	  store i32 %102, i32* %11, align 4
DOALL:     	  %103 = load i32, i32* %8, align 4
DOALL:     	  %104 = and i32 %103, 4
DOALL:     	  %105 = icmp ne i32 %104, 0
DOALL:     	  br i1 %105, label %106, label %._crit_edge2.i, !prof !36
DOALL:     	  %107 = load i32, i32* %9, align 4
DOALL:     	  %108 = load i32, i32* %11, align 4
DOALL:     	  %109 = add nsw i32 %108, %107
DOALL:     	  store i32 %109, i32* %11, align 4
DOALL:     	  %111 = load i32, i32* %8, align 4
DOALL:     	  %112 = and i32 %111, 2
DOALL:     	  %113 = icmp ne i32 %112, 0
DOALL:     	  %144 = load i32, i32* %10, align 4
DOALL:     	  %145 = icmp slt i32 %144, -32768
DOALL:     	  br i1 %145, label %146, label %._crit_edge5.i, !prof !41
DOALL:     	  store i32 -32768, i32* %10, align 4
DOALL:     	  %149 = load i32, i32* %12, align 4
DOALL:     	  %150 = sext i32 %149 to i64
DOALL:     	  %151 = getelementptr inbounds [89 x i32], [89 x i32]* @stepsizeTable, i64 0, i64 %150
DOALL:     	  %152 = load i32, i32* %151, align 4
DOALL:     	  store i32 %152, i32* %9, align 4
DOALL:     	  %153 = load i32, i32* %10, align 4
DOALL:     	  %154 = trunc i32 %153 to i16
DOALL:     	  %155 = load i16*, i16** %6, align 8
DOALL:     	  %156 = getelementptr inbounds i16, i16* %155, i32 1
DOALL:     	  store i16* %156, i16** %6, align 8
DOALL:     	  store i16 %154, i16* %155, align 2
DOALL:     	  %157 = load i32, i32* %3, align 4
DOALL:     	  %158 = add nsw i32 %157, -1
DOALL:     	  store i32 %158, i32* %3, align 4
DOALL:     	  %159 = load i32, i32* %10, align 4
DOALL:     	  %160 = trunc i32 %159 to i16
DOALL:     	  %161 = load %struct.adpcm_state*, %struct.adpcm_state** %4, align 8
DOALL:     	  %162 = getelementptr inbounds %struct.adpcm_state, %struct.adpcm_state* %161, i32 0, i32 0
DOALL:     	  store i16 %160, i16* %162, align 2
DOALL:     	  %163 = load i32, i32* %12, align 4
DOALL:     	  %164 = trunc i32 %163 to i8
DOALL:     	  %165 = load %struct.adpcm_state*, %struct.adpcm_state** %4, align 8
DOALL:     	  %166 = getelementptr inbounds %struct.adpcm_state, %struct.adpcm_state* %165, i32 0, i32 1
DOALL:     	  store i8 %164, i8* %166, align 2
DOALL:     External nodes: 81
DOALL:     	  call void @llvm.lifetime.start.p0i8(i64 4, i8* %39)
DOALL:     	  %40 = bitcast i32* %8 to i8*
DOALL:     	  call void @llvm.lifetime.start.p0i8(i64 4, i8* %40)
DOALL:     	  %41 = bitcast i32* %9 to i8*
DOALL:     	  call void @llvm.lifetime.start.p0i8(i64 4, i8* %41)
DOALL:     	  %42 = bitcast i32* %10 to i8*
DOALL:     	  call void @llvm.lifetime.start.p0i8(i64 4, i8* %42)
DOALL:     	  %43 = bitcast i32* %11 to i8*
DOALL:     	  br label %119
DOALL:     	  br label %119
DOALL:     	  br label %128
DOALL:     	  br label %128
DOALL:     	  br label %139
DOALL:     	  br label %139
DOALL:     	  br label %148
DOALL:     	  %33 = bitcast i8** %1 to i8*
DOALL:     	  call void @llvm.lifetime.start.p0i8(i64 8, i8* %33)
DOALL:     	  %34 = bitcast i16** %2 to i8*
DOALL:     	  call void @llvm.lifetime.start.p0i8(i64 8, i8* %34)
DOALL:     	  %35 = bitcast i32* %3 to i8*
DOALL:     	  call void @llvm.lifetime.start.p0i8(i64 4, i8* %35)
DOALL:     	  %36 = bitcast %struct.adpcm_state** %4 to i8*
DOALL:     	  call void @llvm.lifetime.start.p0i8(i64 8, i8* %36)
DOALL:     	  %37 = bitcast i8** %5 to i8*
DOALL:     	  call void @llvm.lifetime.start.p0i8(i64 8, i8* %37)
DOALL:     	  %38 = bitcast i16** %6 to i8*
DOALL:     	  call void @llvm.lifetime.start.p0i8(i64 8, i8* %38)
DOALL:     	  %39 = bitcast i32* %7 to i8*
DOALL:     	  call void @llvm.lifetime.start.p0i8(i64 4, i8* %43)
DOALL:     	  %44 = bitcast i32* %12 to i8*
DOALL:     	  call void @llvm.lifetime.start.p0i8(i64 4, i8* %44)
DOALL:     	  %45 = bitcast i32* %13 to i8*
DOALL:     	  call void @llvm.lifetime.start.p0i8(i64 4, i8* %45)
DOALL:     	  %46 = bitcast i32* %14 to i8*
DOALL:     	  call void @llvm.lifetime.start.p0i8(i64 4, i8* %46)
DOALL:     	  br label %61
DOALL:     	  br label %78
DOALL:     	  br label %78
DOALL:     	  br label %92
DOALL:     	  br label %92
DOALL:     	  br label %96
DOALL:     	  br label %96
DOALL:     	  br label %110
DOALL:     	  br label %110
DOALL:     	  br label %147
DOALL:     	  br label %147
DOALL:     	  br label %148
DOALL:     	  br label %61
DOALL:     	  %167 = bitcast i8** %1 to i8*
DOALL:     	  call void @llvm.lifetime.end.p0i8(i64 8, i8* %167)
DOALL:     	  %168 = bitcast i16** %2 to i8*
DOALL:     	  call void @llvm.lifetime.end.p0i8(i64 8, i8* %168)
DOALL:     	  %169 = bitcast i32* %3 to i8*
DOALL:     	  call void @llvm.lifetime.end.p0i8(i64 4, i8* %169)
DOALL:     	  %170 = bitcast %struct.adpcm_state** %4 to i8*
DOALL:     	  call void @llvm.lifetime.end.p0i8(i64 8, i8* %170)
DOALL:     	  %171 = bitcast i8** %5 to i8*
DOALL:     	  call void @llvm.lifetime.end.p0i8(i64 8, i8* %171)
DOALL:     	  %172 = bitcast i16** %6 to i8*
DOALL:     	  call void @llvm.lifetime.end.p0i8(i64 8, i8* %172)
DOALL:     	  %173 = bitcast i32* %7 to i8*
DOALL:     	  call void @llvm.lifetime.end.p0i8(i64 4, i8* %173)
DOALL:     	  %174 = bitcast i32* %8 to i8*
DOALL:     	  call void @llvm.lifetime.end.p0i8(i64 4, i8* %174)
DOALL:     	  %175 = bitcast i32* %9 to i8*
DOALL:     	  call void @llvm.lifetime.end.p0i8(i64 4, i8* %175)
DOALL:     	  %176 = bitcast i32* %10 to i8*
DOALL:     	  call void @llvm.lifetime.end.p0i8(i64 4, i8* %176)
DOALL:     	  %177 = bitcast i32* %11 to i8*
DOALL:     	  call void @llvm.lifetime.end.p0i8(i64 4, i8* %177)
DOALL:     	  %178 = bitcast i32* %12 to i8*
DOALL:     	  call void @llvm.lifetime.end.p0i8(i64 4, i8* %178)
DOALL:     	  %179 = bitcast i32* %13 to i8*
DOALL:     	  call void @llvm.lifetime.end.p0i8(i64 4, i8* %179)
DOALL:     	  %180 = bitcast i32* %14 to i8*
DOALL:     	  call void @llvm.lifetime.end.p0i8(i64 4, i8* %180)
DOALL:     	  %181 = load i32, i32* %16, align 4
DOALL:     	  %182 = mul nsw i32 %181, 4
DOALL:     	  %183 = getelementptr [1000 x i16], [1000 x i16]* @sbuf, i64 0, i64 0
DOALL:     	  %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182)
DOALL:     	  br label %17
DOALL:     Edges: 646
DOALL:     Loop-carried data dependences
DOALL:         %73 = load i8, i8* %71, align 1 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:         %55 = load i8, i8* %54, align 2 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:         store i8 %164, i8* %166, align 2 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:         %51 = load i16, i16* %50, align 2 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:         store i16 %160, i16* %162, align 2 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:         store i8 %164, i8* %166, align 2 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:         store i16 %154, i16* %155, align 2 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:         store i16 %160, i16* %162, align 2 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:         store i16 %154, i16* %155, align 2 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:         store i8 %164, i8* %166, align 2 --->   %19 = call i32 (i32, i8*, i32, ...) bitcast (i32 (...)* @read to i32 (i32, i8*, i32, ...)*)(i32 0, i8* %18, i32 500) via memory
DOALL:         store i8 %164, i8* %166, align 2 --->   %51 = load i16, i16* %50, align 2 via memory
DOALL:         store i8 %164, i8* %166, align 2 --->   %19 = call i32 (i32, i8*, i32, ...) bitcast (i32 (...)* @read to i32 (i32, i8*, i32, ...)*)(i32 0, i8* %18, i32 500) via memory
DOALL:         store i8 %164, i8* %166, align 2 --->   %55 = load i8, i8* %54, align 2 via memory
DOALL:         store i8 %164, i8* %166, align 2 --->   store i16 %160, i16* %162, align 2 via memory
DOALL:         store i8 %164, i8* %166, align 2 --->   store i8 %164, i8* %166, align 2 via memory
DOALL:         %73 = load i8, i8* %71, align 1 --->   %19 = call i32 (i32, i8*, i32, ...) bitcast (i32 (...)* @read to i32 (i32, i8*, i32, ...)*)(i32 0, i8* %18, i32 500) via memory
DOALL:         store i16 %160, i16* %162, align 2 --->   %51 = load i16, i16* %50, align 2 via memory
DOALL:         store i16 %160, i16* %162, align 2 --->   %19 = call i32 (i32, i8*, i32, ...) bitcast (i32 (...)* @read to i32 (i32, i8*, i32, ...)*)(i32 0, i8* %18, i32 500) via memory
DOALL:         store i16 %160, i16* %162, align 2 --->   %19 = call i32 (i32, i8*, i32, ...) bitcast (i32 (...)* @read to i32 (i32, i8*, i32, ...)*)(i32 0, i8* %18, i32 500) via memory
DOALL:         store i16 %160, i16* %162, align 2 --->   %55 = load i8, i8* %54, align 2 via memory
DOALL:         store i16 %160, i16* %162, align 2 --->   store i8 %164, i8* %166, align 2 via memory
DOALL:         store i16 %160, i16* %162, align 2 --->   store i16 %160, i16* %162, align 2 via memory
DOALL:         store i16 %154, i16* %155, align 2 --->   store i16 %154, i16* %155, align 2 via memory
DOALL:         store i16 %154, i16* %155, align 2 --->   %19 = call i32 (i32, i8*, i32, ...) bitcast (i32 (...)* @read to i32 (i32, i8*, i32, ...)*)(i32 0, i8* %18, i32 500) via memory
DOALL:         store i16 %154, i16* %155, align 2 --->   %19 = call i32 (i32, i8*, i32, ...) bitcast (i32 (...)* @read to i32 (i32, i8*, i32, ...)*)(i32 0, i8* %18, i32 500) via memory
DOALL:         store i32 %19, i32* %16, align 4 --->   store i32 %19, i32* %16, align 4 via memory
DOALL:         %20 = load i32, i32* %16, align 4 --->   store i32 %19, i32* %16, align 4 via memory
DOALL:         %25 = load i32, i32* %16, align 4 --->   store i32 %19, i32* %16, align 4 via memory
DOALL:         %51 = load i16, i16* %50, align 2 --->   store i16 %160, i16* %162, align 2 via memory
DOALL:         %51 = load i16, i16* %50, align 2 --->   store i8 %164, i8* %166, align 2 via memory
DOALL:         %51 = load i16, i16* %50, align 2 --->   %19 = call i32 (i32, i8*, i32, ...) bitcast (i32 (...)* @read to i32 (i32, i8*, i32, ...)*)(i32 0, i8* %18, i32 500) via memory
DOALL:         %55 = load i8, i8* %54, align 2 --->   store i8 %164, i8* %166, align 2 via memory
DOALL:         %55 = load i8, i8* %54, align 2 --->   store i16 %160, i16* %162, align 2 via memory
DOALL:         %55 = load i8, i8* %54, align 2 --->   %19 = call i32 (i32, i8*, i32, ...) bitcast (i32 (...)* @read to i32 (i32, i8*, i32, ...)*)(i32 0, i8* %18, i32 500) via memory
DOALL:         store i8 %164, i8* %166, align 2 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:         store i8 %164, i8* %166, align 2 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:         %73 = load i8, i8* %71, align 1 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:         store i16 %160, i16* %162, align 2 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:         store i16 %160, i16* %162, align 2 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:         store i16 %154, i16* %155, align 2 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:         store i16 %154, i16* %155, align 2 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:         %51 = load i16, i16* %50, align 2 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL:         %55 = load i8, i8* %54, align 2 --->   %184 = call i32 (i32, i16*, i32, ...) bitcast (i32 (...)* @write to i32 (i32, i16*, i32, ...)*)(i32 1, i16* %183, i32 %182) via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
Inliner:   No remaining calls need to be inlined due to loop-carried data dependences
Inliner:   The code has not been modified
Inliner: Exit
Noelle:  Function "main"
Noelle:     Loop "  %18 = getelementptr [500 x i8], [500 x i8]* @abuf, i64 0, i64 0" (9.994261e+01%)
Noelle:     Loop "  %62 = load i32, i32* %3, align 4" (9.982741e+01%)
Noelle:  Function "adpcm_decoder"
Noelle:     Loop "  %34 = load i32, i32* %7, align 4" (5.736376e-02%)
Noelle:  Function "adpcm_coder"
Noelle:     Loop "  %36 = load i32, i32* %7, align 4" (0.000000e+00%)
Noelle:  Function "main"
Noelle:     Loop "  %18 = getelementptr [500 x i8], [500 x i8]* @abuf, i64 0, i64 0" (9.994261e+01%)
Noelle:     Loop "  %62 = load i32, i32* %3, align 4" (9.982741e+01%)
Noelle:  Function "adpcm_decoder"
Noelle:     Loop "  %34 = load i32, i32* %7, align 4" (5.736376e-02%)
Noelle:  Function "adpcm_coder"
Noelle:     Loop "  %36 = load i32, i32* %7, align 4" (0.000000e+00%)
NOELLE: FixedPoint: Exit
NOELLE: Inliner: Exit
noelle-simplification baseline_pre.bc -o baseline_pre.bc
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -tbaa -early-cse-memssa -licm -simplifycfg -simplifycfg-sink-common=false -instcombine -tailcallelim -loop-simplify -lcssa -licm -loop-unswitch -globalopt -instcombine -ipsccp -dce -gvn -dse -adce -loop-simplify -lcssa -indvars -loop-deletion -instcombine -indvars -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa --functionattrs --rpo-functionattrs baseline_pre.bc -o baseline_pre.bc
noelle-deadcode baseline_pre.bc baseline_pre.bc
NOELLE: DeadFunctions: Start
noelle-fixedpoint baseline_pre.bc baseline_pre.bc "noelle-load" -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DeadFunction.so -noelle-dfe
NOELLE: FixedPoint: Start
NOELLE: FixedPoint:   Loader: noelle-load
NOELLE: FixedPoint:   Options: -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DeadFunction.so -noelle-dfe
NOELLE: FixedPoint:   Input: baseline_pre.bc
NOELLE: FixedPoint:   Output: baseline_pre.bc
NOELLE: FixedPoint:   Temporary input: /tmp/tmp.sbGU7Aedp9 (.ll version is /tmp/tmp.22aPuUDLi3)
NOELLE: FixedPoint:   Temporary output: /tmp/tmp.ySIM5va9UK (.ll version is /tmp/tmp.gXXhLcHMaG)
NOELLE: FixedPoint:   Normalize the code
noelle-norm /tmp/tmp.sbGU7Aedp9 -o /tmp/tmp.ySIM5va9UK
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.sbGU7Aedp9 -o /tmp/tmp.ySIM5va9UK
NOELLE: FixedPoint:   Run until a fixed point is reached
NOELLE: FixedPoint:     Invocation 0
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DeadFunction.so -noelle-dfe /tmp/tmp.sbGU7Aedp9 -o /tmp/tmp.ySIM5va9UK
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DeadFunction.so -noelle-dfe /tmp/tmp.sbGU7Aedp9 -o /tmp/tmp.ySIM5va9UK
DeadFunctionEliminator: Start
DeadFunctionEliminator:   Inline functions that are invoked only by one call instruction and that do not escape into memory
DeadFunctionEliminator:   Get the islands
DeadFunctionEliminator:   Identify the islands reachable from the entry points
DeadFunctionEliminator:     Island
DeadFunctionEliminator:       main
DeadFunctionEliminator:       llvm.lifetime.end.p0i8
DeadFunctionEliminator:       perror
DeadFunctionEliminator:       exit
DeadFunctionEliminator:       fprintf
DeadFunctionEliminator:       llvm.lifetime.start.p0i8
DeadFunctionEliminator:   Identify the functions that can be deleted
DeadFunctionEliminator: Exit
Noelle:  Function "main"
Noelle:     Loop "  %18 = getelementptr [500 x i8], [500 x i8]* @abuf, i64 0, i64 0" (9.994261e+01%)
Noelle:     Loop "  %62 = load i32, i32* %3, align 4" (9.982741e+01%)
Noelle:  Function "adpcm_decoder"
Noelle:     Loop "  %34 = load i32, i32* %7, align 4" (5.736376e-02%)
Noelle:  Function "adpcm_coder"
Noelle:     Loop "  %36 = load i32, i32* %7, align 4" (0.000000e+00%)
Noelle:  Function "main"
Noelle:     Loop "  %18 = getelementptr [500 x i8], [500 x i8]* @abuf, i64 0, i64 0" (9.994261e+01%)
Noelle:     Loop "  %62 = load i32, i32* %3, align 4" (9.982741e+01%)
Noelle:  Function "adpcm_decoder"
Noelle:     Loop "  %34 = load i32, i32* %7, align 4" (5.736376e-02%)
Noelle:  Function "adpcm_coder"
Noelle:     Loop "  %36 = load i32, i32* %7, align 4" (0.000000e+00%)
NOELLE: FixedPoint: Exit
NOELLE: DeadFunctions: Exit
noelle-simplification baseline_pre.bc -o baseline_pre.bc
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -tbaa -early-cse-memssa -licm -simplifycfg -simplifycfg-sink-common=false -instcombine -tailcallelim -loop-simplify -lcssa -licm -loop-unswitch -globalopt -instcombine -ipsccp -dce -gvn -dse -adce -loop-simplify -lcssa -indvars -loop-deletion -instcombine -indvars -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa --functionattrs --rpo-functionattrs baseline_pre.bc -o baseline_pre.bc
noelle-enable baseline_pre.bc baseline_pre.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier
NOELLE: Enablers: Start
noelle-fixedpoint baseline_pre.bc baseline_pre.bc "noelle-parallel-load" -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier
NOELLE: FixedPoint: Start
NOELLE: FixedPoint:   Loader: noelle-parallel-load
NOELLE: FixedPoint:   Options: -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier
NOELLE: FixedPoint:   Input: baseline_pre.bc
NOELLE: FixedPoint:   Output: baseline_pre.bc
NOELLE: FixedPoint:   Temporary input: /tmp/tmp.lUI6KfZtqt (.ll version is /tmp/tmp.yaO7U2M7pJ)
NOELLE: FixedPoint:   Temporary output: /tmp/tmp.wVOe0E8RAI (.ll version is /tmp/tmp.0HkiQZd8Ov)
NOELLE: FixedPoint:   Normalize the code
noelle-norm /tmp/tmp.lUI6KfZtqt -o /tmp/tmp.wVOe0E8RAI
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.lUI6KfZtqt -o /tmp/tmp.wVOe0E8RAI
NOELLE: FixedPoint:   Run until a fixed point is reached
NOELLE: FixedPoint:     Invocation 0
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.lUI6KfZtqt -o /tmp/tmp.wVOe0E8RAI
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.lUI6KfZtqt -o /tmp/tmp.wVOe0E8RAI
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.lUI6KfZtqt -o /tmp/tmp.wVOe0E8RAI
EnablersManager: Start
Noelle: Filter out cold code
Noelle:  Function "main"
Noelle:     Loop "  %18 = getelementptr [500 x i8], [500 x i8]* @abuf, i64 0, i64 0" (9.994261e+01%)
Noelle:     Loop "  %62 = load i32, i32* %3, align 4" (9.982741e+01%)
EnablersManager:   Try to improve all 2 loops, one at a time
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %62 = load i32, i32* %3, align 4
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i32, align 4
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i32, align 4
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i32, align 4
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i32, align 4
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i16*, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %struct.adpcm_state*, align 8
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca i32, align 4
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca i8*, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca i8*, align 8
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i16*, align 8
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %62 = load i32, i32* %3, align 4"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %63, label %64, label %adpcm_decoder.exit, !prof !32
Mem2Reg:   The loop has 9SCCs that each one access the same memory location
Mem2Reg:     Loop invariant memory location:   %3 = alloca i32, align 4
Mem2Reg:     SCC:
Internal nodes: 6
	  %63 = icmp sgt i32 %62, 0
	  %62 = load i32, i32* %3, align 4
	  br i1 %63, label %64, label %adpcm_decoder.exit, !prof !32
	  %157 = load i32, i32* %3, align 4
	  %158 = add nsw i32 %157, -1
	  store i32 %158, i32* %3, align 4
External nodes: 60
	  %66 = icmp ne i32 %65, 0
	  br i1 %113, label %114, label %._crit_edge3.i, !prof !37
	  %120 = load i32, i32* %8, align 4
	  %121 = and i32 %120, 1
	  %122 = icmp ne i32 %121, 0
	  br i1 %122, label %123, label %._crit_edge4.i, !prof !38
	  %129 = load i32, i32* %7, align 4
	  %130 = icmp ne i32 %129, 0
	  br i1 %130, label %131, label %135, !prof !39
	  %140 = load i32, i32* %10, align 4
	  %141 = icmp sgt i32 %140, 32767
	  br i1 %141, label %142, label %143, !prof !40
	  %65 = load i32, i32* %14, align 4
	  br i1 %66, label %67, label %70, !prof !33
	  %79 = load i32, i32* %14, align 4
	  %80 = icmp ne i32 %79, 0
	  %81 = xor i1 %80, true
	  %82 = zext i1 %81 to i32
	  store i32 %82, i32* %14, align 4
	  %83 = load i32, i32* %8, align 4
	  %84 = sext i32 %83 to i64
	  %85 = getelementptr inbounds [16 x i32], [16 x i32]* @indexTable, i64 0, i64 %84
	  %86 = load i32, i32* %85, align 4
	  %87 = load i32, i32* %12, align 4
	  %88 = add nsw i32 %87, %86
	  store i32 %88, i32* %12, align 4
	  %89 = load i32, i32* %12, align 4
	  %90 = icmp slt i32 %89, 0
	  br i1 %90, label %91, label %._crit_edge.i, !prof !34
	  %93 = load i32, i32* %12, align 4
	  %94 = icmp sgt i32 %93, 88
	  br i1 %94, label %95, label %._crit_edge1.i, !prof !35
	  %97 = load i32, i32* %8, align 4
	  %98 = and i32 %97, 8
	  store i32 %98, i32* %7, align 4
	  %99 = load i32, i32* %8, align 4
	  %100 = and i32 %99, 7
	  store i32 %100, i32* %8, align 4
	  %101 = load i32, i32* %9, align 4
	  %102 = ashr i32 %101, 3
	  store i32 %102, i32* %11, align 4
	  %103 = load i32, i32* %8, align 4
	  %104 = and i32 %103, 4
	  %105 = icmp ne i32 %104, 0
	  br i1 %105, label %106, label %._crit_edge2.i, !prof !36
	  %111 = load i32, i32* %8, align 4
	  %112 = and i32 %111, 2
	  %113 = icmp ne i32 %112, 0
	  %149 = load i32, i32* %12, align 4
	  %150 = sext i32 %149 to i64
	  %151 = getelementptr inbounds [89 x i32], [89 x i32]* @stepsizeTable, i64 0, i64 %150
	  %152 = load i32, i32* %151, align 4
	  store i32 %152, i32* %9, align 4
	  %153 = load i32, i32* %10, align 4
	  %154 = trunc i32 %153 to i16
	  %155 = load i16*, i16** %6, align 8
	  %156 = getelementptr inbounds i16, i16* %155, i32 1
	  store i16* %156, i16** %6, align 8
	  store i16 %154, i16* %155, align 2
	  br label %61
Edges: 75

Mem2Reg:  Collecting and ordering memory loads/stores by basic block
Mem2Reg: Iterating basic blocks to determine last stored values
Mem2Reg: placeholder PHI required: label %62
Mem2Reg:  checking for last value entering block: label %62
Mem2Reg:  Last value entering block: label %62	  %63 = phi i32 
Mem2Reg:  checking for last value entering block: label %66
Mem2Reg:  Last value entering block: label %66	  %63 = phi i32 
Mem2Reg:  checking for last value entering block: label %69
Mem2Reg:  Last value entering block: label %69	  %63 = phi i32 
Mem2Reg:  checking for last value entering block: label %72
Mem2Reg:  Last value entering block: label %72	  %63 = phi i32 
Mem2Reg:  checking for last value entering block: label %80
Mem2Reg:  Last value entering block: label %80	  %81 = phi i32 [ %63, %72 ], [ %63, %69 ]
Mem2Reg:  checking for last value entering block: label %94
Mem2Reg:  Last value entering block: label %94	  %81 = phi i32 [ %63, %72 ], [ %63, %69 ]
Mem2Reg:  checking for last value entering block: label %._crit_edge.i
Mem2Reg:  Last value entering block: label %._crit_edge.i	  %81 = phi i32 [ %63, %72 ], [ %63, %69 ]
Mem2Reg:  checking for last value entering block: label %95
Mem2Reg:  Last value entering block: label %95	  %96 = phi i32 [ %81, %94 ], [ %81, %._crit_edge.i ]
Mem2Reg:  checking for last value entering block: label %99
Mem2Reg:  Last value entering block: label %99	  %96 = phi i32 [ %81, %94 ], [ %81, %._crit_edge.i ]
Mem2Reg:  checking for last value entering block: label %._crit_edge1.i
Mem2Reg:  Last value entering block: label %._crit_edge1.i	  %96 = phi i32 [ %81, %94 ], [ %81, %._crit_edge.i ]
Mem2Reg:  checking for last value entering block: label %100
Mem2Reg:  Last value entering block: label %100	  %101 = phi i32 [ %96, %99 ], [ %96, %._crit_edge1.i ]
Mem2Reg:  checking for last value entering block: label %111
Mem2Reg:  Last value entering block: label %111	  %101 = phi i32 [ %96, %99 ], [ %96, %._crit_edge1.i ]
Mem2Reg:  checking for last value entering block: label %._crit_edge2.i
Mem2Reg:  Last value entering block: label %._crit_edge2.i	  %101 = phi i32 [ %96, %99 ], [ %96, %._crit_edge1.i ]
Mem2Reg:  checking for last value entering block: label %115
Mem2Reg:  Last value entering block: label %115	  %116 = phi i32 [ %101, %111 ], [ %101, %._crit_edge2.i ]
Mem2Reg:  checking for last value entering block: label %120
Mem2Reg:  Last value entering block: label %120	  %116 = phi i32 [ %101, %111 ], [ %101, %._crit_edge2.i ]
Mem2Reg:  checking for last value entering block: label %._crit_edge3.i
Mem2Reg:  Last value entering block: label %._crit_edge3.i	  %116 = phi i32 [ %101, %111 ], [ %101, %._crit_edge2.i ]
Mem2Reg:  checking for last value entering block: label %125
Mem2Reg:  Last value entering block: label %125	  %126 = phi i32 [ %116, %120 ], [ %116, %._crit_edge3.i ]
Mem2Reg:  checking for last value entering block: label %130
Mem2Reg:  Last value entering block: label %130	  %126 = phi i32 [ %116, %120 ], [ %116, %._crit_edge3.i ]
Mem2Reg:  checking for last value entering block: label %._crit_edge4.i
Mem2Reg:  Last value entering block: label %._crit_edge4.i	  %126 = phi i32 [ %116, %120 ], [ %116, %._crit_edge3.i ]
Mem2Reg:  checking for last value entering block: label %135
Mem2Reg:  Last value entering block: label %135	  %136 = phi i32 [ %126, %130 ], [ %126, %._crit_edge4.i ]
Mem2Reg:  checking for last value entering block: label %139
Mem2Reg:  Last value entering block: label %139	  %136 = phi i32 [ %126, %130 ], [ %126, %._crit_edge4.i ]
Mem2Reg:  checking for last value entering block: label %143
Mem2Reg:  Last value entering block: label %143	  %136 = phi i32 [ %126, %130 ], [ %126, %._crit_edge4.i ]
Mem2Reg:  checking for last value entering block: label %147
Mem2Reg:  Last value entering block: label %147	  %148 = phi i32 [ %136, %143 ], [ %136, %139 ]
Mem2Reg:  checking for last value entering block: label %151
Mem2Reg:  Last value entering block: label %151	  %148 = phi i32 [ %136, %143 ], [ %136, %139 ]
Mem2Reg:  checking for last value entering block: label %152
Mem2Reg:  Last value entering block: label %152	  %148 = phi i32 [ %136, %143 ], [ %136, %139 ]
Mem2Reg: placeholder PHI required: label %157
Mem2Reg:  checking for last value entering block: label %157
Mem2Reg:  Last value entering block: label %157	  %158 = phi i32 
Mem2Reg:  Value updated:   %168 = add nsw i32 %158, -1
Mem2Reg:  checking for last value entering block: label %155
Mem2Reg:  Last value entering block: label %155	  %148 = phi i32 [ %136, %143 ], [ %136, %139 ]
Mem2Reg:  checking for last value entering block: label %._crit_edge5.i
Mem2Reg:  Last value entering block: label %._crit_edge5.i	  %148 = phi i32 [ %136, %143 ], [ %136, %139 ]
Mem2Reg:  checking for last value entering block: label %156
Mem2Reg:  Last value entering block: label %156	  %157 = phi i32 [ %148, %155 ], [ %148, %._crit_edge5.i ]
Mem2Reg:  Removing
  %64 = load i32, i32* %3, align 4
Mem2Reg:  Removing
  %167 = load i32, i32* %3, align 4
Mem2Reg:  Removing
  store i32 %167, i32* %3, align 4
Mem2Reg:       The memory location has been promoted
Mem2Reg: Exit
EnablersManager:       Loop invariants have been extracted
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %18 = getelementptr [500 x i8], [500 x i8]* @abuf, i64 0, i64 0
EnablersManager:     The current loop belongs to the function main , which has already been modified.
EnablersManager: Exit
Noelle:  Function "main"
Noelle:     Loop "  %18 = getelementptr [500 x i8], [500 x i8]* @abuf, i64 0, i64 0" (9.994261e+01%)
Noelle:     Loop "  %62 = load i32, i32* %3, align 4" (9.982741e+01%)
Noelle:  Function "adpcm_decoder"
Noelle:     Loop "  %34 = load i32, i32* %7, align 4" (5.736376e-02%)
Noelle:  Function "adpcm_coder"
Noelle:     Loop "  %36 = load i32, i32* %7, align 4" (0.000000e+00%)
Noelle:  Function "main"
Noelle:     Loop "  %18 = getelementptr [500 x i8], [500 x i8]* @abuf, i64 0, i64 0" (9.994656e+01%)
Noelle:     Loop "  %64 = icmp sgt i32 %63, 0" (9.983733e+01%)
Noelle:  Function "adpcm_decoder"
Noelle:     Loop "  %34 = load i32, i32* %7, align 4" (5.341129e-02%)
Noelle:  Function "adpcm_coder"
Noelle:     Loop "  %36 = load i32, i32* %7, align 4" (0.000000e+00%)
NOELLE: FixedPoint:       There are -1 different instructions and -4 different loop instructions
NOELLE: FixedPoint:       Normalize the code
noelle-norm /tmp/tmp.wVOe0E8RAI -o /tmp/tmp.wVOe0E8RAI
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.wVOe0E8RAI -o /tmp/tmp.wVOe0E8RAI
NOELLE: FixedPoint:     Invocation 1
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.lUI6KfZtqt -o /tmp/tmp.wVOe0E8RAI
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.lUI6KfZtqt -o /tmp/tmp.wVOe0E8RAI
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.lUI6KfZtqt -o /tmp/tmp.wVOe0E8RAI
EnablersManager: Start
Noelle: Filter out cold code
Noelle:  Function "main"
Noelle:     Loop "  %18 = getelementptr [500 x i8], [500 x i8]* @abuf, i64 0, i64 0" (9.994656e+01%)
Noelle:     Loop "  %64 = icmp sgt i32 %63, 0" (9.983635e+01%)
EnablersManager:   Try to improve all 2 loops, one at a time
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %64 = icmp sgt i32 %63, 0
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i32, align 4
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i32, align 4
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i32, align 4
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i16*, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i32, align 4
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca i8*, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca i8*, align 8
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %struct.adpcm_state*, align 8
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i16*, align 8
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %64 = icmp sgt i32 %63, 0"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %64, label %65, label %adpcm_decoder.exit, !prof !32
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %18 = getelementptr [500 x i8], [500 x i8]* @abuf, i64 0, i64 0
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca i32, align 4
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i32, align 4
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %14 = alloca i32, align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i32, align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %13 = alloca i32, align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %12 = alloca i32, align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %11 = alloca i32, align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca i32, align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca i32, align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i32, align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca i32, align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca i32, align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i16*, align 8
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %2 = alloca i16*, align 8 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i32, align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %7 = alloca i32, align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca i8*, align 8
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %1 = alloca i8*, align 8 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca i8*, align 8
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %5 = alloca i8*, align 8 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca i32, align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca i32, align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %struct.adpcm_state*, align 8
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca %struct.adpcm_state*, align 8 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i16*, align 8
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca i16*, align 8 can be cloned
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %18 = getelementptr [500 x i8], [500 x i8]* @abuf, i64 0, i64 0"
LICM:     Invariant = "  %176 = bitcast i8** %1 to i8*
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %177 = bitcast i16** %2 to i8*
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %178 = bitcast i32* %3 to i8*
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %179 = bitcast %struct.adpcm_state** %4 to i8*
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %180 = bitcast i8** %5 to i8*
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %181 = bitcast i16** %6 to i8*
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %182 = bitcast i32* %7 to i8*
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %183 = bitcast i32* %8 to i8*
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %184 = bitcast i32* %9 to i8*
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %185 = bitcast i32* %10 to i8*
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %186 = bitcast i32* %11 to i8*
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %187 = bitcast i32* %12 to i8*
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %188 = bitcast i32* %13 to i8*
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %189 = bitcast i32* %14 to i8*
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %192 = getelementptr [1000 x i16], [1000 x i16]* @sbuf, i64 0, i64 0
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %18 = getelementptr [500 x i8], [500 x i8]* @abuf, i64 0, i64 0
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %31 = bitcast i8** %1 to i8*
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %32 = bitcast i16** %2 to i8*
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %33 = bitcast i32* %3 to i8*
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %34 = bitcast %struct.adpcm_state** %4 to i8*
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %35 = bitcast i8** %5 to i8*
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %36 = bitcast i16** %6 to i8*
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %37 = bitcast i32* %7 to i8*
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %38 = bitcast i32* %8 to i8*
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %39 = bitcast i32* %9 to i8*
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %40 = bitcast i32* %10 to i8*
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %41 = bitcast i32* %11 to i8*
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %42 = bitcast i32* %12 to i8*
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %43 = bitcast i32* %13 to i8*
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %44 = bitcast i32* %14 to i8*
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %45 = getelementptr [500 x i8], [500 x i8]* @abuf, i64 0, i64 0
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  store i8* %45, i8** %1, align 8
LICM:       The instruction might generate unwanted side-effects if it does not execute at least once per loop invocation
LICM:     Invariant = "  %46 = getelementptr [1000 x i16], [1000 x i16]* @sbuf, i64 0, i64 0
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  store i16* %46, i16** %2, align 8
LICM:       The instruction might generate unwanted side-effects if it does not execute at least once per loop invocation
LICM:     Invariant = "  store %struct.adpcm_state* @state, %struct.adpcm_state** %4, align 8
LICM:       The instruction might generate unwanted side-effects if it does not execute at least once per loop invocation
LICM:     Invariant = "  store i32 0, i32* %14, align 4
LICM:       The instruction might generate unwanted side-effects if it does not execute at least once per loop invocation
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has been modified
LICM: Exit
EnablersManager:       Loop invariants have been extracted
EnablersManager: Exit
Noelle:  Function "main"
Noelle:     Loop "  %18 = getelementptr [500 x i8], [500 x i8]* @abuf, i64 0, i64 0" (9.994656e+01%)
Noelle:     Loop "  %64 = icmp sgt i32 %63, 0" (9.983635e+01%)
Noelle:  Function "adpcm_decoder"
Noelle:     Loop "  %34 = load i32, i32* %7, align 4" (5.341077e-02%)
Noelle:  Function "adpcm_coder"
Noelle:     Loop "  %36 = load i32, i32* %7, align 4" (0.000000e+00%)
Noelle:  Function "main"
Noelle:     Loop "  %50 = call i32 (i32, i8*, i32, ...) bitcast (i32 (...)* @read to i32 (i32, i8*, i32, ...)*)(i32 0, i8* %17, i32 500)" (9.994654e+01%)
Noelle:     Loop "  %79 = icmp sgt i32 %78, 0" (9.986780e+01%)
Noelle:  Function "adpcm_decoder"
Noelle:     Loop "  %34 = load i32, i32* %7, align 4" (5.342759e-02%)
Noelle:  Function "adpcm_coder"
Noelle:     Loop "  %36 = load i32, i32* %7, align 4" (0.000000e+00%)
NOELLE: FixedPoint:       There are 0 different instructions and -32 different loop instructions
NOELLE: FixedPoint:       Normalize the code
noelle-norm /tmp/tmp.wVOe0E8RAI -o /tmp/tmp.wVOe0E8RAI
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.wVOe0E8RAI -o /tmp/tmp.wVOe0E8RAI
NOELLE: FixedPoint:     Invocation 2
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.lUI6KfZtqt -o /tmp/tmp.wVOe0E8RAI
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.lUI6KfZtqt -o /tmp/tmp.wVOe0E8RAI
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.lUI6KfZtqt -o /tmp/tmp.wVOe0E8RAI
EnablersManager: Start
Noelle: Filter out cold code
Noelle:  Function "main"
Noelle:     Loop "  %50 = call i32 (i32, i8*, i32, ...) bitcast (i32 (...)* @read to i32 (i32, i8*, i32, ...)*)(i32 0, i8* %17, i32 500)" (9.994654e+01%)
Noelle:     Loop "  %79 = icmp sgt i32 %78, 0" (9.986780e+01%)
EnablersManager:   Try to improve all 2 loops, one at a time
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %79 = icmp sgt i32 %78, 0
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i32, align 4
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i32, align 4
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i32, align 4
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i16*, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i32, align 4
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca i8*, align 8
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca i8*, align 8
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca i32, align 4
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %struct.adpcm_state*, align 8
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i16*, align 8
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %79 = icmp sgt i32 %78, 0"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %79, label %80, label %adpcm_decoder.exit, !prof !32
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %50 = call i32 (i32, i8*, i32, ...) bitcast (i32 (...)* @read to i32 (i32, i8*, i32, ...)*)(i32 0, i8* %17, i32 500)
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca i32, align 4
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i32, align 4
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %14 = alloca i32, align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i32, align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %13 = alloca i32, align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %12 = alloca i32, align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %11 = alloca i32, align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca i32, align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca i32, align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i32, align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca i32, align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca i32, align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i16*, align 8
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %2 = alloca i16*, align 8 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i32, align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %7 = alloca i32, align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca i8*, align 8
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %1 = alloca i8*, align 8 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca i8*, align 8
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %5 = alloca i8*, align 8 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca i32, align 4
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca i32, align 4 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %struct.adpcm_state*, align 8
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca %struct.adpcm_state*, align 8 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i16*, align 8
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca i16*, align 8 can be cloned
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %50 = call i32 (i32, i8*, i32, ...) bitcast (i32 (...)* @read to i32 (i32, i8*, i32, ...)*)(i32 0, i8* %17, i32 500)"
LICM:     Invariant = "  store i8* %32, i8** %1, align 8
LICM:       The instruction might generate unwanted side-effects if it does not execute at least once per loop invocation
LICM:     Invariant = "  store i16* %33, i16** %2, align 8
LICM:       The instruction might generate unwanted side-effects if it does not execute at least once per loop invocation
LICM:     Invariant = "  store %struct.adpcm_state* @state, %struct.adpcm_state** %4, align 8
LICM:       The instruction might generate unwanted side-effects if it does not execute at least once per loop invocation
LICM:     Invariant = "  store i32 0, i32* %14, align 4
LICM:       The instruction might generate unwanted side-effects if it does not execute at least once per loop invocation
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %52, label %53, label %55, !prof !30
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager: Exit
Noelle:  Function "main"
Noelle:     Loop "  %50 = call i32 (i32, i8*, i32, ...) bitcast (i32 (...)* @read to i32 (i32, i8*, i32, ...)*)(i32 0, i8* %17, i32 500)" (9.994654e+01%)
Noelle:     Loop "  %79 = icmp sgt i32 %78, 0" (9.986780e+01%)
Noelle:  Function "adpcm_decoder"
Noelle:     Loop "  %34 = load i32, i32* %7, align 4" (5.342759e-02%)
Noelle:  Function "adpcm_coder"
Noelle:     Loop "  %36 = load i32, i32* %7, align 4" (0.000000e+00%)
Noelle:  Function "main"
Noelle:     Loop "  %50 = call i32 (i32, i8*, i32, ...) bitcast (i32 (...)* @read to i32 (i32, i8*, i32, ...)*)(i32 0, i8* %17, i32 500)" (9.994654e+01%)
Noelle:     Loop "  %79 = icmp sgt i32 %78, 0" (9.986780e+01%)
Noelle:  Function "adpcm_decoder"
Noelle:     Loop "  %34 = load i32, i32* %7, align 4" (5.342759e-02%)
Noelle:  Function "adpcm_coder"
Noelle:     Loop "  %36 = load i32, i32* %7, align 4" (0.000000e+00%)
NOELLE: FixedPoint: Exit
NOELLE: Enablers: Exit
noelle-simplification baseline_pre.bc -o baseline_pre.bc
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -tbaa -early-cse-memssa -licm -simplifycfg -simplifycfg-sink-common=false -instcombine -tailcallelim -loop-simplify -lcssa -licm -loop-unswitch -globalopt -instcombine -ipsccp -dce -gvn -dse -adce -loop-simplify -lcssa -indvars -loop-deletion -instcombine -indvars -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa --functionattrs --rpo-functionattrs baseline_pre.bc -o baseline_pre.bc
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CleanMetadata.so -CleanMetadata -clean-loop-metadata=true -clean-prof-metadata=true -clean-pdg-metadata=true baseline_pre.bc -o baseline_pre.bc
noelle/core/Clean Loop Metadata
noelle/core/Clean PDG Metadata
noelle/core/Clean profiler metadata
opt --strip-named-metadata baseline_pre.bc -o baseline_pre.bc
/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/rawdaudio /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/rawdaudio
WARNING: ./runme_rawdaudio.sh not found. Going up one dir.
Running: ./baseline_pre_prof < data/very_large.adpcm > output_very_large.pcm in /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/MiBench/telecomm/adpcm
Final valprev=0, index=0
--------------------------------------------------------------------------------------
/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/rawdaudio
DONE
opt -pgo-test-profile-file=/tmp/tmp.kgH1a45FmU -block-freq -pgo-instr-use baseline_pre.bc -o baseline_with_metadata.bc
noelle-load -PDGAnalysis -noelle-pdg-verbose=3 -noelle-pdg-embed baseline_with_metadata.bc -o baseline_with_metadata.bc
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -PDGAnalysis -noelle-pdg-verbose=3 -noelle-pdg-embed baseline_with_metadata.bc -o baseline_with_metadata.bc
PDGAnalysis: Construct PDG from Analysis
Embed PDG as metadata
noelle-parallelizer baseline_with_metadata.bc -o baseline_parallelized.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
noelle-meta-loop-embed baseline_with_metadata.bc -o afterLoopMetadata.bc
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopMetadata.so -LoopMetadata baseline_with_metadata.bc -o afterLoopMetadata.bc
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopMetadata.so -LoopMetadata baseline_with_metadata.bc -o afterLoopMetadata.bc
noelle-parallelization-planner afterLoopMetadata.bc -o baseline_with_parallel_plan.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Planner.so -planner afterLoopMetadata.bc -o baseline_with_parallel_plan.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Planner.so -planner afterLoopMetadata.bc -o baseline_with_parallel_plan.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Planner.so -planner afterLoopMetadata.bc -o baseline_with_parallel_plan.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
Planner: Start
Planner:  Fetching the program loops
Noelle: Filter out cold code
Noelle:  Function "main"
Noelle:     Loop "  %46 = getelementptr [500 x i8], [500 x i8]* @abuf, i64 0, i64 0, !noelle.pdg.inst.id !1024" (1.000000e+02%)
Noelle:     Loop "  %78 = icmp sgt i32 %77, 0, !noelle.pdg.inst.id !1061" (9.991728e+01%)
Noelle:  Function "adpcm_coder"
Noelle:  Disable "adpcm_coder" as cold function
Noelle:  Function "adpcm_decoder"
Noelle:  Disable "adpcm_decoder" as cold function
Planner:    There are 2 loops in the program we are going to consider
Planner:  Filter out loops not worth considering
Planner:  There are 1 loop nesting trees in the program
Planner:    ID: 0 (1)
Planner:      Function: "main"
Planner:      Loop: "  %46 = getelementptr [500 x i8], [500 x i8]* @abuf, i64 0, i64 0, !noelle.pdg.inst.id !1024"
Planner:      Loop nesting level: 1
Planner:      Hotness = 1.000000e+02 %
Planner:      Average instructions per invocation = 1.090293e+14 %
Planner:      Average iterations per invocation = 1.073742e+09 %
Planner:    
Planner:      ID: 1 (2)
Planner:        Function: "main"
Planner:        Loop: "  %78 = icmp sgt i32 %77, 0, !noelle.pdg.inst.id !1061"
Planner:        Loop nesting level: 2
Planner:        Hotness = 9.991728e+01 %
Planner:        Average instructions per invocation = 1.014575e+05 %
Planner:        Average iterations per invocation = 1.001000e+03 %
Planner:      
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca i32, align 4, !noelle.pdg.inst.id !994
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i32, align 4, !noelle.pdg.inst.id !993
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4, !noelle.pdg.inst.id !992
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %14 = alloca i32, align 4, !noelle.pdg.inst.id !992 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i32, align 4, !noelle.pdg.inst.id !991
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %13 = alloca i32, align 4, !noelle.pdg.inst.id !991 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4, !noelle.pdg.inst.id !990
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %12 = alloca i32, align 4, !noelle.pdg.inst.id !990 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4, !noelle.pdg.inst.id !989
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %11 = alloca i32, align 4, !noelle.pdg.inst.id !989 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca i32, align 4, !noelle.pdg.inst.id !988
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca i32, align 4, !noelle.pdg.inst.id !988 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i32, align 4, !noelle.pdg.inst.id !987
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca i32, align 4, !noelle.pdg.inst.id !987 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4, !noelle.pdg.inst.id !986
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca i32, align 4, !noelle.pdg.inst.id !986 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i32, align 4, !noelle.pdg.inst.id !985
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %7 = alloca i32, align 4, !noelle.pdg.inst.id !985 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i16*, align 8, !noelle.pdg.inst.id !980
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %2 = alloca i16*, align 8, !noelle.pdg.inst.id !980 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca i8*, align 8, !noelle.pdg.inst.id !979
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %1 = alloca i8*, align 8, !noelle.pdg.inst.id !979 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca i32, align 4, !noelle.pdg.inst.id !981
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca i32, align 4, !noelle.pdg.inst.id !981 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %struct.adpcm_state*, align 8, !noelle.pdg.inst.id !982
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca %struct.adpcm_state*, align 8, !noelle.pdg.inst.id !982 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca i8*, align 8, !noelle.pdg.inst.id !983
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %5 = alloca i8*, align 8, !noelle.pdg.inst.id !983 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i16*, align 8, !noelle.pdg.inst.id !984
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca i16*, align 8, !noelle.pdg.inst.id !984 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca i32, align 4, !noelle.pdg.inst.id !994
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i32, align 4, !noelle.pdg.inst.id !993
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4, !noelle.pdg.inst.id !992
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %14 = alloca i32, align 4, !noelle.pdg.inst.id !992 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i32, align 4, !noelle.pdg.inst.id !991
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %13 = alloca i32, align 4, !noelle.pdg.inst.id !991 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4, !noelle.pdg.inst.id !990
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %12 = alloca i32, align 4, !noelle.pdg.inst.id !990 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4, !noelle.pdg.inst.id !989
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %11 = alloca i32, align 4, !noelle.pdg.inst.id !989 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca i32, align 4, !noelle.pdg.inst.id !988
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca i32, align 4, !noelle.pdg.inst.id !988 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i32, align 4, !noelle.pdg.inst.id !987
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca i32, align 4, !noelle.pdg.inst.id !987 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4, !noelle.pdg.inst.id !986
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca i32, align 4, !noelle.pdg.inst.id !986 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i32, align 4, !noelle.pdg.inst.id !985
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %7 = alloca i32, align 4, !noelle.pdg.inst.id !985 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i16*, align 8, !noelle.pdg.inst.id !980
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %2 = alloca i16*, align 8, !noelle.pdg.inst.id !980 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca i8*, align 8, !noelle.pdg.inst.id !979
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %1 = alloca i8*, align 8, !noelle.pdg.inst.id !979 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca i32, align 4, !noelle.pdg.inst.id !981
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca i32, align 4, !noelle.pdg.inst.id !981 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %struct.adpcm_state*, align 8, !noelle.pdg.inst.id !982
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca %struct.adpcm_state*, align 8, !noelle.pdg.inst.id !982 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca i8*, align 8, !noelle.pdg.inst.id !983
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %5 = alloca i8*, align 8, !noelle.pdg.inst.id !983 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i16*, align 8, !noelle.pdg.inst.id !984
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca i16*, align 8, !noelle.pdg.inst.id !984 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca i32, align 4, !noelle.pdg.inst.id !994
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i32, align 4, !noelle.pdg.inst.id !993
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4, !noelle.pdg.inst.id !992
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i32, align 4, !noelle.pdg.inst.id !991
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4, !noelle.pdg.inst.id !990
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4, !noelle.pdg.inst.id !989
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca i32, align 4, !noelle.pdg.inst.id !988
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i32, align 4, !noelle.pdg.inst.id !987
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4, !noelle.pdg.inst.id !986
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i32, align 4, !noelle.pdg.inst.id !985
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i16*, align 8, !noelle.pdg.inst.id !980
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca i8*, align 8, !noelle.pdg.inst.id !979
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca i32, align 4, !noelle.pdg.inst.id !981
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %struct.adpcm_state*, align 8, !noelle.pdg.inst.id !982
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca i8*, align 8, !noelle.pdg.inst.id !983
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i16*, align 8, !noelle.pdg.inst.id !984
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca i32, align 4, !noelle.pdg.inst.id !994
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i32, align 4, !noelle.pdg.inst.id !993
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4, !noelle.pdg.inst.id !992
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i32, align 4, !noelle.pdg.inst.id !991
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4, !noelle.pdg.inst.id !990
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4, !noelle.pdg.inst.id !989
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca i32, align 4, !noelle.pdg.inst.id !988
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i32, align 4, !noelle.pdg.inst.id !987
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4, !noelle.pdg.inst.id !986
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i32, align 4, !noelle.pdg.inst.id !985
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i16*, align 8, !noelle.pdg.inst.id !980
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca i8*, align 8, !noelle.pdg.inst.id !979
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca i32, align 4, !noelle.pdg.inst.id !981
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %struct.adpcm_state*, align 8, !noelle.pdg.inst.id !982
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca i8*, align 8, !noelle.pdg.inst.id !983
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i16*, align 8, !noelle.pdg.inst.id !984
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
Planner: LoopSelector: Start
Planner: LoopSelector:   Order of loops and their maximum savings
Planner: LoopSelector:    Loop 1
Planner: LoopSelector:      Function: "main"
Planner: LoopSelector:      Loop nesting level: 2
Planner: LoopSelector:      "  %78 = icmp sgt i32 %77, 0, !noelle.pdg.inst.id !1061"
Planner: LoopSelector:      Coverage: 9.991728e+01%
Planner: LoopSelector:      Whole-program savings = 1.477228e+01%
Planner: LoopSelector:      Loop savings = 1.478452e+01%
Planner: LoopSelector:    Loop 0
Planner: LoopSelector:      Function: "main"
Planner: LoopSelector:      Loop nesting level: 1
Planner: LoopSelector:      "  %46 = getelementptr [500 x i8], [500 x i8]* @abuf, i64 0, i64 0, !noelle.pdg.inst.id !1024"
Planner: LoopSelector:      Coverage: 1.000000e+02%
Planner: LoopSelector:      Whole-program savings = 9.883643e+00%
Planner: LoopSelector:      Loop savings = 9.883643e+00%
Planner: LoopSelector: End
Planner:   Maximum time saved = 1.477228e+01% (16106122026633)
Planner:   Maximum time saved with DOALL only = 0.000000e+00% (0)
Planner: Exit
noelle-rm-function -function-name=SIMONE_CAMPANONI_IS_GOING_TO_REMOVE_THIS_FUNCTION code_with_prototypes.bc -o code_to_parallelize.bc
NOELLE: DeadFunctions: Start
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/RemoveFunction.so -noelle-rm-function -function-name=SIMONE_CAMPANONI_IS_GOING_TO_REMOVE_THIS_FUNCTION code_with_prototypes.bc -o code_to_parallelize.bc
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/RemoveFunction.so -noelle-rm-function -function-name=SIMONE_CAMPANONI_IS_GOING_TO_REMOVE_THIS_FUNCTION code_with_prototypes.bc -o code_to_parallelize.bc
RemoveFunction: Start
RemoveFunction:   Check if function "SIMONE_CAMPANONI_IS_GOING_TO_REMOVE_THIS_FUNCTION" exists
RemoveFunction:     The function exists
RemoveFunction:   Remove the function
RemoveFunction: Exit
NOELLE: DeadFunctions: Exit
noelle-parallelizer-loop code_to_parallelize.bc -o parallelized_unoptimized.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Parallelizer.so -parallelizer code_to_parallelize.bc -o parallelized_unoptimized.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Parallelizer.so -parallelizer code_to_parallelize.bc -o parallelized_unoptimized.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Parallelizer.so -parallelizer code_to_parallelize.bc -o parallelized_unoptimized.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
Parallelizer: Start
Parallelizer:  Analyzing the module code_to_parallelize.bc
Parallelizer:  Fetching the program loops
Noelle: Filter out cold code
Noelle:  Function "main"
Noelle:     Loop "  %46 = getelementptr [500 x i8], [500 x i8]* @abuf, i64 0, i64 0, !noelle.pdg.inst.id !1026" (1.000000e+02%)
Noelle:     Loop "  %78 = icmp sgt i32 %77, 0, !noelle.pdg.inst.id !1064" (9.991728e+01%)
Noelle:  Function "adpcm_decoder"
Noelle:  Disable "adpcm_decoder" as cold function
Noelle:  Function "adpcm_coder"
Noelle:  Disable "adpcm_coder" as cold function
Parallelizer:    There are 2 loops in the program we are going to consider
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca i32, align 4, !noelle.pdg.inst.id !996
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i32, align 4, !noelle.pdg.inst.id !995
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4, !noelle.pdg.inst.id !994
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %14 = alloca i32, align 4, !noelle.pdg.inst.id !994 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i32, align 4, !noelle.pdg.inst.id !993
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %13 = alloca i32, align 4, !noelle.pdg.inst.id !993 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4, !noelle.pdg.inst.id !992
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %12 = alloca i32, align 4, !noelle.pdg.inst.id !992 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4, !noelle.pdg.inst.id !991
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %11 = alloca i32, align 4, !noelle.pdg.inst.id !991 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca i32, align 4, !noelle.pdg.inst.id !990
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca i32, align 4, !noelle.pdg.inst.id !990 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i32, align 4, !noelle.pdg.inst.id !989
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca i32, align 4, !noelle.pdg.inst.id !989 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4, !noelle.pdg.inst.id !988
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca i32, align 4, !noelle.pdg.inst.id !988 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i32, align 4, !noelle.pdg.inst.id !987
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %7 = alloca i32, align 4, !noelle.pdg.inst.id !987 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i16*, align 8, !noelle.pdg.inst.id !982
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %2 = alloca i16*, align 8, !noelle.pdg.inst.id !982 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca i8*, align 8, !noelle.pdg.inst.id !981
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %1 = alloca i8*, align 8, !noelle.pdg.inst.id !981 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca i32, align 4, !noelle.pdg.inst.id !983
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca i32, align 4, !noelle.pdg.inst.id !983 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %struct.adpcm_state*, align 8, !noelle.pdg.inst.id !984
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca %struct.adpcm_state*, align 8, !noelle.pdg.inst.id !984 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca i8*, align 8, !noelle.pdg.inst.id !985
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %5 = alloca i8*, align 8, !noelle.pdg.inst.id !985 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i16*, align 8, !noelle.pdg.inst.id !986
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca i16*, align 8, !noelle.pdg.inst.id !986 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca i32, align 4, !noelle.pdg.inst.id !996
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i32, align 4, !noelle.pdg.inst.id !995
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4, !noelle.pdg.inst.id !994
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %14 = alloca i32, align 4, !noelle.pdg.inst.id !994 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i32, align 4, !noelle.pdg.inst.id !993
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %13 = alloca i32, align 4, !noelle.pdg.inst.id !993 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4, !noelle.pdg.inst.id !992
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %12 = alloca i32, align 4, !noelle.pdg.inst.id !992 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4, !noelle.pdg.inst.id !991
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %11 = alloca i32, align 4, !noelle.pdg.inst.id !991 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca i32, align 4, !noelle.pdg.inst.id !990
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca i32, align 4, !noelle.pdg.inst.id !990 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i32, align 4, !noelle.pdg.inst.id !989
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca i32, align 4, !noelle.pdg.inst.id !989 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4, !noelle.pdg.inst.id !988
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca i32, align 4, !noelle.pdg.inst.id !988 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i32, align 4, !noelle.pdg.inst.id !987
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %7 = alloca i32, align 4, !noelle.pdg.inst.id !987 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i16*, align 8, !noelle.pdg.inst.id !982
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %2 = alloca i16*, align 8, !noelle.pdg.inst.id !982 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca i8*, align 8, !noelle.pdg.inst.id !981
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %1 = alloca i8*, align 8, !noelle.pdg.inst.id !981 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca i32, align 4, !noelle.pdg.inst.id !983
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca i32, align 4, !noelle.pdg.inst.id !983 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %struct.adpcm_state*, align 8, !noelle.pdg.inst.id !984
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca %struct.adpcm_state*, align 8, !noelle.pdg.inst.id !984 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca i8*, align 8, !noelle.pdg.inst.id !985
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %5 = alloca i8*, align 8, !noelle.pdg.inst.id !985 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i16*, align 8, !noelle.pdg.inst.id !986
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca i16*, align 8, !noelle.pdg.inst.id !986 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca i32, align 4, !noelle.pdg.inst.id !996
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i32, align 4, !noelle.pdg.inst.id !995
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4, !noelle.pdg.inst.id !994
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i32, align 4, !noelle.pdg.inst.id !993
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4, !noelle.pdg.inst.id !992
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4, !noelle.pdg.inst.id !991
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca i32, align 4, !noelle.pdg.inst.id !990
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i32, align 4, !noelle.pdg.inst.id !989
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4, !noelle.pdg.inst.id !988
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i32, align 4, !noelle.pdg.inst.id !987
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i16*, align 8, !noelle.pdg.inst.id !982
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca i8*, align 8, !noelle.pdg.inst.id !981
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca i32, align 4, !noelle.pdg.inst.id !983
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %struct.adpcm_state*, align 8, !noelle.pdg.inst.id !984
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca i8*, align 8, !noelle.pdg.inst.id !985
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i16*, align 8, !noelle.pdg.inst.id !986
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca i32, align 4, !noelle.pdg.inst.id !996
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i32, align 4, !noelle.pdg.inst.id !995
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4, !noelle.pdg.inst.id !994
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i32, align 4, !noelle.pdg.inst.id !993
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4, !noelle.pdg.inst.id !992
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4, !noelle.pdg.inst.id !991
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca i32, align 4, !noelle.pdg.inst.id !990
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i32, align 4, !noelle.pdg.inst.id !989
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4, !noelle.pdg.inst.id !988
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i32, align 4, !noelle.pdg.inst.id !987
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i16*, align 8, !noelle.pdg.inst.id !982
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca i8*, align 8, !noelle.pdg.inst.id !981
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca i32, align 4, !noelle.pdg.inst.id !983
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %struct.adpcm_state*, align 8, !noelle.pdg.inst.id !984
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca i8*, align 8, !noelle.pdg.inst.id !985
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i16*, align 8, !noelle.pdg.inst.id !986
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "main"
Parallelizer: parallelizerLoop:   Loop 1 = "  %78 = icmp sgt i32 %77, 0, !noelle.pdg.inst.id !1064"
Parallelizer: parallelizerLoop:   Nesting level = 2
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %5 = alloca i8*, align 8, !noelle.pdg.inst.id !985
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %6 = alloca i16*, align 8, !noelle.pdg.inst.id !986
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %7 = alloca i32, align 4, !noelle.pdg.inst.id !987
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %8 = alloca i32, align 4, !noelle.pdg.inst.id !988
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %9 = alloca i32, align 4, !noelle.pdg.inst.id !989
Parallelizer: parallelizerLoop:   Environment:   Live-in 5 =   %10 = alloca i32, align 4, !noelle.pdg.inst.id !990
Parallelizer: parallelizerLoop:   Environment:   Live-in 6 =   %11 = alloca i32, align 4, !noelle.pdg.inst.id !991
Parallelizer: parallelizerLoop:   Environment:   Live-in 7 =   %12 = alloca i32, align 4, !noelle.pdg.inst.id !992
Parallelizer: parallelizerLoop:   Environment:   Live-in 8 =   %13 = alloca i32, align 4, !noelle.pdg.inst.id !993
Parallelizer: parallelizerLoop:   Environment:   Live-in 9 =   %14 = alloca i32, align 4, !noelle.pdg.inst.id !994
Parallelizer: parallelizerLoop:   Environment:   Live-in 10 =   %75 = load i32, i32* %3, !noelle.pdg.inst.id !334
Parallelizer: parallelizerLoop:   Environment:   Live-out 11 =   %77 = phi i32 [ %181, %171 ], [ %75, %56 ], !noelle.pdg.inst.id !1063
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "main"
Parallelizer: parallelizerLoop:   Loop 0 = "  %46 = getelementptr [500 x i8], [500 x i8]* @abuf, i64 0, i64 0, !noelle.pdg.inst.id !1026"
Parallelizer: parallelizerLoop:   Nesting level = 1
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %16 = alloca i32, align 4, !noelle.pdg.inst.id !996
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %17 = bitcast i8** %1 to i8*, !noelle.pdg.inst.id !997
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %18 = bitcast i16** %2 to i8*, !noelle.pdg.inst.id !998
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %19 = bitcast i32* %3 to i8*, !noelle.pdg.inst.id !999
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %20 = bitcast %struct.adpcm_state** %4 to i8*, !noelle.pdg.inst.id !1000
Parallelizer: parallelizerLoop:   Environment:   Live-in 5 =   %21 = bitcast i8** %5 to i8*, !noelle.pdg.inst.id !1001
Parallelizer: parallelizerLoop:   Environment:   Live-in 6 =   %22 = bitcast i16** %6 to i8*, !noelle.pdg.inst.id !1002
Parallelizer: parallelizerLoop:   Environment:   Live-in 7 =   %23 = bitcast i32* %7 to i8*, !noelle.pdg.inst.id !1003
Parallelizer: parallelizerLoop:   Environment:   Live-in 8 =   %24 = bitcast i32* %8 to i8*, !noelle.pdg.inst.id !1004
Parallelizer: parallelizerLoop:   Environment:   Live-in 9 =   %25 = bitcast i32* %9 to i8*, !noelle.pdg.inst.id !1005
Parallelizer: parallelizerLoop:   Environment:   Live-in 10 =   %26 = bitcast i32* %10 to i8*, !noelle.pdg.inst.id !1006
Parallelizer: parallelizerLoop:   Environment:   Live-in 11 =   %27 = bitcast i32* %11 to i8*, !noelle.pdg.inst.id !1007
Parallelizer: parallelizerLoop:   Environment:   Live-in 12 =   %28 = bitcast i32* %12 to i8*, !noelle.pdg.inst.id !1008
Parallelizer: parallelizerLoop:   Environment:   Live-in 13 =   %29 = bitcast i32* %13 to i8*, !noelle.pdg.inst.id !1009
Parallelizer: parallelizerLoop:   Environment:   Live-in 14 =   %30 = bitcast i32* %14 to i8*, !noelle.pdg.inst.id !1010
Parallelizer: parallelizerLoop:   Environment:   Live-in 15 =   %31 = bitcast i8** %1 to i8*, !noelle.pdg.inst.id !1011
Parallelizer: parallelizerLoop:   Environment:   Live-in 16 =   %32 = bitcast i16** %2 to i8*, !noelle.pdg.inst.id !1012
Parallelizer: parallelizerLoop:   Environment:   Live-in 17 =   %33 = bitcast i32* %3 to i8*, !noelle.pdg.inst.id !1013
Parallelizer: parallelizerLoop:   Environment:   Live-in 18 =   %34 = bitcast %struct.adpcm_state** %4 to i8*, !noelle.pdg.inst.id !1014
Parallelizer: parallelizerLoop:   Environment:   Live-in 19 =   %35 = bitcast i8** %5 to i8*, !noelle.pdg.inst.id !1015
Parallelizer: parallelizerLoop:   Environment:   Live-in 20 =   %36 = bitcast i16** %6 to i8*, !noelle.pdg.inst.id !1016
Parallelizer: parallelizerLoop:   Environment:   Live-in 21 =   %37 = bitcast i32* %7 to i8*, !noelle.pdg.inst.id !1017
Parallelizer: parallelizerLoop:   Environment:   Live-in 22 =   %38 = bitcast i32* %8 to i8*, !noelle.pdg.inst.id !1018
Parallelizer: parallelizerLoop:   Environment:   Live-in 23 =   %39 = bitcast i32* %9 to i8*, !noelle.pdg.inst.id !1019
Parallelizer: parallelizerLoop:   Environment:   Live-in 24 =   %40 = bitcast i32* %10 to i8*, !noelle.pdg.inst.id !1020
Parallelizer: parallelizerLoop:   Environment:   Live-in 25 =   %41 = bitcast i32* %11 to i8*, !noelle.pdg.inst.id !1021
Parallelizer: parallelizerLoop:   Environment:   Live-in 26 =   %42 = bitcast i32* %12 to i8*, !noelle.pdg.inst.id !1022
Parallelizer: parallelizerLoop:   Environment:   Live-in 27 =   %43 = bitcast i32* %13 to i8*, !noelle.pdg.inst.id !1023
Parallelizer: parallelizerLoop:   Environment:   Live-in 28 =   %44 = bitcast i32* %14 to i8*, !noelle.pdg.inst.id !1024
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: Exit
noelle-meta-clean parallelized_unoptimized.bc parallelized_unoptimized.bc
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CleanMetadata.so -CleanMetadata -clean-loop-metadata=true -clean-prof-metadata=true -clean-pdg-metadata=true parallelized_unoptimized.bc -o parallelized_unoptimized.bc
noelle/core/Clean Loop Metadata
noelle/core/Clean PDG Metadata
noelle/core/Clean profiler metadata
opt --strip-named-metadata parallelized_unoptimized.bc -o parallelized_unoptimized.bc
clang -O3 -c -emit-llvm parallelized_unoptimized.bc -o baseline_parallelized.bc
clang -O3 -c -emit-llvm baseline_parallelized.bc -o baseline_parallelized.bc
cp baseline_parallelized.bc rawdaudio.bc
make[1]: Leaving directory '/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/rawdaudio'
