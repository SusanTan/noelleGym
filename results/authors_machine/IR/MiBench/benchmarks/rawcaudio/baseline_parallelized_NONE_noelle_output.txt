make[1]: Entering directory '/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/rawcaudio'
./runEnablers.sh rawcaudio rawcaudio.bc large "-lm -lstdc++ -lpthread -ltermcap" -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier
/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/rawcaudio /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/rawcaudio
Cloning https://github.com/scampanoni/virgil.git
Cloning into 'threadpool'...
/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/rawcaudio
The IR has already been transformed for enabling parallelization
noelle-parallelizer baseline_with_metadata.bc -o baseline_parallelized.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
noelle-meta-loop-embed baseline_with_metadata.bc -o afterLoopMetadata.bc
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopMetadata.so -LoopMetadata baseline_with_metadata.bc -o afterLoopMetadata.bc
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopMetadata.so -LoopMetadata baseline_with_metadata.bc -o afterLoopMetadata.bc
noelle-parallelization-planner afterLoopMetadata.bc -o baseline_with_parallel_plan.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Planner.so -planner afterLoopMetadata.bc -o baseline_with_parallel_plan.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Planner.so -planner afterLoopMetadata.bc -o baseline_with_parallel_plan.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Planner.so -planner afterLoopMetadata.bc -o baseline_with_parallel_plan.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
Planner: Start
Planner:  Fetching the program loops
Noelle: Filter out cold code
Noelle:  Function "main"
Noelle:     Loop "  %53 = getelementptr [1000 x i16], [1000 x i16]* @sbuf, i64 0, i64 0, !noelle.pdg.inst.id !1446" (1.000000e+02%)
Noelle:     Loop "  %86 = icmp sgt i32 %84, 0, !noelle.pdg.inst.id !1486" (9.993149e+01%)
Noelle:  Function "adpcm_coder"
Noelle:  Disable "adpcm_coder" as cold function
Noelle:  Function "adpcm_decoder"
Noelle:  Disable "adpcm_decoder" as cold function
Planner:    There are 2 loops in the program we are going to consider
Planner:  Filter out loops not worth considering
Planner:  There are 1 loop nesting trees in the program
Planner:    ID: 0 (1)
Planner:      Function: "main"
Planner:      Loop: "  %53 = getelementptr [1000 x i16], [1000 x i16]* @sbuf, i64 0, i64 0, !noelle.pdg.inst.id !1446"
Planner:      Loop nesting level: 1
Planner:      Hotness = 1.000000e+02 %
Planner:      Average instructions per invocation = 1.473242e+14 %
Planner:      Average iterations per invocation = 1.073742e+09 %
Planner:    
Planner:      ID: 1 (2)
Planner:        Function: "main"
Planner:        Loop: "  %86 = icmp sgt i32 %84, 0, !noelle.pdg.inst.id !1486"
Planner:        Loop nesting level: 2
Planner:        Hotness = 9.993149e+01 %
Planner:        Average instructions per invocation = 1.371123e+05 %
Planner:        Average iterations per invocation = 1.001000e+03 %
Planner:      
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca i32, align 4, !noelle.pdg.inst.id !1412
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca i32, align 4, !noelle.pdg.inst.id !1411
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i8*, align 8, !noelle.pdg.inst.id !1400
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca i8*, align 8, !noelle.pdg.inst.id !1400 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca i16*, align 8, !noelle.pdg.inst.id !1399
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %5 = alloca i16*, align 8, !noelle.pdg.inst.id !1399 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %struct.adpcm_state*, align 8, !noelle.pdg.inst.id !1398
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca %struct.adpcm_state*, align 8, !noelle.pdg.inst.id !1398 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca i32, align 4, !noelle.pdg.inst.id !1397
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca i32, align 4, !noelle.pdg.inst.id !1397 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca i16*, align 8, !noelle.pdg.inst.id !1395
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %1 = alloca i16*, align 8, !noelle.pdg.inst.id !1395 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i8*, align 8, !noelle.pdg.inst.id !1396
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %2 = alloca i8*, align 8, !noelle.pdg.inst.id !1396 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i32, align 4, !noelle.pdg.inst.id !1401
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %7 = alloca i32, align 4, !noelle.pdg.inst.id !1401 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4, !noelle.pdg.inst.id !1402
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca i32, align 4, !noelle.pdg.inst.id !1402 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i32, align 4, !noelle.pdg.inst.id !1403
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca i32, align 4, !noelle.pdg.inst.id !1403 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca i32, align 4, !noelle.pdg.inst.id !1404
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca i32, align 4, !noelle.pdg.inst.id !1404 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4, !noelle.pdg.inst.id !1405
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %11 = alloca i32, align 4, !noelle.pdg.inst.id !1405 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4, !noelle.pdg.inst.id !1406
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %12 = alloca i32, align 4, !noelle.pdg.inst.id !1406 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i32, align 4, !noelle.pdg.inst.id !1407
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %13 = alloca i32, align 4, !noelle.pdg.inst.id !1407 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4, !noelle.pdg.inst.id !1408
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %14 = alloca i32, align 4, !noelle.pdg.inst.id !1408 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i32, align 4, !noelle.pdg.inst.id !1409
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %15 = alloca i32, align 4, !noelle.pdg.inst.id !1409 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca i32, align 4, !noelle.pdg.inst.id !1410
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %16 = alloca i32, align 4, !noelle.pdg.inst.id !1410 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca i32, align 4, !noelle.pdg.inst.id !1412
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca i32, align 4, !noelle.pdg.inst.id !1411
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i8*, align 8, !noelle.pdg.inst.id !1400
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca i8*, align 8, !noelle.pdg.inst.id !1400 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca i16*, align 8, !noelle.pdg.inst.id !1399
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %5 = alloca i16*, align 8, !noelle.pdg.inst.id !1399 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %struct.adpcm_state*, align 8, !noelle.pdg.inst.id !1398
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca %struct.adpcm_state*, align 8, !noelle.pdg.inst.id !1398 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca i32, align 4, !noelle.pdg.inst.id !1397
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca i32, align 4, !noelle.pdg.inst.id !1397 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca i16*, align 8, !noelle.pdg.inst.id !1395
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %1 = alloca i16*, align 8, !noelle.pdg.inst.id !1395 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i8*, align 8, !noelle.pdg.inst.id !1396
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %2 = alloca i8*, align 8, !noelle.pdg.inst.id !1396 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i32, align 4, !noelle.pdg.inst.id !1401
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %7 = alloca i32, align 4, !noelle.pdg.inst.id !1401 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4, !noelle.pdg.inst.id !1402
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca i32, align 4, !noelle.pdg.inst.id !1402 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i32, align 4, !noelle.pdg.inst.id !1403
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca i32, align 4, !noelle.pdg.inst.id !1403 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca i32, align 4, !noelle.pdg.inst.id !1404
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca i32, align 4, !noelle.pdg.inst.id !1404 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4, !noelle.pdg.inst.id !1405
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %11 = alloca i32, align 4, !noelle.pdg.inst.id !1405 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4, !noelle.pdg.inst.id !1406
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %12 = alloca i32, align 4, !noelle.pdg.inst.id !1406 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i32, align 4, !noelle.pdg.inst.id !1407
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %13 = alloca i32, align 4, !noelle.pdg.inst.id !1407 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4, !noelle.pdg.inst.id !1408
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %14 = alloca i32, align 4, !noelle.pdg.inst.id !1408 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i32, align 4, !noelle.pdg.inst.id !1409
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %15 = alloca i32, align 4, !noelle.pdg.inst.id !1409 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca i32, align 4, !noelle.pdg.inst.id !1410
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %16 = alloca i32, align 4, !noelle.pdg.inst.id !1410 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca i32, align 4, !noelle.pdg.inst.id !1412
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca i32, align 4, !noelle.pdg.inst.id !1411
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i8*, align 8, !noelle.pdg.inst.id !1400
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca i16*, align 8, !noelle.pdg.inst.id !1399
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %struct.adpcm_state*, align 8, !noelle.pdg.inst.id !1398
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca i32, align 4, !noelle.pdg.inst.id !1397
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca i16*, align 8, !noelle.pdg.inst.id !1395
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i8*, align 8, !noelle.pdg.inst.id !1396
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i32, align 4, !noelle.pdg.inst.id !1401
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4, !noelle.pdg.inst.id !1402
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i32, align 4, !noelle.pdg.inst.id !1403
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca i32, align 4, !noelle.pdg.inst.id !1404
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4, !noelle.pdg.inst.id !1405
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4, !noelle.pdg.inst.id !1406
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i32, align 4, !noelle.pdg.inst.id !1407
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4, !noelle.pdg.inst.id !1408
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i32, align 4, !noelle.pdg.inst.id !1409
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca i32, align 4, !noelle.pdg.inst.id !1410
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca i32, align 4, !noelle.pdg.inst.id !1412
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca i32, align 4, !noelle.pdg.inst.id !1411
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i8*, align 8, !noelle.pdg.inst.id !1400
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca i16*, align 8, !noelle.pdg.inst.id !1399
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %struct.adpcm_state*, align 8, !noelle.pdg.inst.id !1398
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca i32, align 4, !noelle.pdg.inst.id !1397
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca i16*, align 8, !noelle.pdg.inst.id !1395
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i8*, align 8, !noelle.pdg.inst.id !1396
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i32, align 4, !noelle.pdg.inst.id !1401
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4, !noelle.pdg.inst.id !1402
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i32, align 4, !noelle.pdg.inst.id !1403
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca i32, align 4, !noelle.pdg.inst.id !1404
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4, !noelle.pdg.inst.id !1405
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4, !noelle.pdg.inst.id !1406
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i32, align 4, !noelle.pdg.inst.id !1407
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4, !noelle.pdg.inst.id !1408
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i32, align 4, !noelle.pdg.inst.id !1409
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca i32, align 4, !noelle.pdg.inst.id !1410
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
Planner: LoopSelector: Start
Planner: LoopSelector:   Order of loops and their maximum savings
Planner: LoopSelector:    Loop 1
Planner: LoopSelector:      Function: "main"
Planner: LoopSelector:      Loop nesting level: 2
Planner: LoopSelector:      "  %86 = icmp sgt i32 %84, 0, !noelle.pdg.inst.id !1486"
Planner: LoopSelector:      Coverage: 9.993149e+01%
Planner: LoopSelector:      Whole-program savings = 2.004353e+01%
Planner: LoopSelector:      Loop savings = 2.005727e+01%
Planner: LoopSelector:    Loop 0
Planner: LoopSelector:      Function: "main"
Planner: LoopSelector:      Loop nesting level: 1
Planner: LoopSelector:      "  %53 = getelementptr [1000 x i16], [1000 x i16]* @sbuf, i64 0, i64 0, !noelle.pdg.inst.id !1446"
Planner: LoopSelector:      Coverage: 1.000000e+02%
Planner: LoopSelector:      Whole-program savings = 8.775831e+00%
Planner: LoopSelector:      Loop savings = 8.775831e+00%
Planner: LoopSelector: End
Planner:   Maximum time saved = 2.004353e+01% (29528964120644)
Planner:   Maximum time saved with DOALL only = 0.000000e+00% (0)
Planner: Exit
noelle-rm-function -function-name=SIMONE_CAMPANONI_IS_GOING_TO_REMOVE_THIS_FUNCTION code_with_prototypes.bc -o code_to_parallelize.bc
NOELLE: DeadFunctions: Start
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/RemoveFunction.so -noelle-rm-function -function-name=SIMONE_CAMPANONI_IS_GOING_TO_REMOVE_THIS_FUNCTION code_with_prototypes.bc -o code_to_parallelize.bc
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/RemoveFunction.so -noelle-rm-function -function-name=SIMONE_CAMPANONI_IS_GOING_TO_REMOVE_THIS_FUNCTION code_with_prototypes.bc -o code_to_parallelize.bc
RemoveFunction: Start
RemoveFunction:   Check if function "SIMONE_CAMPANONI_IS_GOING_TO_REMOVE_THIS_FUNCTION" exists
RemoveFunction:     The function exists
RemoveFunction:   Remove the function
RemoveFunction: Exit
NOELLE: DeadFunctions: Exit
noelle-parallelizer-loop code_to_parallelize.bc -o parallelized_unoptimized.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Parallelizer.so -parallelizer code_to_parallelize.bc -o parallelized_unoptimized.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Parallelizer.so -parallelizer code_to_parallelize.bc -o parallelized_unoptimized.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Parallelizer.so -parallelizer code_to_parallelize.bc -o parallelized_unoptimized.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
Parallelizer: Start
Parallelizer:  Analyzing the module code_to_parallelize.bc
Parallelizer:  Fetching the program loops
Noelle: Filter out cold code
Noelle:  Function "main"
Noelle:     Loop "  %53 = getelementptr [1000 x i16], [1000 x i16]* @sbuf, i64 0, i64 0, !noelle.pdg.inst.id !1448" (1.000000e+02%)
Noelle:     Loop "  %86 = icmp sgt i32 %84, 0, !noelle.pdg.inst.id !1489" (9.993149e+01%)
Noelle:  Function "adpcm_decoder"
Noelle:  Disable "adpcm_decoder" as cold function
Noelle:  Function "adpcm_coder"
Noelle:  Disable "adpcm_coder" as cold function
Parallelizer:    There are 2 loops in the program we are going to consider
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca i32, align 4, !noelle.pdg.inst.id !1414
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca i32, align 4, !noelle.pdg.inst.id !1413
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i8*, align 8, !noelle.pdg.inst.id !1402
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca i8*, align 8, !noelle.pdg.inst.id !1402 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca i16*, align 8, !noelle.pdg.inst.id !1401
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %5 = alloca i16*, align 8, !noelle.pdg.inst.id !1401 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %struct.adpcm_state*, align 8, !noelle.pdg.inst.id !1400
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca %struct.adpcm_state*, align 8, !noelle.pdg.inst.id !1400 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca i32, align 4, !noelle.pdg.inst.id !1399
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca i32, align 4, !noelle.pdg.inst.id !1399 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca i16*, align 8, !noelle.pdg.inst.id !1397
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %1 = alloca i16*, align 8, !noelle.pdg.inst.id !1397 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i8*, align 8, !noelle.pdg.inst.id !1398
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %2 = alloca i8*, align 8, !noelle.pdg.inst.id !1398 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i32, align 4, !noelle.pdg.inst.id !1403
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %7 = alloca i32, align 4, !noelle.pdg.inst.id !1403 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4, !noelle.pdg.inst.id !1404
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca i32, align 4, !noelle.pdg.inst.id !1404 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i32, align 4, !noelle.pdg.inst.id !1405
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca i32, align 4, !noelle.pdg.inst.id !1405 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca i32, align 4, !noelle.pdg.inst.id !1406
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca i32, align 4, !noelle.pdg.inst.id !1406 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4, !noelle.pdg.inst.id !1407
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %11 = alloca i32, align 4, !noelle.pdg.inst.id !1407 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4, !noelle.pdg.inst.id !1408
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %12 = alloca i32, align 4, !noelle.pdg.inst.id !1408 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i32, align 4, !noelle.pdg.inst.id !1409
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %13 = alloca i32, align 4, !noelle.pdg.inst.id !1409 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4, !noelle.pdg.inst.id !1410
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %14 = alloca i32, align 4, !noelle.pdg.inst.id !1410 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i32, align 4, !noelle.pdg.inst.id !1411
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %15 = alloca i32, align 4, !noelle.pdg.inst.id !1411 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca i32, align 4, !noelle.pdg.inst.id !1412
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %16 = alloca i32, align 4, !noelle.pdg.inst.id !1412 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca i32, align 4, !noelle.pdg.inst.id !1414
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca i32, align 4, !noelle.pdg.inst.id !1413
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i8*, align 8, !noelle.pdg.inst.id !1402
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %6 = alloca i8*, align 8, !noelle.pdg.inst.id !1402 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca i16*, align 8, !noelle.pdg.inst.id !1401
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %5 = alloca i16*, align 8, !noelle.pdg.inst.id !1401 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %struct.adpcm_state*, align 8, !noelle.pdg.inst.id !1400
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca %struct.adpcm_state*, align 8, !noelle.pdg.inst.id !1400 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca i32, align 4, !noelle.pdg.inst.id !1399
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca i32, align 4, !noelle.pdg.inst.id !1399 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca i16*, align 8, !noelle.pdg.inst.id !1397
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %1 = alloca i16*, align 8, !noelle.pdg.inst.id !1397 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i8*, align 8, !noelle.pdg.inst.id !1398
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %2 = alloca i8*, align 8, !noelle.pdg.inst.id !1398 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i32, align 4, !noelle.pdg.inst.id !1403
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %7 = alloca i32, align 4, !noelle.pdg.inst.id !1403 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4, !noelle.pdg.inst.id !1404
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %8 = alloca i32, align 4, !noelle.pdg.inst.id !1404 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i32, align 4, !noelle.pdg.inst.id !1405
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %9 = alloca i32, align 4, !noelle.pdg.inst.id !1405 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca i32, align 4, !noelle.pdg.inst.id !1406
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %10 = alloca i32, align 4, !noelle.pdg.inst.id !1406 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4, !noelle.pdg.inst.id !1407
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %11 = alloca i32, align 4, !noelle.pdg.inst.id !1407 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4, !noelle.pdg.inst.id !1408
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %12 = alloca i32, align 4, !noelle.pdg.inst.id !1408 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i32, align 4, !noelle.pdg.inst.id !1409
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %13 = alloca i32, align 4, !noelle.pdg.inst.id !1409 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4, !noelle.pdg.inst.id !1410
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %14 = alloca i32, align 4, !noelle.pdg.inst.id !1410 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i32, align 4, !noelle.pdg.inst.id !1411
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %15 = alloca i32, align 4, !noelle.pdg.inst.id !1411 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca i32, align 4, !noelle.pdg.inst.id !1412
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %16 = alloca i32, align 4, !noelle.pdg.inst.id !1412 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca i32, align 4, !noelle.pdg.inst.id !1414
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca i32, align 4, !noelle.pdg.inst.id !1413
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i8*, align 8, !noelle.pdg.inst.id !1402
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca i16*, align 8, !noelle.pdg.inst.id !1401
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %struct.adpcm_state*, align 8, !noelle.pdg.inst.id !1400
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca i32, align 4, !noelle.pdg.inst.id !1399
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca i16*, align 8, !noelle.pdg.inst.id !1397
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i8*, align 8, !noelle.pdg.inst.id !1398
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i32, align 4, !noelle.pdg.inst.id !1403
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4, !noelle.pdg.inst.id !1404
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i32, align 4, !noelle.pdg.inst.id !1405
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca i32, align 4, !noelle.pdg.inst.id !1406
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4, !noelle.pdg.inst.id !1407
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4, !noelle.pdg.inst.id !1408
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i32, align 4, !noelle.pdg.inst.id !1409
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4, !noelle.pdg.inst.id !1410
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i32, align 4, !noelle.pdg.inst.id !1411
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca i32, align 4, !noelle.pdg.inst.id !1412
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %18 = alloca i32, align 4, !noelle.pdg.inst.id !1414
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %17 = alloca i32, align 4, !noelle.pdg.inst.id !1413
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %6 = alloca i8*, align 8, !noelle.pdg.inst.id !1402
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %5 = alloca i16*, align 8, !noelle.pdg.inst.id !1401
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca %struct.adpcm_state*, align 8, !noelle.pdg.inst.id !1400
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca i32, align 4, !noelle.pdg.inst.id !1399
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %1 = alloca i16*, align 8, !noelle.pdg.inst.id !1397
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca i8*, align 8, !noelle.pdg.inst.id !1398
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %7 = alloca i32, align 4, !noelle.pdg.inst.id !1403
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %8 = alloca i32, align 4, !noelle.pdg.inst.id !1404
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %9 = alloca i32, align 4, !noelle.pdg.inst.id !1405
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %10 = alloca i32, align 4, !noelle.pdg.inst.id !1406
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %11 = alloca i32, align 4, !noelle.pdg.inst.id !1407
ClonableMemoryObject:   There are RAW memory data dependences between loop iterations
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %12 = alloca i32, align 4, !noelle.pdg.inst.id !1408
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %13 = alloca i32, align 4, !noelle.pdg.inst.id !1409
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %14 = alloca i32, align 4, !noelle.pdg.inst.id !1410
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %15 = alloca i32, align 4, !noelle.pdg.inst.id !1411
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %16 = alloca i32, align 4, !noelle.pdg.inst.id !1412
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "main"
Parallelizer: parallelizerLoop:   Loop 1 = "  %86 = icmp sgt i32 %84, 0, !noelle.pdg.inst.id !1489"
Parallelizer: parallelizerLoop:   Nesting level = 2
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %5 = alloca i16*, align 8, !noelle.pdg.inst.id !1401
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %6 = alloca i8*, align 8, !noelle.pdg.inst.id !1402
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %7 = alloca i32, align 4, !noelle.pdg.inst.id !1403
Parallelizer: parallelizerLoop:   Environment:   Live-in 5 =   %8 = alloca i32, align 4, !noelle.pdg.inst.id !1404
Parallelizer: parallelizerLoop:   Environment:   Live-in 6 =   %9 = alloca i32, align 4, !noelle.pdg.inst.id !1405
Parallelizer: parallelizerLoop:   Environment:   Live-in 7 =   %10 = alloca i32, align 4, !noelle.pdg.inst.id !1406
Parallelizer: parallelizerLoop:   Environment:   Live-in 8 =   %11 = alloca i32, align 4, !noelle.pdg.inst.id !1407
Parallelizer: parallelizerLoop:   Environment:   Live-in 9 =   %12 = alloca i32, align 4, !noelle.pdg.inst.id !1408
Parallelizer: parallelizerLoop:   Environment:   Live-in 10 =   %13 = alloca i32, align 4, !noelle.pdg.inst.id !1409
Parallelizer: parallelizerLoop:   Environment:   Live-in 11 =   %14 = alloca i32, align 4, !noelle.pdg.inst.id !1410
Parallelizer: parallelizerLoop:   Environment:   Live-in 12 =   %16 = alloca i32, align 4, !noelle.pdg.inst.id !1412
Parallelizer: parallelizerLoop:   Environment:   Live-in 13 =   %35 = load i32, i32* %15, !noelle.pdg.inst.id !158
Parallelizer: parallelizerLoop:   Environment:   Live-in 14 =   %82 = load i32, i32* %3, !noelle.pdg.inst.id !653
Parallelizer: parallelizerLoop:   Environment:   Live-out 0 =   %85 = phi i32 [ %219, %217 ], [ %35, %63 ], !noelle.pdg.inst.id !1488
Parallelizer: parallelizerLoop:   Environment:   Live-out 1 =   %84 = phi i32 [ %224, %217 ], [ %82, %63 ], !noelle.pdg.inst.id !1487
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "main"
Parallelizer: parallelizerLoop:   Loop 0 = "  %53 = getelementptr [1000 x i16], [1000 x i16]* @sbuf, i64 0, i64 0, !noelle.pdg.inst.id !1448"
Parallelizer: parallelizerLoop:   Nesting level = 1
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 =   %18 = alloca i32, align 4, !noelle.pdg.inst.id !1414
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %19 = bitcast i16** %1 to i8*, !noelle.pdg.inst.id !1415
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %20 = bitcast i8** %2 to i8*, !noelle.pdg.inst.id !1416
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %21 = bitcast i32* %3 to i8*, !noelle.pdg.inst.id !1417
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %22 = bitcast %struct.adpcm_state** %4 to i8*, !noelle.pdg.inst.id !1418
Parallelizer: parallelizerLoop:   Environment:   Live-in 5 =   %23 = bitcast i16** %5 to i8*, !noelle.pdg.inst.id !1419
Parallelizer: parallelizerLoop:   Environment:   Live-in 6 =   %24 = bitcast i8** %6 to i8*, !noelle.pdg.inst.id !1420
Parallelizer: parallelizerLoop:   Environment:   Live-in 7 =   %25 = bitcast i32* %7 to i8*, !noelle.pdg.inst.id !1421
Parallelizer: parallelizerLoop:   Environment:   Live-in 8 =   %26 = bitcast i32* %8 to i8*, !noelle.pdg.inst.id !1422
Parallelizer: parallelizerLoop:   Environment:   Live-in 9 =   %27 = bitcast i32* %9 to i8*, !noelle.pdg.inst.id !1423
Parallelizer: parallelizerLoop:   Environment:   Live-in 10 =   %28 = bitcast i32* %10 to i8*, !noelle.pdg.inst.id !1424
Parallelizer: parallelizerLoop:   Environment:   Live-in 11 =   %29 = bitcast i32* %11 to i8*, !noelle.pdg.inst.id !1425
Parallelizer: parallelizerLoop:   Environment:   Live-in 12 =   %30 = bitcast i32* %12 to i8*, !noelle.pdg.inst.id !1426
Parallelizer: parallelizerLoop:   Environment:   Live-in 13 =   %31 = bitcast i32* %13 to i8*, !noelle.pdg.inst.id !1427
Parallelizer: parallelizerLoop:   Environment:   Live-in 14 =   %32 = bitcast i32* %14 to i8*, !noelle.pdg.inst.id !1428
Parallelizer: parallelizerLoop:   Environment:   Live-in 15 =   %33 = bitcast i32* %15 to i8*, !noelle.pdg.inst.id !1429
Parallelizer: parallelizerLoop:   Environment:   Live-in 16 =   %34 = bitcast i32* %16 to i8*, !noelle.pdg.inst.id !1430
Parallelizer: parallelizerLoop:   Environment:   Live-in 17 =   %35 = load i32, i32* %15, !noelle.pdg.inst.id !158
Parallelizer: parallelizerLoop:   Environment:   Live-in 18 =   %36 = bitcast i16** %1 to i8*, !noelle.pdg.inst.id !1431
Parallelizer: parallelizerLoop:   Environment:   Live-in 19 =   %37 = bitcast i8** %2 to i8*, !noelle.pdg.inst.id !1432
Parallelizer: parallelizerLoop:   Environment:   Live-in 20 =   %38 = bitcast i32* %3 to i8*, !noelle.pdg.inst.id !1433
Parallelizer: parallelizerLoop:   Environment:   Live-in 21 =   %39 = bitcast %struct.adpcm_state** %4 to i8*, !noelle.pdg.inst.id !1434
Parallelizer: parallelizerLoop:   Environment:   Live-in 22 =   %40 = bitcast i16** %5 to i8*, !noelle.pdg.inst.id !1435
Parallelizer: parallelizerLoop:   Environment:   Live-in 23 =   %41 = bitcast i8** %6 to i8*, !noelle.pdg.inst.id !1436
Parallelizer: parallelizerLoop:   Environment:   Live-in 24 =   %42 = bitcast i32* %7 to i8*, !noelle.pdg.inst.id !1437
Parallelizer: parallelizerLoop:   Environment:   Live-in 25 =   %43 = bitcast i32* %8 to i8*, !noelle.pdg.inst.id !1438
Parallelizer: parallelizerLoop:   Environment:   Live-in 26 =   %44 = bitcast i32* %9 to i8*, !noelle.pdg.inst.id !1439
Parallelizer: parallelizerLoop:   Environment:   Live-in 27 =   %45 = bitcast i32* %10 to i8*, !noelle.pdg.inst.id !1440
Parallelizer: parallelizerLoop:   Environment:   Live-in 28 =   %46 = bitcast i32* %11 to i8*, !noelle.pdg.inst.id !1441
Parallelizer: parallelizerLoop:   Environment:   Live-in 29 =   %47 = bitcast i32* %12 to i8*, !noelle.pdg.inst.id !1442
Parallelizer: parallelizerLoop:   Environment:   Live-in 30 =   %48 = bitcast i32* %13 to i8*, !noelle.pdg.inst.id !1443
Parallelizer: parallelizerLoop:   Environment:   Live-in 31 =   %49 = bitcast i32* %14 to i8*, !noelle.pdg.inst.id !1444
Parallelizer: parallelizerLoop:   Environment:   Live-in 32 =   %50 = bitcast i32* %15 to i8*, !noelle.pdg.inst.id !1445
Parallelizer: parallelizerLoop:   Environment:   Live-in 33 =   %51 = bitcast i32* %16 to i8*, !noelle.pdg.inst.id !1446
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: Exit
noelle-meta-clean parallelized_unoptimized.bc parallelized_unoptimized.bc
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CleanMetadata.so -CleanMetadata -clean-loop-metadata=true -clean-prof-metadata=true -clean-pdg-metadata=true parallelized_unoptimized.bc -o parallelized_unoptimized.bc
noelle/core/Clean Loop Metadata
noelle/core/Clean PDG Metadata
noelle/core/Clean profiler metadata
opt --strip-named-metadata parallelized_unoptimized.bc -o parallelized_unoptimized.bc
clang -O3 -c -emit-llvm parallelized_unoptimized.bc -o baseline_parallelized.bc
clang -O3 -c -emit-llvm baseline_parallelized.bc -o baseline_parallelized.bc
cp baseline_parallelized.bc rawcaudio.bc
make[1]: Leaving directory '/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/rawcaudio'
