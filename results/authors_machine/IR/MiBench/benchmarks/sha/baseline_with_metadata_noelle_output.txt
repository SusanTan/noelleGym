make[1]: Entering directory '/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/sha'
./runEnablers.sh sha sha.bc large "-lm -lstdc++ -lpthread -ltermcap" -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier
/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/sha /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/sha
Cloning https://github.com/scampanoni/virgil.git
Cloning into 'threadpool'...
/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/sha

opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -tbaa -early-cse-memssa -licm -simplifycfg -simplifycfg-sink-common=false -instcombine -tailcallelim -loop-simplify -lcssa -licm -loop-unswitch -globalopt -instcombine -ipsccp -dce -gvn -dse -adce -loop-simplify -lcssa -indvars -loop-deletion -instcombine -indvars -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa --functionattrs --rpo-functionattrs sha.bc -o baseline.bc
/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/sha /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/sha
Running: ./baseline_prof input_verylarge.asc > output_large.txt in /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/MiBench/security/sha
--------------------------------------------------------------------------------------
/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/sha
DONE
opt -pgo-test-profile-file=/tmp/tmp.9WMM6ZBzLx -block-freq -pgo-instr-use baseline.bc -o baseline_pre.bc
opt --strip-debug --strip-debug-declare baseline_pre.bc -o baseline_pre.bc
noelle-deadcode baseline_pre.bc baseline_pre.bc
NOELLE: DeadFunctions: Start
noelle-fixedpoint baseline_pre.bc baseline_pre.bc "noelle-load" -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DeadFunction.so -noelle-dfe
NOELLE: FixedPoint: Start
NOELLE: FixedPoint:   Loader: noelle-load
NOELLE: FixedPoint:   Options: -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DeadFunction.so -noelle-dfe
NOELLE: FixedPoint:   Input: baseline_pre.bc
NOELLE: FixedPoint:   Output: baseline_pre.bc
NOELLE: FixedPoint:   Temporary input: /tmp/tmp.AB42EUs58K (.ll version is /tmp/tmp.Dq4T7WkEzd)
NOELLE: FixedPoint:   Temporary output: /tmp/tmp.XQhxQ0hiA1 (.ll version is /tmp/tmp.DkyFtJ1JAS)
NOELLE: FixedPoint:   Normalize the code
noelle-norm /tmp/tmp.AB42EUs58K -o /tmp/tmp.XQhxQ0hiA1
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.AB42EUs58K -o /tmp/tmp.XQhxQ0hiA1
NOELLE: FixedPoint:   Run until a fixed point is reached
NOELLE: FixedPoint:     Invocation 0
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DeadFunction.so -noelle-dfe /tmp/tmp.AB42EUs58K -o /tmp/tmp.XQhxQ0hiA1
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DeadFunction.so -noelle-dfe /tmp/tmp.AB42EUs58K -o /tmp/tmp.XQhxQ0hiA1
DeadFunctionEliminator: Start
DeadFunctionEliminator:   Inline functions that are invoked only by one call instruction and that do not escape into memory
DeadFunctionEliminator:   Get the islands
DeadFunctionEliminator:   Identify the islands reachable from the entry points
DeadFunctionEliminator:     Island
DeadFunctionEliminator:       main
DeadFunctionEliminator:       llvm.lifetime.start.p0i8
DeadFunctionEliminator:       fopen
DeadFunctionEliminator:       printf
DeadFunctionEliminator:       fclose
DeadFunctionEliminator:       sha_stream
DeadFunctionEliminator:       llvm.lifetime.end.p0i8
DeadFunctionEliminator:       byte_reverse
DeadFunctionEliminator:       sha_init
DeadFunctionEliminator:       sha_update
DeadFunctionEliminator:       llvm.memcpy.p0i8.p0i8.i64
DeadFunctionEliminator:       sha_transform
DeadFunctionEliminator:       sha_final
DeadFunctionEliminator:       llvm.memset.p0i8.i64
DeadFunctionEliminator:       fread
DeadFunctionEliminator:       sha_print
DeadFunctionEliminator:   Identify the functions that can be deleted
DeadFunctionEliminator: Exit
Noelle:  Function "sha_update"
Noelle:     Loop "  %22 = icmp sgt i32 %.0, 63" (9.994119e+01%)
Noelle:  Function "main"
Noelle:     Loop "  %9 = add nsw i32 %.0, -1" (9.994574e+01%)
Noelle:  Function "sha_stream"
Noelle:     Loop "  %6 = call i64 @fread(i8* nonnull %4, i64 1, i64 8192, %struct._IO_FILE* %1) #7" (9.999979e+01%)
Noelle:  Function "sha_transform"
Noelle:     Loop "  %exitcond38 = icmp eq i64 %indvars.iv36, 16" (3.868914e+00%)
Noelle:     Loop "  %exitcond35 = icmp eq i64 %indvars.iv33, 80" (3.706394e+01%)
Noelle:     Loop "  %exitcond32 = icmp eq i64 %indvars.iv30, 20" (1.389651e+01%)
Noelle:     Loop "  %exitcond29 = icmp eq i64 %indvars.iv27, 40" (1.284374e+01%)
Noelle:     Loop "  %exitcond26 = icmp eq i64 %indvars.iv24, 60" (1.389651e+01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 80" (1.284374e+01%)
Noelle:  Function "byte_reverse"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 8" (3.895233e+00%)
Noelle:  Function "sha_final"
Noelle:  Function "sha_init"
Noelle:  Function "sha_print"
Noelle:  Function "sha_update"
Noelle:     Loop "  %22 = icmp sgt i32 %.0, 63" (9.994119e+01%)
Noelle:  Function "main"
Noelle:     Loop "  %9 = add nsw i32 %.0, -1" (9.994574e+01%)
Noelle:  Function "sha_stream"
Noelle:     Loop "  %6 = call i64 @fread(i8* nonnull %4, i64 1, i64 8192, %struct._IO_FILE* %1) #7" (9.999979e+01%)
Noelle:  Function "sha_transform"
Noelle:     Loop "  %exitcond38 = icmp eq i64 %indvars.iv36, 16" (3.868914e+00%)
Noelle:     Loop "  %exitcond35 = icmp eq i64 %indvars.iv33, 80" (3.706394e+01%)
Noelle:     Loop "  %exitcond32 = icmp eq i64 %indvars.iv30, 20" (1.389651e+01%)
Noelle:     Loop "  %exitcond29 = icmp eq i64 %indvars.iv27, 40" (1.284374e+01%)
Noelle:     Loop "  %exitcond26 = icmp eq i64 %indvars.iv24, 60" (1.389651e+01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 80" (1.284374e+01%)
Noelle:  Function "byte_reverse"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 8" (3.895233e+00%)
Noelle:  Function "sha_final"
Noelle:  Function "sha_init"
Noelle:  Function "sha_print"
NOELLE: FixedPoint: Exit
NOELLE: DeadFunctions: Exit
noelle-simplification baseline_pre.bc -o baseline_pre.bc
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -tbaa -early-cse-memssa -licm -simplifycfg -simplifycfg-sink-common=false -instcombine -tailcallelim -loop-simplify -lcssa -licm -loop-unswitch -globalopt -instcombine -ipsccp -dce -gvn -dse -adce -loop-simplify -lcssa -indvars -loop-deletion -instcombine -indvars -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa --functionattrs --rpo-functionattrs baseline_pre.bc -o baseline_pre.bc
noelle-inline baseline_pre.bc "-noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier"
NOELLE: Inliner: Start
noelle-fixedpoint baseline_pre.bc baseline_pre.bc "noelle-parallel-load" -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier
NOELLE: FixedPoint: Start
NOELLE: FixedPoint:   Loader: noelle-parallel-load
NOELLE: FixedPoint:   Options: -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier
NOELLE: FixedPoint:   Input: baseline_pre.bc
NOELLE: FixedPoint:   Output: baseline_pre.bc
NOELLE: FixedPoint:   Temporary input: /tmp/tmp.uQjaPIBrDF (.ll version is /tmp/tmp.QI4K9yYhMX)
NOELLE: FixedPoint:   Temporary output: /tmp/tmp.miMFSnbqIK (.ll version is /tmp/tmp.PuF8rng4u6)
NOELLE: FixedPoint:   Normalize the code
noelle-norm /tmp/tmp.uQjaPIBrDF -o /tmp/tmp.miMFSnbqIK
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.uQjaPIBrDF -o /tmp/tmp.miMFSnbqIK
NOELLE: FixedPoint:   Run until a fixed point is reached
NOELLE: FixedPoint:     Invocation 0
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.uQjaPIBrDF -o /tmp/tmp.miMFSnbqIK
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.uQjaPIBrDF -o /tmp/tmp.miMFSnbqIK
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.uQjaPIBrDF -o /tmp/tmp.miMFSnbqIK
Inliner: Start
Inliner:   Number of program instructions = 350
Inliner:   Profiles are available and will be used
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
Inliner:   Inlining in: sha_update (36 instructions. The inlining will add 21 instructions),   tail call fastcc void @byte_reverse(i64* nonnull %17, i32 64)
Inliner:   Inlined calls due to loop-carried data dependences
Inliner: Exit
Noelle:  Function "sha_update"
Noelle:     Loop "  %20 = icmp sgt i32 %.0, 63" (9.994140e+01%)
Noelle:  Function "main"
Noelle:     Loop "  %8 = add nsw i32 %.0, -1" (9.994574e+01%)
Noelle:  Function "sha_stream"
Noelle:     Loop "  %6 = call i64 @fread(i8* nonnull %4, i64 1, i64 8192, %struct._IO_FILE* %1) #7" (9.999979e+01%)
Noelle:  Function "sha_transform"
Noelle:     Loop "  %exitcond38 = icmp eq i64 %indvars.iv36, 16" (3.868922e+00%)
Noelle:     Loop "  %exitcond35 = icmp eq i64 %indvars.iv33, 80" (3.706401e+01%)
Noelle:     Loop "  %exitcond32 = icmp eq i64 %indvars.iv30, 20" (1.389654e+01%)
Noelle:     Loop "  %exitcond29 = icmp eq i64 %indvars.iv27, 40" (1.284377e+01%)
Noelle:     Loop "  %exitcond26 = icmp eq i64 %indvars.iv24, 60" (1.389654e+01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 80" (1.284377e+01%)
Noelle:  Function "byte_reverse"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 8" (3.895241e+00%)
Noelle:  Function "sha_final"
Noelle:  Function "sha_init"
Noelle:  Function "sha_print"
Noelle:  Function "sha_update"
Noelle:     Loop "  %20 = icmp sgt i32 %.0, 63" (9.614471e+01%)
Noelle:     Loop "  %exitcond.i = icmp eq i32 %.01.i, 8" (3.748251e+00%)
Noelle:  Function "main"
Noelle:     Loop "  %8 = add nsw i32 %.0, -1" (9.612358e+01%)
Noelle:  Function "sha_stream"
Noelle:     Loop "  %6 = call i64 @fread(i8* nonnull %4, i64 1, i64 8192, %struct._IO_FILE* %1) #7" (9.617557e+01%)
Noelle:  Function "sha_transform"
Noelle:     Loop "  %exitcond38 = icmp eq i64 %indvars.iv36, 16" (3.722925e+00%)
Noelle:     Loop "  %exitcond35 = icmp eq i64 %indvars.iv33, 80" (3.566537e+01%)
Noelle:     Loop "  %exitcond32 = icmp eq i64 %indvars.iv30, 20" (1.337214e+01%)
Noelle:     Loop "  %exitcond29 = icmp eq i64 %indvars.iv27, 40" (1.235910e+01%)
Noelle:     Loop "  %exitcond26 = icmp eq i64 %indvars.iv24, 60" (1.337214e+01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 80" (1.235910e+01%)
Noelle:  Function "byte_reverse"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 8" (3.748251e+00%)
Noelle:  Function "sha_final"
Noelle:  Function "sha_init"
Noelle:  Function "sha_print"
NOELLE: FixedPoint:       There are 15 different instructions and 30 different loop instructions
NOELLE: FixedPoint:       Normalize the code
noelle-norm /tmp/tmp.miMFSnbqIK -o /tmp/tmp.miMFSnbqIK
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.miMFSnbqIK -o /tmp/tmp.miMFSnbqIK
NOELLE: FixedPoint:     Invocation 1
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.uQjaPIBrDF -o /tmp/tmp.miMFSnbqIK
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.uQjaPIBrDF -o /tmp/tmp.miMFSnbqIK
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.uQjaPIBrDF -o /tmp/tmp.miMFSnbqIK
Inliner: Start
Inliner:   Number of program instructions = 369
Inliner:   Profiles are available and will be used
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The next live-out variables are not reducable
DOALL:     Live-out ID = 5
DOALL:     Live-out ID = 6
Inliner:   Inlining in: sha_update (55 instructions. The inlining will add 182 instructions),   tail call fastcc void @sha_transform(%struct.SHA_INFO* %0)
Inliner:   Inlined calls due to loop-carried data dependences
Inliner: Exit
Noelle:  Function "sha_update"
Noelle:     Loop "  %20 = icmp sgt i32 %.0, 63" (9.614471e+01%)
Noelle:     Loop "  %exitcond.i = icmp eq i32 %.01.i, 8" (3.748251e+00%)
Noelle:  Function "main"
Noelle:     Loop "  %8 = add nsw i32 %.0, -1" (9.612358e+01%)
Noelle:  Function "sha_stream"
Noelle:     Loop "  %6 = call i64 @fread(i8* nonnull %4, i64 1, i64 8192, %struct._IO_FILE* %1) #7" (9.617557e+01%)
Noelle:  Function "sha_transform"
Noelle:     Loop "  %exitcond38 = icmp eq i64 %indvars.iv36, 16" (3.722925e+00%)
Noelle:     Loop "  %exitcond35 = icmp eq i64 %indvars.iv33, 80" (3.566537e+01%)
Noelle:     Loop "  %exitcond32 = icmp eq i64 %indvars.iv30, 20" (1.337214e+01%)
Noelle:     Loop "  %exitcond29 = icmp eq i64 %indvars.iv27, 40" (1.235910e+01%)
Noelle:     Loop "  %exitcond26 = icmp eq i64 %indvars.iv24, 60" (1.337214e+01%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 80" (1.235910e+01%)
Noelle:  Function "byte_reverse"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 8" (3.748251e+00%)
Noelle:  Function "sha_final"
Noelle:  Function "sha_init"
Noelle:  Function "sha_print"
Noelle:  Function "sha_update"
Noelle:     Loop "  %21 = icmp sgt i32 %.0, 63" (4.991771e+01%)
Noelle:     Loop "  %exitcond.i = icmp eq i32 %.01.i, 8" (1.955986e+00%)
Noelle:     Loop "  %exitcond38.i = icmp eq i64 %indvars.iv36.i, 16" (1.942770e+00%)
Noelle:     Loop "  %exitcond35.i = icmp eq i64 %indvars.iv33.i, 80" (1.864795e+01%)
Noelle:     Loop "  %exitcond32.i = icmp eq i64 %indvars.iv30.i, 20" (6.978113e+00%)
Noelle:     Loop "  %exitcond29.i = icmp eq i64 %indvars.iv27.i, 40" (6.449468e+00%)
Noelle:     Loop "  %exitcond26.i = icmp eq i64 %indvars.iv24.i, 60" (6.978113e+00%)
Noelle:     Loop "  %exitcond.i2 = icmp eq i64 %indvars.iv.i, 80" (6.449468e+00%)
Noelle:  Function "main"
Noelle:     Loop "  %8 = add nsw i32 %.0, -1" (4.989372e+01%)
Noelle:  Function "sha_stream"
Noelle:     Loop "  %6 = call i64 @fread(i8* nonnull %4, i64 1, i64 8192, %struct._IO_FILE* %1) #7" (4.992070e+01%)
Noelle:  Function "sha_transform"
Noelle:     Loop "  %exitcond38 = icmp eq i64 %indvars.iv36, 16" (1.942770e+00%)
Noelle:     Loop "  %exitcond35 = icmp eq i64 %indvars.iv33, 80" (1.861161e+01%)
Noelle:     Loop "  %exitcond32 = icmp eq i64 %indvars.iv30, 20" (6.978113e+00%)
Noelle:     Loop "  %exitcond29 = icmp eq i64 %indvars.iv27, 40" (6.449468e+00%)
Noelle:     Loop "  %exitcond26 = icmp eq i64 %indvars.iv24, 60" (6.978113e+00%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 80" (6.449468e+00%)
Noelle:  Function "byte_reverse"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 8" (1.955986e+00%)
Noelle:  Function "sha_final"
Noelle:  Function "sha_init"
Noelle:  Function "sha_print"
NOELLE: FixedPoint:       There are 122 different instructions and 220 different loop instructions
NOELLE: FixedPoint:       Normalize the code
noelle-norm /tmp/tmp.miMFSnbqIK -o /tmp/tmp.miMFSnbqIK
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.miMFSnbqIK -o /tmp/tmp.miMFSnbqIK
NOELLE: FixedPoint:     Invocation 2
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.uQjaPIBrDF -o /tmp/tmp.miMFSnbqIK
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.uQjaPIBrDF -o /tmp/tmp.miMFSnbqIK
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.uQjaPIBrDF -o /tmp/tmp.miMFSnbqIK
Inliner: Start
Inliner:   Number of program instructions = 549
Inliner:   Profiles are available and will be used
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [80 x i64], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca [80 x i64], align 16 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The next live-out variables are not reducable
DOALL:     Live-out ID = 6
DOALL:     Live-out ID = 7
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [8192 x i8], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca [8192 x i8], align 16 can be cloned
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
Inliner:   Inlining in: sha_stream (14 instructions. The inlining will add 235 instructions),   call void @sha_update(%struct.SHA_INFO* %0, i8* nonnull %4, i32 %7)
Inliner:   Inlined calls due to loop-carried data dependences
Inliner: Exit
Noelle:  Function "sha_update"
Noelle:     Loop "  %21 = icmp sgt i32 %.0, 63" (5.004974e+01%)
Noelle:     Loop "  %exitcond.i = icmp eq i32 %.01.i, 8" (1.950830e+00%)
Noelle:     Loop "  %exitcond38.i = icmp eq i64 %indvars.iv36.i, 16" (1.937648e+00%)
Noelle:     Loop "  %exitcond35.i = icmp eq i64 %indvars.iv33.i, 80" (1.859879e+01%)
Noelle:     Loop "  %exitcond32.i = icmp eq i64 %indvars.iv30.i, 20" (6.959717e+00%)
Noelle:     Loop "  %exitcond29.i = icmp eq i64 %indvars.iv27.i, 40" (6.432465e+00%)
Noelle:     Loop "  %exitcond26.i = icmp eq i64 %indvars.iv24.i, 60" (6.959717e+00%)
Noelle:     Loop "  %exitcond.i2 = icmp eq i64 %indvars.iv.i, 80" (6.432465e+00%)
Noelle:  Function "main"
Noelle:     Loop "  %8 = add nsw i32 %.0, -1" (5.002567e+01%)
Noelle:  Function "sha_stream"
Noelle:     Loop "  %6 = call i64 @fread(i8* nonnull %4, i64 1, i64 8192, %struct._IO_FILE* %1) #7" (5.005272e+01%)
Noelle:  Function "sha_transform"
Noelle:     Loop "  %exitcond38 = icmp eq i64 %indvars.iv36, 16" (1.937648e+00%)
Noelle:     Loop "  %exitcond35 = icmp eq i64 %indvars.iv33, 80" (1.856254e+01%)
Noelle:     Loop "  %exitcond32 = icmp eq i64 %indvars.iv30, 20" (6.959717e+00%)
Noelle:     Loop "  %exitcond29 = icmp eq i64 %indvars.iv27, 40" (6.432466e+00%)
Noelle:     Loop "  %exitcond26 = icmp eq i64 %indvars.iv24, 60" (6.959717e+00%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 80" (6.432466e+00%)
Noelle:  Function "byte_reverse"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 8" (1.950830e+00%)
Noelle:  Function "sha_final"
Noelle:  Function "sha_init"
Noelle:  Function "sha_print"
Noelle:  Function "sha_update"
Noelle:     Loop "  %21 = icmp sgt i32 %.0, 63" (3.341973e+01%)
Noelle:     Loop "  %exitcond.i = icmp eq i32 %.01.i, 8" (1.302628e+00%)
Noelle:     Loop "  %exitcond38.i = icmp eq i64 %indvars.iv36.i, 16" (1.293827e+00%)
Noelle:     Loop "  %exitcond35.i = icmp eq i64 %indvars.iv33.i, 80" (1.241897e+01%)
Noelle:     Loop "  %exitcond32.i = icmp eq i64 %indvars.iv30.i, 20" (4.647214e+00%)
Noelle:     Loop "  %exitcond29.i = icmp eq i64 %indvars.iv27.i, 40" (4.295152e+00%)
Noelle:     Loop "  %exitcond26.i = icmp eq i64 %indvars.iv24.i, 60" (4.647214e+00%)
Noelle:     Loop "  %exitcond.i2 = icmp eq i64 %indvars.iv.i, 80" (4.295152e+00%)
Noelle:  Function "main"
Noelle:     Loop "  %8 = add nsw i32 %.0, -1" (3.322738e+01%)
Noelle:  Function "sha_stream"
Noelle:     Loop "  %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7" (3.322738e+01%)
Noelle:     Loop "  %27 = icmp sgt i32 %.0.i, 63" (3.322567e+01%)
Noelle:     Loop "  %exitcond.i.i = icmp eq i32 %.01.i.i, 8" (1.301922e+00%)
Noelle:     Loop "  %exitcond38.i.i = icmp eq i64 %indvars.iv36.i.i, 16" (1.293125e+00%)
Noelle:     Loop "  %exitcond35.i.i = icmp eq i64 %indvars.iv33.i.i, 80" (1.241224e+01%)
Noelle:     Loop "  %exitcond32.i.i = icmp eq i64 %indvars.iv30.i.i, 20" (4.644693e+00%)
Noelle:     Loop "  %exitcond29.i.i = icmp eq i64 %indvars.iv27.i.i, 40" (4.292823e+00%)
Noelle:     Loop "  %exitcond26.i.i = icmp eq i64 %indvars.iv24.i.i, 60" (4.644693e+00%)
Noelle:     Loop "  %exitcond.i2.i = icmp eq i64 %indvars.iv.i.i, 80" (4.292823e+00%)
Noelle:  Function "sha_transform"
Noelle:     Loop "  %exitcond38 = icmp eq i64 %indvars.iv36, 16" (1.293827e+00%)
Noelle:     Loop "  %exitcond35 = icmp eq i64 %indvars.iv33, 80" (1.239477e+01%)
Noelle:     Loop "  %exitcond32 = icmp eq i64 %indvars.iv30, 20" (4.647214e+00%)
Noelle:     Loop "  %exitcond29 = icmp eq i64 %indvars.iv27, 40" (4.295152e+00%)
Noelle:     Loop "  %exitcond26 = icmp eq i64 %indvars.iv24, 60" (4.647214e+00%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 80" (4.295152e+00%)
Noelle:  Function "byte_reverse"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 8" (1.302628e+00%)
Noelle:  Function "sha_final"
Noelle:  Function "sha_init"
Noelle:  Function "sha_print"
NOELLE: FixedPoint:       There are 162 different instructions and 418 different loop instructions
NOELLE: FixedPoint:       Normalize the code
noelle-norm /tmp/tmp.miMFSnbqIK -o /tmp/tmp.miMFSnbqIK
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.miMFSnbqIK -o /tmp/tmp.miMFSnbqIK
NOELLE: FixedPoint:     Invocation 3
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.uQjaPIBrDF -o /tmp/tmp.miMFSnbqIK
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.uQjaPIBrDF -o /tmp/tmp.miMFSnbqIK
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.uQjaPIBrDF -o /tmp/tmp.miMFSnbqIK
Inliner: Start
Inliner:   Number of program instructions = 782
Inliner:   Profiles are available and will be used
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca [80 x i64], align 16 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca [8192 x i8], align 16 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca [80 x i64], align 16 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 214
DOALL:     	  %131 = add i64 %128, %130
DOALL:     	  %132 = add i64 %131, %.3.i.i
DOALL:     	  %133 = getelementptr inbounds [80 x i64], [80 x i64]* %3, i64 0, i64 %indvars.iv.i.i
DOALL:     	  %134 = load i64, i64* %133, align 8, !tbaa !42
DOALL:     	  %135 = add i64 %132, %134
DOALL:     	  %136 = add i64 %135, 3395469782
DOALL:     	  %137 = shl i64 %.312.i.i, 30
DOALL:     	  %138 = lshr i64 %.312.i.i, 2
DOALL:     	  %139 = or i64 %137, %138
DOALL:     	  %indvars.iv.next.i.i = add nuw nsw i64 %indvars.iv.i.i, 1
DOALL:     	  %.320.i.i.lcssa = phi i64 [ %.320.i.i, %.preheader.i.i ]
DOALL:     	  %.316.i.i.lcssa = phi i64 [ %.316.i.i, %.preheader.i.i ]
DOALL:     	  %.312.i.i.lcssa = phi i64 [ %.312.i.i, %.preheader.i.i ]
DOALL:     	  %.38.i.i.lcssa = phi i64 [ %.38.i.i, %.preheader.i.i ]
DOALL:     	  %.3.i.i.lcssa = phi i64 [ %.3.i.i, %.preheader.i.i ]
DOALL:     	  %140 = add i64 %66, %.38.i.i.lcssa
DOALL:     	  store i64 %140, i64* %65, align 8, !tbaa !42
DOALL:     	  %141 = add i64 %68, %.312.i.i.lcssa
DOALL:     	  store i64 %141, i64* %67, align 8, !tbaa !42
DOALL:     	  %142 = add i64 %70, %.316.i.i.lcssa
DOALL:     	  store i64 %142, i64* %69, align 8, !tbaa !42
DOALL:     	  %143 = add i64 %72, %.320.i.i.lcssa
DOALL:     	  store i64 %143, i64* %71, align 8, !tbaa !42
DOALL:     	  %144 = add i64 %74, %.3.i.i.lcssa
DOALL:     	  store i64 %144, i64* %73, align 8, !tbaa !42
DOALL:     	  %145 = getelementptr inbounds i8, i8* %.01.i, i64 64
DOALL:     	  %146 = add nsw i32 %.0.i, -64
DOALL:     	  %.01.i.lcssa = phi i8* [ %.01.i, %26 ]
DOALL:     	  %.0.i.lcssa = phi i32 [ %.0.i, %26 ]
DOALL:     	  %147 = sext i32 %.0.i.lcssa to i64
DOALL:     	  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45
DOALL:     	  %21 = phi i64 [ %20, %19 ], [ %18, %.._crit_edge_crit_edge.i ]
DOALL:     	  %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7
DOALL:     	  %8 = trunc i64 %7 to i32
DOALL:     	  %9 = icmp sgt i32 %8, 0
DOALL:     	  br i1 %9, label %10, label %148, !prof !30
DOALL:     	  %11 = getelementptr inbounds %struct.SHA_INFO, %struct.SHA_INFO* %0, i64 0, i32 1
DOALL:     	  %12 = load i64, i64* %11, align 8, !tbaa !31
DOALL:     	  %13 = sext i32 %8 to i64
DOALL:     	  %14 = shl nsw i64 %13, 3
DOALL:     	  %15 = add i64 %12, %14
DOALL:     	  %16 = icmp ult i64 %15, %12
DOALL:     	  %17 = getelementptr inbounds %struct.SHA_INFO, %struct.SHA_INFO* %0, i64 0, i32 2
DOALL:     	  %18 = load i64, i64* %17, align 8, !tbaa !36
DOALL:     	  br i1 %16, label %19, label %.._crit_edge_crit_edge.i, !prof !37
DOALL:     	  %20 = add i64 %18, 1
DOALL:     	  store i64 %20, i64* %17, align 8, !tbaa !36
DOALL:     	  store i64 %15, i64* %11, align 8, !tbaa !31
DOALL:     	  %22 = lshr i64 %13, 29
DOALL:     	  %23 = add i64 %21, %22
DOALL:     	  store i64 %23, i64* %17, align 8, !tbaa !36
DOALL:     	  %24 = getelementptr inbounds %struct.SHA_INFO, %struct.SHA_INFO* %0, i64 0, i32 3, i64 0
DOALL:     	  %25 = bitcast i64* %24 to i8*
DOALL:     	  %.01.i = phi i8* [ %5, %._crit_edge.i ], [ %145, %sha_transform.exit.i ]
DOALL:     	  %.0.i = phi i32 [ %8, %._crit_edge.i ], [ %146, %sha_transform.exit.i ]
DOALL:     	  %27 = icmp sgt i32 %.0.i, 63
DOALL:     	  br i1 %27, label %28, label %sha_update.exit, !prof !38
DOALL:     	  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7
DOALL:     	  %29 = bitcast i64* %24 to i8*
DOALL:     	  %.01.i.i = phi i32 [ 0, %28 ], [ %40, %31 ]
DOALL:     	  %.0.i.i = phi i8* [ %29, %28 ], [ %39, %31 ]
DOALL:     	  %exitcond.i.i = icmp eq i32 %.01.i.i, 8
DOALL:     	  br i1 %exitcond.i.i, label %byte_reverse.exit.i, label %31, !prof !39
DOALL:     	  %32 = load i8, i8* %.0.i.i, align 1, !tbaa !40
DOALL:     	  %33 = getelementptr inbounds i8, i8* %.0.i.i, i64 1
DOALL:     	  %34 = load i8, i8* %33, align 1, !tbaa !40
DOALL:     	  %35 = getelementptr inbounds i8, i8* %.0.i.i, i64 2
DOALL:     	  %36 = load i8, i8* %35, align 1, !tbaa !40
DOALL:     	  %37 = getelementptr inbounds i8, i8* %.0.i.i, i64 3
DOALL:     	  %38 = load i8, i8* %37, align 1, !tbaa !40
DOALL:     	  store i8 %38, i8* %.0.i.i, align 1, !tbaa !40
DOALL:     	  store i8 %36, i8* %33, align 1, !tbaa !40
DOALL:     	  store i8 %34, i8* %35, align 1, !tbaa !40
DOALL:     	  store i8 %32, i8* %37, align 1, !tbaa !40
DOALL:     	  %39 = getelementptr inbounds i8, i8* %.0.i.i, i64 8
DOALL:     	  %40 = add nuw nsw i32 %.01.i.i, 1
DOALL:     	  %indvars.iv36.i.i = phi i64 [ %indvars.iv.next37.i.i, %43 ], [ 0, %byte_reverse.exit.i ]
DOALL:     	  %exitcond38.i.i = icmp eq i64 %indvars.iv36.i.i, 16
DOALL:     	  br i1 %exitcond38.i.i, label %.preheader23.preheader.i.i, label %43, !prof !41
DOALL:     	  %44 = getelementptr inbounds %struct.SHA_INFO, %struct.SHA_INFO* %0, i64 0, i32 3, i64 %indvars.iv36.i.i
DOALL:     	  %45 = load i64, i64* %44, align 8, !tbaa !42
DOALL:     	  %indvars.iv.next37.i.i = add nuw nsw i64 %indvars.iv36.i.i, 1
DOALL:     	  %indvars.iv33.i.i = phi i64 [ %indvars.iv.next34.i.i, %47 ], [ 16, %.preheader23.preheader.i.i ]
DOALL:     	  %exitcond35.i.i = icmp eq i64 %indvars.iv33.i.i, 80
DOALL:     	  br i1 %exitcond35.i.i, label %64, label %47, !prof !43
DOALL:     	  %48 = add nsw i64 %indvars.iv33.i.i, -3
DOALL:     	  %49 = getelementptr inbounds [80 x i64], [80 x i64]* %3, i64 0, i64 %48
DOALL:     	  %50 = load i64, i64* %49, align 8, !tbaa !42
DOALL:     	  %51 = add nsw i64 %indvars.iv33.i.i, -8
DOALL:     	  %52 = getelementptr inbounds [80 x i64], [80 x i64]* %3, i64 0, i64 %51
DOALL:     	  %53 = load i64, i64* %52, align 8, !tbaa !42
DOALL:     	  %54 = xor i64 %50, %53
DOALL:     	  %55 = add nsw i64 %indvars.iv33.i.i, -14
DOALL:     	  %56 = getelementptr inbounds [80 x i64], [80 x i64]* %3, i64 0, i64 %55
DOALL:     	  %57 = load i64, i64* %56, align 8, !tbaa !42
DOALL:     	  %58 = xor i64 %54, %57
DOALL:     	  %59 = add nsw i64 %indvars.iv33.i.i, -16
DOALL:     	  %60 = getelementptr inbounds [80 x i64], [80 x i64]* %3, i64 0, i64 %59
DOALL:     	  %61 = load i64, i64* %60, align 8, !tbaa !42
DOALL:     	  %62 = xor i64 %58, %61
DOALL:     	  %63 = getelementptr inbounds [80 x i64], [80 x i64]* %3, i64 0, i64 %indvars.iv33.i.i
DOALL:     	  store i64 %62, i64* %63, align 8, !tbaa !42
DOALL:     	  %indvars.iv.next34.i.i = add nuw nsw i64 %indvars.iv33.i.i, 1
DOALL:     	  %65 = getelementptr inbounds %struct.SHA_INFO, %struct.SHA_INFO* %0, i64 0, i32 0, i64 0
DOALL:     	  %66 = load i64, i64* %65, align 8, !tbaa !42
DOALL:     	  %67 = getelementptr inbounds %struct.SHA_INFO, %struct.SHA_INFO* %0, i64 0, i32 0, i64 1
DOALL:     	  %68 = load i64, i64* %67, align 8, !tbaa !42
DOALL:     	  %69 = getelementptr inbounds %struct.SHA_INFO, %struct.SHA_INFO* %0, i64 0, i32 0, i64 2
DOALL:     	  %70 = load i64, i64* %69, align 8, !tbaa !42
DOALL:     	  %71 = getelementptr inbounds %struct.SHA_INFO, %struct.SHA_INFO* %0, i64 0, i32 0, i64 3
DOALL:     	  %72 = load i64, i64* %71, align 8, !tbaa !42
DOALL:     	  %73 = getelementptr inbounds %struct.SHA_INFO, %struct.SHA_INFO* %0, i64 0, i32 0, i64 4
DOALL:     	  %74 = load i64, i64* %73, align 8, !tbaa !42
DOALL:     	  %indvars.iv30.i.i = phi i64 [ %indvars.iv.next31.i.i, %76 ], [ 0, %64 ]
DOALL:     	  %.017.i.i = phi i64 [ %.013.i.i, %76 ], [ %72, %64 ]
DOALL:     	  %.013.i.i = phi i64 [ %92, %76 ], [ %70, %64 ]
DOALL:     	  %.09.i.i = phi i64 [ %.05.i.i, %76 ], [ %68, %64 ]
DOALL:     	  %.05.i.i = phi i64 [ %89, %76 ], [ %66, %64 ]
DOALL:     	  %.0.i1.i = phi i64 [ %.017.i.i, %76 ], [ %74, %64 ]
DOALL:     	  %exitcond32.i.i = icmp eq i64 %indvars.iv30.i.i, 20
DOALL:     	  br i1 %exitcond32.i.i, label %.preheader22.preheader.i.i, label %76, !prof !44
DOALL:     	  %.017.i.i.lcssa = phi i64 [ %.017.i.i, %75 ]
DOALL:     	  %.013.i.i.lcssa = phi i64 [ %.013.i.i, %75 ]
DOALL:     	  %.09.i.i.lcssa = phi i64 [ %.09.i.i, %75 ]
DOALL:     	  %.05.i.i.lcssa = phi i64 [ %.05.i.i, %75 ]
DOALL:     	  %.0.i1.i.lcssa = phi i64 [ %.0.i1.i, %75 ]
DOALL:     	  %77 = shl i64 %.05.i.i, 5
DOALL:     	  %78 = lshr i64 %.05.i.i, 27
DOALL:     	  %79 = or i64 %77, %78
DOALL:     	  %80 = and i64 %.09.i.i, %.013.i.i
DOALL:     	  %81 = xor i64 %.09.i.i, -1
DOALL:     	  %82 = and i64 %.017.i.i, %81
DOALL:     	  %83 = or i64 %80, %82
DOALL:     	  %84 = add i64 %79, %83
DOALL:     	  %85 = add i64 %84, %.0.i1.i
DOALL:     	  %86 = getelementptr inbounds [80 x i64], [80 x i64]* %3, i64 0, i64 %indvars.iv30.i.i
DOALL:     	  %87 = load i64, i64* %86, align 8, !tbaa !42
DOALL:     	  %88 = add i64 %85, %87
DOALL:     	  %89 = add i64 %88, 1518500249
DOALL:     	  %90 = shl i64 %.09.i.i, 30
DOALL:     	  %91 = lshr i64 %.09.i.i, 2
DOALL:     	  %92 = or i64 %90, %91
DOALL:     	  %indvars.iv.next31.i.i = add nuw nsw i64 %indvars.iv30.i.i, 1
DOALL:     	  %indvars.iv27.i.i = phi i64 [ %indvars.iv.next28.i.i, %93 ], [ 20, %.preheader22.preheader.i.i ]
DOALL:     	  %.118.i.i = phi i64 [ %.114.i.i, %93 ], [ %.017.i.i.lcssa, %.preheader22.preheader.i.i ]
DOALL:     	  %.114.i.i = phi i64 [ %107, %93 ], [ %.013.i.i.lcssa, %.preheader22.preheader.i.i ]
DOALL:     	  %.110.i.i = phi i64 [ %.16.i.i, %93 ], [ %.09.i.i.lcssa, %.preheader22.preheader.i.i ]
DOALL:     	  %.16.i.i = phi i64 [ %104, %93 ], [ %.05.i.i.lcssa, %.preheader22.preheader.i.i ]
DOALL:     	  %.1.i.i = phi i64 [ %.118.i.i, %93 ], [ %.0.i1.i.lcssa, %.preheader22.preheader.i.i ]
DOALL:     	  %exitcond29.i.i = icmp eq i64 %indvars.iv27.i.i, 40
DOALL:     	  br i1 %exitcond29.i.i, label %.preheader21.preheader.i.i, label %93, !prof !44
DOALL:     	  %.118.i.i.lcssa = phi i64 [ %.118.i.i, %.preheader22.i.i ]
DOALL:     	  %.114.i.i.lcssa = phi i64 [ %.114.i.i, %.preheader22.i.i ]
DOALL:     	  %.110.i.i.lcssa = phi i64 [ %.110.i.i, %.preheader22.i.i ]
DOALL:     	  %.16.i.i.lcssa = phi i64 [ %.16.i.i, %.preheader22.i.i ]
DOALL:     	  %.1.i.i.lcssa = phi i64 [ %.1.i.i, %.preheader22.i.i ]
DOALL:     	  %94 = shl i64 %.16.i.i, 5
DOALL:     	  %95 = lshr i64 %.16.i.i, 27
DOALL:     	  %96 = or i64 %94, %95
DOALL:     	  %97 = xor i64 %.110.i.i, %.114.i.i
DOALL:     	  %98 = xor i64 %97, %.118.i.i
DOALL:     	  %99 = add i64 %96, %98
DOALL:     	  %100 = add i64 %99, %.1.i.i
DOALL:     	  %101 = getelementptr inbounds [80 x i64], [80 x i64]* %3, i64 0, i64 %indvars.iv27.i.i
DOALL:     	  %102 = load i64, i64* %101, align 8, !tbaa !42
DOALL:     	  %103 = add i64 %100, %102
DOALL:     	  %104 = add i64 %103, 1859775393
DOALL:     	  %105 = shl i64 %.110.i.i, 30
DOALL:     	  %106 = lshr i64 %.110.i.i, 2
DOALL:     	  %107 = or i64 %105, %106
DOALL:     	  %indvars.iv.next28.i.i = add nuw nsw i64 %indvars.iv27.i.i, 1
DOALL:     	  %indvars.iv24.i.i = phi i64 [ %indvars.iv.next25.i.i, %108 ], [ 40, %.preheader21.preheader.i.i ]
DOALL:     	  %.219.i.i = phi i64 [ %.215.i.i, %108 ], [ %.118.i.i.lcssa, %.preheader21.preheader.i.i ]
DOALL:     	  %.215.i.i = phi i64 [ %124, %108 ], [ %.114.i.i.lcssa, %.preheader21.preheader.i.i ]
DOALL:     	  %.211.i.i = phi i64 [ %.27.i.i, %108 ], [ %.110.i.i.lcssa, %.preheader21.preheader.i.i ]
DOALL:     	  %.27.i.i = phi i64 [ %121, %108 ], [ %.16.i.i.lcssa, %.preheader21.preheader.i.i ]
DOALL:     	  %.2.i.i = phi i64 [ %.219.i.i, %108 ], [ %.1.i.i.lcssa, %.preheader21.preheader.i.i ]
DOALL:     	  %exitcond26.i.i = icmp eq i64 %indvars.iv24.i.i, 60
DOALL:     	  br i1 %exitcond26.i.i, label %.preheader.preheader.i.i, label %108, !prof !44
DOALL:     	  %.219.i.i.lcssa = phi i64 [ %.219.i.i, %.preheader21.i.i ]
DOALL:     	  %.215.i.i.lcssa = phi i64 [ %.215.i.i, %.preheader21.i.i ]
DOALL:     	  %.211.i.i.lcssa = phi i64 [ %.211.i.i, %.preheader21.i.i ]
DOALL:     	  %.27.i.i.lcssa = phi i64 [ %.27.i.i, %.preheader21.i.i ]
DOALL:     	  %.2.i.i.lcssa = phi i64 [ %.2.i.i, %.preheader21.i.i ]
DOALL:     	  %109 = shl i64 %.27.i.i, 5
DOALL:     	  %110 = lshr i64 %.27.i.i, 27
DOALL:     	  %111 = or i64 %109, %110
DOALL:     	  %112 = or i64 %.215.i.i, %.219.i.i
DOALL:     	  %113 = and i64 %.211.i.i, %112
DOALL:     	  %114 = and i64 %.215.i.i, %.219.i.i
DOALL:     	  %115 = or i64 %113, %114
DOALL:     	  %116 = add i64 %111, %115
DOALL:     	  %117 = add i64 %116, %.2.i.i
DOALL:     	  %118 = getelementptr inbounds [80 x i64], [80 x i64]* %3, i64 0, i64 %indvars.iv24.i.i
DOALL:     	  %119 = load i64, i64* %118, align 8, !tbaa !42
DOALL:     	  %120 = add i64 %117, %119
DOALL:     	  %121 = add i64 %120, 2400959708
DOALL:     	  %122 = shl i64 %.211.i.i, 30
DOALL:     	  %123 = lshr i64 %.211.i.i, 2
DOALL:     	  %124 = or i64 %122, %123
DOALL:     	  %indvars.iv.next25.i.i = add nuw nsw i64 %indvars.iv24.i.i, 1
DOALL:     	  %indvars.iv.i.i = phi i64 [ %indvars.iv.next.i.i, %125 ], [ 60, %.preheader.preheader.i.i ]
DOALL:     	  %.320.i.i = phi i64 [ %.316.i.i, %125 ], [ %.219.i.i.lcssa, %.preheader.preheader.i.i ]
DOALL:     	  %.316.i.i = phi i64 [ %139, %125 ], [ %.215.i.i.lcssa, %.preheader.preheader.i.i ]
DOALL:     	  %.312.i.i = phi i64 [ %.38.i.i, %125 ], [ %.211.i.i.lcssa, %.preheader.preheader.i.i ]
DOALL:     	  %.38.i.i = phi i64 [ %136, %125 ], [ %.27.i.i.lcssa, %.preheader.preheader.i.i ]
DOALL:     	  %.3.i.i = phi i64 [ %.320.i.i, %125 ], [ %.2.i.i.lcssa, %.preheader.preheader.i.i ]
DOALL:     	  %exitcond.i2.i = icmp eq i64 %indvars.iv.i.i, 80
DOALL:     	  br i1 %exitcond.i2.i, label %sha_transform.exit.i, label %125, !prof !44
DOALL:     	  %126 = shl i64 %.38.i.i, 5
DOALL:     	  %127 = lshr i64 %.38.i.i, 27
DOALL:     	  %128 = or i64 %126, %127
DOALL:     	  %129 = xor i64 %.312.i.i, %.316.i.i
DOALL:     	  %130 = xor i64 %129, %.320.i.i
DOALL:     External nodes: 24
DOALL:     	  br label %.preheader.i.i
DOALL:     	  call void @llvm.lifetime.end.p0i8(i64 640, i8* nonnull %41) #7
DOALL:     	  br label %26
DOALL:     	  br label %6
DOALL:     	  br label %._crit_edge.i
DOALL:     	  br label %._crit_edge.i
DOALL:     	  br label %26
DOALL:     	  br label %30
DOALL:     	  br label %30
DOALL:     	  %41 = bitcast [80 x i64]* %3 to i8*
DOALL:     	  call void @llvm.lifetime.start.p0i8(i64 640, i8* nonnull %41) #7
DOALL:     	  br label %42
DOALL:     	  br label %.preheader23.i.i
DOALL:     	  %46 = getelementptr inbounds [80 x i64], [80 x i64]* %3, i64 0, i64 %indvars.iv36.i.i
DOALL:     	  store i64 %45, i64* %46, align 8, !tbaa !42
DOALL:     	  br label %42
DOALL:     	  br label %.preheader23.i.i
DOALL:     	  br label %75
DOALL:     	  br label %.preheader22.i.i
DOALL:     	  br label %75
DOALL:     	  br label %.preheader21.i.i
DOALL:     	  br label %.preheader22.i.i
DOALL:     	  br label %.preheader.i.i
DOALL:     	  br label %.preheader21.i.i
DOALL:     Edges: 899
DOALL:     Loop-carried data dependences
DOALL:         store i64 %140, i64* %65, align 8, !tbaa !42 --->   store i8 %32, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i64 %140, i64* %65, align 8, !tbaa !42 --->   store i8 %34, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i64 %140, i64* %65, align 8, !tbaa !42 --->   store i8 %36, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i64 %140, i64* %65, align 8, !tbaa !42 --->   %38 = load i8, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i64 %140, i64* %65, align 8, !tbaa !42 --->   %66 = load i64, i64* %65, align 8, !tbaa !42 via memory
DOALL:         store i64 %140, i64* %65, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i64 %140, i64* %65, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i64 %140, i64* %65, align 8, !tbaa !42 --->   store i64 %140, i64* %65, align 8, !tbaa !42 via memory
DOALL:         store i64 %140, i64* %65, align 8, !tbaa !42 --->   %32 = load i8, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i64 %140, i64* %65, align 8, !tbaa !42 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i64 %140, i64* %65, align 8, !tbaa !42 --->   %34 = load i8, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i64 %140, i64* %65, align 8, !tbaa !42 --->   %36 = load i8, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i64 %141, i64* %67, align 8, !tbaa !42 --->   %68 = load i64, i64* %67, align 8, !tbaa !42 via memory
DOALL:         store i64 %141, i64* %67, align 8, !tbaa !42 --->   store i8 %32, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i64 %141, i64* %67, align 8, !tbaa !42 --->   store i8 %34, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i64 %141, i64* %67, align 8, !tbaa !42 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i64 %141, i64* %67, align 8, !tbaa !42 --->   %34 = load i8, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i64 %141, i64* %67, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i64 %141, i64* %67, align 8, !tbaa !42 --->   store i8 %36, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i64 %141, i64* %67, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i64 %141, i64* %67, align 8, !tbaa !42 --->   store i64 %141, i64* %67, align 8, !tbaa !42 via memory
DOALL:         store i64 %141, i64* %67, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i64 %141, i64* %67, align 8, !tbaa !42 --->   %36 = load i8, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i64 %141, i64* %67, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i64 %141, i64* %67, align 8, !tbaa !42 --->   %38 = load i8, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i64 %141, i64* %67, align 8, !tbaa !42 --->   %32 = load i8, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i64 %142, i64* %69, align 8, !tbaa !42 --->   %70 = load i64, i64* %69, align 8, !tbaa !42 via memory
DOALL:         store i64 %142, i64* %69, align 8, !tbaa !42 --->   store i8 %32, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i64 %142, i64* %69, align 8, !tbaa !42 --->   store i8 %34, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i64 %142, i64* %69, align 8, !tbaa !42 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i64 %142, i64* %69, align 8, !tbaa !42 --->   %34 = load i8, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i64 %142, i64* %69, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i64 %142, i64* %69, align 8, !tbaa !42 --->   store i8 %36, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i64 %142, i64* %69, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i64 %142, i64* %69, align 8, !tbaa !42 --->   store i64 %142, i64* %69, align 8, !tbaa !42 via memory
DOALL:         store i64 %142, i64* %69, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i64 %142, i64* %69, align 8, !tbaa !42 --->   %36 = load i8, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i64 %142, i64* %69, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i64 %142, i64* %69, align 8, !tbaa !42 --->   %38 = load i8, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i64 %142, i64* %69, align 8, !tbaa !42 --->   %32 = load i8, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i64 %143, i64* %71, align 8, !tbaa !42 --->   %72 = load i64, i64* %71, align 8, !tbaa !42 via memory
DOALL:         store i64 %143, i64* %71, align 8, !tbaa !42 --->   store i8 %32, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i64 %143, i64* %71, align 8, !tbaa !42 --->   store i8 %34, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i64 %143, i64* %71, align 8, !tbaa !42 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i64 %143, i64* %71, align 8, !tbaa !42 --->   %34 = load i8, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i64 %143, i64* %71, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i64 %143, i64* %71, align 8, !tbaa !42 --->   store i8 %36, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i64 %143, i64* %71, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i64 %143, i64* %71, align 8, !tbaa !42 --->   store i64 %143, i64* %71, align 8, !tbaa !42 via memory
DOALL:         store i64 %143, i64* %71, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i64 %143, i64* %71, align 8, !tbaa !42 --->   %36 = load i8, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i64 %143, i64* %71, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i64 %143, i64* %71, align 8, !tbaa !42 --->   %38 = load i8, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i64 %143, i64* %71, align 8, !tbaa !42 --->   %32 = load i8, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i64 %144, i64* %73, align 8, !tbaa !42 --->   %74 = load i64, i64* %73, align 8, !tbaa !42 via memory
DOALL:         store i64 %144, i64* %73, align 8, !tbaa !42 --->   store i8 %34, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i64 %144, i64* %73, align 8, !tbaa !42 --->   store i8 %36, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i64 %144, i64* %73, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i64 %144, i64* %73, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i64 %144, i64* %73, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i64 %144, i64* %73, align 8, !tbaa !42 --->   %36 = load i8, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i64 %144, i64* %73, align 8, !tbaa !42 --->   store i8 %32, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i64 %144, i64* %73, align 8, !tbaa !42 --->   %34 = load i8, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i64 %144, i64* %73, align 8, !tbaa !42 --->   %38 = load i8, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i64 %144, i64* %73, align 8, !tbaa !42 --->   %32 = load i8, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i64 %144, i64* %73, align 8, !tbaa !42 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i64 %144, i64* %73, align 8, !tbaa !42 --->   store i64 %144, i64* %73, align 8, !tbaa !42 via memory
DOALL:         store i64 %144, i64* %73, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   %45 = load i64, i64* %44, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i8 %32, i8* %37, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i8 %32, i8* %37, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i8 %34, i8* %35, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i64 %144, i64* %73, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i64 %144, i64* %73, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i64 %143, i64* %71, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i64 %142, i64* %69, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i64 %142, i64* %69, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i64 %141, i64* %67, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i8 %36, i8* %33, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i64 %141, i64* %67, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   %68 = load i64, i64* %67, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i64 %15, i64* %11, align 8, !tbaa !31 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i64 %143, i64* %71, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   %72 = load i64, i64* %71, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i64 %140, i64* %65, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   %74 = load i64, i64* %73, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   %12 = load i64, i64* %11, align 8, !tbaa !31 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   %18 = load i64, i64* %17, align 8, !tbaa !36 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i64 %20, i64* %17, align 8, !tbaa !36 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i64 %20, i64* %17, align 8, !tbaa !36 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i64 %15, i64* %11, align 8, !tbaa !31 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i64 %23, i64* %17, align 8, !tbaa !36 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   %70 = load i64, i64* %69, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i64 %23, i64* %17, align 8, !tbaa !36 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   %32 = load i8, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   %34 = load i8, i8* %33, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   %36 = load i8, i8* %35, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   %38 = load i8, i8* %37, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i8 %36, i8* %33, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i8 %34, i8* %35, align 1, !tbaa !40 via memory
DOALL:         %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 --->   store i8 %34, i8* %35, align 1, !tbaa !40 via memory
DOALL:         %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 --->   store i8 %36, i8* %33, align 1, !tbaa !40 via memory
DOALL:         %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 --->   store i8 %36, i8* %33, align 1, !tbaa !40 via memory
DOALL:         %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 --->   store i8 %32, i8* %37, align 1, !tbaa !40 via memory
DOALL:         %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 --->   store i8 %32, i8* %37, align 1, !tbaa !40 via memory
DOALL:         %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 --->   %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 via memory
DOALL:         %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 --->   %38 = load i8, i8* %37, align 1, !tbaa !40 via memory
DOALL:         %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 --->   %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 via memory
DOALL:         %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 --->   %32 = load i8, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 --->   %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 via memory
DOALL:         %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 --->   %34 = load i8, i8* %33, align 1, !tbaa !40 via memory
DOALL:         %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 --->   store i8 %34, i8* %35, align 1, !tbaa !40 via memory
DOALL:         %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 --->   %36 = load i8, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i64 %15, i64* %11, align 8, !tbaa !31 --->   store i8 %34, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i64 %15, i64* %11, align 8, !tbaa !31 --->   %38 = load i8, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i64 %15, i64* %11, align 8, !tbaa !31 --->   %32 = load i8, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i64 %15, i64* %11, align 8, !tbaa !31 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i64 %15, i64* %11, align 8, !tbaa !31 --->   %12 = load i64, i64* %11, align 8, !tbaa !31 via memory
DOALL:         store i64 %15, i64* %11, align 8, !tbaa !31 --->   store i8 %32, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i64 %15, i64* %11, align 8, !tbaa !31 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i64 %15, i64* %11, align 8, !tbaa !31 --->   store i64 %15, i64* %11, align 8, !tbaa !31 via memory
DOALL:         store i64 %15, i64* %11, align 8, !tbaa !31 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i64 %15, i64* %11, align 8, !tbaa !31 --->   %34 = load i8, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i64 %15, i64* %11, align 8, !tbaa !31 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i64 %15, i64* %11, align 8, !tbaa !31 --->   store i8 %36, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i64 %15, i64* %11, align 8, !tbaa !31 --->   %36 = load i8, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i64 %15, i64* %11, align 8, !tbaa !31 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i64 %23, i64* %17, align 8, !tbaa !36 --->   store i8 %32, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i64 %23, i64* %17, align 8, !tbaa !36 --->   store i8 %34, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i64 %23, i64* %17, align 8, !tbaa !36 --->   store i8 %36, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i64 %23, i64* %17, align 8, !tbaa !36 --->   %36 = load i8, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i64 %23, i64* %17, align 8, !tbaa !36 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i64 %23, i64* %17, align 8, !tbaa !36 --->   %34 = load i8, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i64 %23, i64* %17, align 8, !tbaa !36 --->   %32 = load i8, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i64 %23, i64* %17, align 8, !tbaa !36 --->   %38 = load i8, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i64 %23, i64* %17, align 8, !tbaa !36 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i64 %23, i64* %17, align 8, !tbaa !36 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i64 %23, i64* %17, align 8, !tbaa !36 --->   %18 = load i64, i64* %17, align 8, !tbaa !36 via memory
DOALL:         store i64 %23, i64* %17, align 8, !tbaa !36 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i64 %23, i64* %17, align 8, !tbaa !36 --->   store i64 %20, i64* %17, align 8, !tbaa !36 via memory
DOALL:         store i64 %23, i64* %17, align 8, !tbaa !36 --->   store i64 %23, i64* %17, align 8, !tbaa !36 via memory
DOALL:         store i64 %23, i64* %17, align 8, !tbaa !36 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   %74 = load i64, i64* %73, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   %72 = load i64, i64* %71, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   %68 = load i64, i64* %67, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i64 %23, i64* %17, align 8, !tbaa !36 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   %12 = load i64, i64* %11, align 8, !tbaa !31 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i64 %141, i64* %67, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i8 %34, i8* %35, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i64 %142, i64* %69, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i64 %144, i64* %73, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i64 %142, i64* %69, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i64 %20, i64* %17, align 8, !tbaa !36 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   %34 = load i8, i8* %33, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i64 %144, i64* %73, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i64 %141, i64* %67, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   %32 = load i8, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   %18 = load i64, i64* %17, align 8, !tbaa !36 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i64 %140, i64* %65, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i8 %32, i8* %37, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i64 %143, i64* %71, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i64 %143, i64* %71, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i8 %34, i8* %35, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   %45 = load i64, i64* %44, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i64 %15, i64* %11, align 8, !tbaa !31 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i64 %15, i64* %11, align 8, !tbaa !31 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   %38 = load i8, i8* %37, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i64 %23, i64* %17, align 8, !tbaa !36 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i64 %20, i64* %17, align 8, !tbaa !36 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i8 %36, i8* %33, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   %36 = load i8, i8* %35, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i8 %36, i8* %33, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   %70 = load i64, i64* %69, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i8 %32, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   store i64 %141, i64* %67, align 8, !tbaa !42 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   store i64 %23, i64* %17, align 8, !tbaa !36 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   %74 = load i64, i64* %73, align 8, !tbaa !42 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   %72 = load i64, i64* %71, align 8, !tbaa !42 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   %70 = load i64, i64* %69, align 8, !tbaa !42 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   %68 = load i64, i64* %67, align 8, !tbaa !42 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   %66 = load i64, i64* %65, align 8, !tbaa !42 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   %45 = load i64, i64* %44, align 8, !tbaa !42 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   store i8 %32, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   store i8 %34, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   store i8 %36, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   store i64 %144, i64* %73, align 8, !tbaa !42 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   %18 = load i64, i64* %17, align 8, !tbaa !36 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   store i64 %143, i64* %71, align 8, !tbaa !42 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   store i64 %140, i64* %65, align 8, !tbaa !42 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   %34 = load i8, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   store i64 %142, i64* %69, align 8, !tbaa !42 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   store i64 %20, i64* %17, align 8, !tbaa !36 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   %32 = load i8, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   %12 = load i64, i64* %11, align 8, !tbaa !31 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   store i64 %15, i64* %11, align 8, !tbaa !31 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   %36 = load i8, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   %38 = load i8, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   %68 = load i64, i64* %67, align 8, !tbaa !42 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   %66 = load i64, i64* %65, align 8, !tbaa !42 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   store i8 %36, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   %34 = load i8, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   store i64 %141, i64* %67, align 8, !tbaa !42 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   store i64 %144, i64* %73, align 8, !tbaa !42 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   %70 = load i64, i64* %69, align 8, !tbaa !42 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   store i64 %143, i64* %71, align 8, !tbaa !42 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   %45 = load i64, i64* %44, align 8, !tbaa !42 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   store i64 %142, i64* %69, align 8, !tbaa !42 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   %18 = load i64, i64* %17, align 8, !tbaa !36 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   %72 = load i64, i64* %71, align 8, !tbaa !42 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   %74 = load i64, i64* %73, align 8, !tbaa !42 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   %12 = load i64, i64* %11, align 8, !tbaa !31 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   store i64 %23, i64* %17, align 8, !tbaa !36 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   store i64 %20, i64* %17, align 8, !tbaa !36 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   %32 = load i8, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   store i64 %15, i64* %11, align 8, !tbaa !31 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   store i64 %140, i64* %65, align 8, !tbaa !42 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   %74 = load i64, i64* %73, align 8, !tbaa !42 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   %72 = load i64, i64* %71, align 8, !tbaa !42 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   %70 = load i64, i64* %69, align 8, !tbaa !42 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   %68 = load i64, i64* %67, align 8, !tbaa !42 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   %66 = load i64, i64* %65, align 8, !tbaa !42 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   %45 = load i64, i64* %44, align 8, !tbaa !42 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   store i8 %34, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   %36 = load i8, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   store i64 %140, i64* %65, align 8, !tbaa !42 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   store i64 %143, i64* %71, align 8, !tbaa !42 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   %12 = load i64, i64* %11, align 8, !tbaa !31 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   store i64 %144, i64* %73, align 8, !tbaa !42 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   store i64 %15, i64* %11, align 8, !tbaa !31 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   %18 = load i64, i64* %17, align 8, !tbaa !36 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   store i64 %142, i64* %69, align 8, !tbaa !42 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   %32 = load i8, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   store i64 %141, i64* %67, align 8, !tbaa !42 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   store i64 %23, i64* %17, align 8, !tbaa !36 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   store i64 %20, i64* %17, align 8, !tbaa !36 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   %68 = load i64, i64* %67, align 8, !tbaa !42 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   %70 = load i64, i64* %69, align 8, !tbaa !42 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   %66 = load i64, i64* %65, align 8, !tbaa !42 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   %72 = load i64, i64* %71, align 8, !tbaa !42 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   %45 = load i64, i64* %44, align 8, !tbaa !42 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   %74 = load i64, i64* %73, align 8, !tbaa !42 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   store i8 %32, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   %32 = load i8, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   store i64 %142, i64* %69, align 8, !tbaa !42 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   store i64 %140, i64* %65, align 8, !tbaa !42 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   store i64 %143, i64* %71, align 8, !tbaa !42 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   store i64 %144, i64* %73, align 8, !tbaa !42 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   %38 = load i8, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   store i64 %141, i64* %67, align 8, !tbaa !42 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   store i64 %23, i64* %17, align 8, !tbaa !36 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   %12 = load i64, i64* %11, align 8, !tbaa !31 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   store i64 %20, i64* %17, align 8, !tbaa !36 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   store i64 %15, i64* %11, align 8, !tbaa !31 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   %18 = load i64, i64* %17, align 8, !tbaa !36 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         %45 = load i64, i64* %44, align 8, !tbaa !42 --->   store i8 %32, i8* %37, align 1, !tbaa !40 via memory
DOALL:         %45 = load i64, i64* %44, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         %45 = load i64, i64* %44, align 8, !tbaa !42 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         %45 = load i64, i64* %44, align 8, !tbaa !42 --->   store i8 %36, i8* %33, align 1, !tbaa !40 via memory
DOALL:         %45 = load i64, i64* %44, align 8, !tbaa !42 --->   store i8 %34, i8* %35, align 1, !tbaa !40 via memory
DOALL:         %45 = load i64, i64* %44, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The next live-out variables are not reducable
DOALL:     Live-out ID = 0
DOALL:     Live-out ID = 1
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.SHA_INFO, align 8
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
Inliner:   Inlining in: main (33 instructions. The inlining will add 13 instructions),   call void @sha_print(%struct.SHA_INFO* nonnull %3)
Inliner:   Inlined calls due to loop-carried data dependences
Inliner: Exit
Noelle:  Function "sha_update"
Noelle:     Loop "  %21 = icmp sgt i32 %.0, 63" (3.336099e+01%)
Noelle:     Loop "  %exitcond.i = icmp eq i32 %.01.i, 8" (1.300339e+00%)
Noelle:     Loop "  %exitcond38.i = icmp eq i64 %indvars.iv36.i, 16" (1.291552e+00%)
Noelle:     Loop "  %exitcond35.i = icmp eq i64 %indvars.iv33.i, 80" (1.239715e+01%)
Noelle:     Loop "  %exitcond32.i = icmp eq i64 %indvars.iv30.i, 20" (4.639046e+00%)
Noelle:     Loop "  %exitcond29.i = icmp eq i64 %indvars.iv27.i, 40" (4.287603e+00%)
Noelle:     Loop "  %exitcond26.i = icmp eq i64 %indvars.iv24.i, 60" (4.639046e+00%)
Noelle:     Loop "  %exitcond.i2 = icmp eq i64 %indvars.iv.i, 80" (4.287603e+00%)
Noelle:  Function "main"
Noelle:     Loop "  %8 = add nsw i32 %.0, -1" (3.334475e+01%)
Noelle:  Function "sha_stream"
Noelle:     Loop "  %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7" (3.334475e+01%)
Noelle:     Loop "  %27 = icmp sgt i32 %.0.i, 63" (3.334289e+01%)
Noelle:     Loop "  %exitcond.i.i = icmp eq i32 %.01.i.i, 8" (1.299633e+00%)
Noelle:     Loop "  %exitcond38.i.i = icmp eq i64 %indvars.iv36.i.i, 16" (1.290852e+00%)
Noelle:     Loop "  %exitcond35.i.i = icmp eq i64 %indvars.iv33.i.i, 80" (1.239042e+01%)
Noelle:     Loop "  %exitcond32.i.i = icmp eq i64 %indvars.iv30.i.i, 20" (4.636530e+00%)
Noelle:     Loop "  %exitcond29.i.i = icmp eq i64 %indvars.iv27.i.i, 40" (4.285277e+00%)
Noelle:     Loop "  %exitcond26.i.i = icmp eq i64 %indvars.iv24.i.i, 60" (4.636530e+00%)
Noelle:     Loop "  %exitcond.i2.i = icmp eq i64 %indvars.iv.i.i, 80" (4.285277e+00%)
Noelle:  Function "sha_transform"
Noelle:     Loop "  %exitcond38 = icmp eq i64 %indvars.iv36, 16" (1.291552e+00%)
Noelle:     Loop "  %exitcond35 = icmp eq i64 %indvars.iv33, 80" (1.237298e+01%)
Noelle:     Loop "  %exitcond32 = icmp eq i64 %indvars.iv30, 20" (4.639046e+00%)
Noelle:     Loop "  %exitcond29 = icmp eq i64 %indvars.iv27, 40" (4.287603e+00%)
Noelle:     Loop "  %exitcond26 = icmp eq i64 %indvars.iv24, 60" (4.639046e+00%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 80" (4.287603e+00%)
Noelle:  Function "byte_reverse"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 8" (1.300339e+00%)
Noelle:  Function "sha_final"
Noelle:  Function "sha_init"
Noelle:  Function "sha_print"
Noelle:  Function "sha_update"
Noelle:     Loop "  %21 = icmp sgt i32 %.0, 63" (3.336099e+01%)
Noelle:     Loop "  %exitcond.i = icmp eq i32 %.01.i, 8" (1.300339e+00%)
Noelle:     Loop "  %exitcond38.i = icmp eq i64 %indvars.iv36.i, 16" (1.291552e+00%)
Noelle:     Loop "  %exitcond35.i = icmp eq i64 %indvars.iv33.i, 80" (1.239715e+01%)
Noelle:     Loop "  %exitcond32.i = icmp eq i64 %indvars.iv30.i, 20" (4.639046e+00%)
Noelle:     Loop "  %exitcond29.i = icmp eq i64 %indvars.iv27.i, 40" (4.287603e+00%)
Noelle:     Loop "  %exitcond26.i = icmp eq i64 %indvars.iv24.i, 60" (4.639046e+00%)
Noelle:     Loop "  %exitcond.i2 = icmp eq i64 %indvars.iv.i, 80" (4.287603e+00%)
Noelle:  Function "main"
Noelle:     Loop "  %8 = add nsw i32 %.0, -1" (3.334475e+01%)
Noelle:  Function "sha_stream"
Noelle:     Loop "  %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7" (3.334475e+01%)
Noelle:     Loop "  %27 = icmp sgt i32 %.0.i, 63" (3.334289e+01%)
Noelle:     Loop "  %exitcond.i.i = icmp eq i32 %.01.i.i, 8" (1.299633e+00%)
Noelle:     Loop "  %exitcond38.i.i = icmp eq i64 %indvars.iv36.i.i, 16" (1.290852e+00%)
Noelle:     Loop "  %exitcond35.i.i = icmp eq i64 %indvars.iv33.i.i, 80" (1.239042e+01%)
Noelle:     Loop "  %exitcond32.i.i = icmp eq i64 %indvars.iv30.i.i, 20" (4.636530e+00%)
Noelle:     Loop "  %exitcond29.i.i = icmp eq i64 %indvars.iv27.i.i, 40" (4.285277e+00%)
Noelle:     Loop "  %exitcond26.i.i = icmp eq i64 %indvars.iv24.i.i, 60" (4.636530e+00%)
Noelle:     Loop "  %exitcond.i2.i = icmp eq i64 %indvars.iv.i.i, 80" (4.285277e+00%)
Noelle:  Function "sha_transform"
Noelle:     Loop "  %exitcond38 = icmp eq i64 %indvars.iv36, 16" (1.291552e+00%)
Noelle:     Loop "  %exitcond35 = icmp eq i64 %indvars.iv33, 80" (1.237298e+01%)
Noelle:     Loop "  %exitcond32 = icmp eq i64 %indvars.iv30, 20" (4.639046e+00%)
Noelle:     Loop "  %exitcond29 = icmp eq i64 %indvars.iv27, 40" (4.287603e+00%)
Noelle:     Loop "  %exitcond26 = icmp eq i64 %indvars.iv24, 60" (4.639046e+00%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 80" (4.287603e+00%)
Noelle:  Function "byte_reverse"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 8" (1.300339e+00%)
Noelle:  Function "sha_final"
Noelle:  Function "sha_init"
Noelle:  Function "sha_print"
NOELLE: FixedPoint:       There are 11 different instructions and 11 different loop instructions
NOELLE: FixedPoint:       Normalize the code
noelle-norm /tmp/tmp.miMFSnbqIK -o /tmp/tmp.miMFSnbqIK
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.miMFSnbqIK -o /tmp/tmp.miMFSnbqIK
NOELLE: FixedPoint:     Invocation 4
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.uQjaPIBrDF -o /tmp/tmp.miMFSnbqIK
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.uQjaPIBrDF -o /tmp/tmp.miMFSnbqIK
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.uQjaPIBrDF -o /tmp/tmp.miMFSnbqIK
Inliner: Start
Inliner:   Number of program instructions = 793
Inliner:   Profiles are available and will be used
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca [80 x i64], align 16 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca [8192 x i8], align 16 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca [80 x i64], align 16 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   We found an SCC of the loop that is non clonable and non commutative
DOALL:     Internal nodes: 214
DOALL:     	  %21 = phi i64 [ %20, %19 ], [ %18, %.._crit_edge_crit_edge.i ]
DOALL:     	  %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7
DOALL:     	  %8 = trunc i64 %7 to i32
DOALL:     	  %9 = icmp sgt i32 %8, 0
DOALL:     	  br i1 %9, label %10, label %148, !prof !30
DOALL:     	  %11 = getelementptr inbounds %struct.SHA_INFO, %struct.SHA_INFO* %0, i64 0, i32 1
DOALL:     	  %12 = load i64, i64* %11, align 8, !tbaa !31
DOALL:     	  %13 = sext i32 %8 to i64
DOALL:     	  %14 = shl nsw i64 %13, 3
DOALL:     	  %15 = add i64 %12, %14
DOALL:     	  %16 = icmp ult i64 %15, %12
DOALL:     	  %17 = getelementptr inbounds %struct.SHA_INFO, %struct.SHA_INFO* %0, i64 0, i32 2
DOALL:     	  %18 = load i64, i64* %17, align 8, !tbaa !36
DOALL:     	  br i1 %16, label %19, label %.._crit_edge_crit_edge.i, !prof !37
DOALL:     	  %20 = add i64 %18, 1
DOALL:     	  store i64 %20, i64* %17, align 8, !tbaa !36
DOALL:     	  store i64 %15, i64* %11, align 8, !tbaa !31
DOALL:     	  %22 = lshr i64 %13, 29
DOALL:     	  %23 = add i64 %21, %22
DOALL:     	  store i64 %23, i64* %17, align 8, !tbaa !36
DOALL:     	  %24 = getelementptr inbounds %struct.SHA_INFO, %struct.SHA_INFO* %0, i64 0, i32 3, i64 0
DOALL:     	  %25 = bitcast i64* %24 to i8*
DOALL:     	  %.01.i = phi i8* [ %5, %._crit_edge.i ], [ %145, %sha_transform.exit.i ]
DOALL:     	  %.0.i = phi i32 [ %8, %._crit_edge.i ], [ %146, %sha_transform.exit.i ]
DOALL:     	  %27 = icmp sgt i32 %.0.i, 63
DOALL:     	  br i1 %27, label %28, label %sha_update.exit, !prof !38
DOALL:     	  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7
DOALL:     	  %29 = bitcast i64* %24 to i8*
DOALL:     	  %.01.i.i = phi i32 [ 0, %28 ], [ %40, %31 ]
DOALL:     	  %.0.i.i = phi i8* [ %29, %28 ], [ %39, %31 ]
DOALL:     	  %exitcond.i.i = icmp eq i32 %.01.i.i, 8
DOALL:     	  br i1 %exitcond.i.i, label %byte_reverse.exit.i, label %31, !prof !39
DOALL:     	  %32 = load i8, i8* %.0.i.i, align 1, !tbaa !40
DOALL:     	  %33 = getelementptr inbounds i8, i8* %.0.i.i, i64 1
DOALL:     	  %34 = load i8, i8* %33, align 1, !tbaa !40
DOALL:     	  %35 = getelementptr inbounds i8, i8* %.0.i.i, i64 2
DOALL:     	  %36 = load i8, i8* %35, align 1, !tbaa !40
DOALL:     	  %37 = getelementptr inbounds i8, i8* %.0.i.i, i64 3
DOALL:     	  %38 = load i8, i8* %37, align 1, !tbaa !40
DOALL:     	  store i8 %38, i8* %.0.i.i, align 1, !tbaa !40
DOALL:     	  store i8 %36, i8* %33, align 1, !tbaa !40
DOALL:     	  store i8 %34, i8* %35, align 1, !tbaa !40
DOALL:     	  store i8 %32, i8* %37, align 1, !tbaa !40
DOALL:     	  %39 = getelementptr inbounds i8, i8* %.0.i.i, i64 8
DOALL:     	  %40 = add nuw nsw i32 %.01.i.i, 1
DOALL:     	  %indvars.iv36.i.i = phi i64 [ %indvars.iv.next37.i.i, %43 ], [ 0, %byte_reverse.exit.i ]
DOALL:     	  %exitcond38.i.i = icmp eq i64 %indvars.iv36.i.i, 16
DOALL:     	  br i1 %exitcond38.i.i, label %.preheader23.preheader.i.i, label %43, !prof !41
DOALL:     	  %44 = getelementptr inbounds %struct.SHA_INFO, %struct.SHA_INFO* %0, i64 0, i32 3, i64 %indvars.iv36.i.i
DOALL:     	  %45 = load i64, i64* %44, align 8, !tbaa !42
DOALL:     	  %indvars.iv.next37.i.i = add nuw nsw i64 %indvars.iv36.i.i, 1
DOALL:     	  %indvars.iv33.i.i = phi i64 [ %indvars.iv.next34.i.i, %47 ], [ 16, %.preheader23.preheader.i.i ]
DOALL:     	  %exitcond35.i.i = icmp eq i64 %indvars.iv33.i.i, 80
DOALL:     	  br i1 %exitcond35.i.i, label %64, label %47, !prof !43
DOALL:     	  %48 = add nsw i64 %indvars.iv33.i.i, -3
DOALL:     	  %49 = getelementptr inbounds [80 x i64], [80 x i64]* %3, i64 0, i64 %48
DOALL:     	  %50 = load i64, i64* %49, align 8, !tbaa !42
DOALL:     	  %51 = add nsw i64 %indvars.iv33.i.i, -8
DOALL:     	  %52 = getelementptr inbounds [80 x i64], [80 x i64]* %3, i64 0, i64 %51
DOALL:     	  %53 = load i64, i64* %52, align 8, !tbaa !42
DOALL:     	  %54 = xor i64 %50, %53
DOALL:     	  %55 = add nsw i64 %indvars.iv33.i.i, -14
DOALL:     	  %56 = getelementptr inbounds [80 x i64], [80 x i64]* %3, i64 0, i64 %55
DOALL:     	  %57 = load i64, i64* %56, align 8, !tbaa !42
DOALL:     	  %58 = xor i64 %54, %57
DOALL:     	  %59 = add nsw i64 %indvars.iv33.i.i, -16
DOALL:     	  %60 = getelementptr inbounds [80 x i64], [80 x i64]* %3, i64 0, i64 %59
DOALL:     	  %61 = load i64, i64* %60, align 8, !tbaa !42
DOALL:     	  %62 = xor i64 %58, %61
DOALL:     	  %63 = getelementptr inbounds [80 x i64], [80 x i64]* %3, i64 0, i64 %indvars.iv33.i.i
DOALL:     	  store i64 %62, i64* %63, align 8, !tbaa !42
DOALL:     	  %indvars.iv.next34.i.i = add nuw nsw i64 %indvars.iv33.i.i, 1
DOALL:     	  %65 = getelementptr inbounds %struct.SHA_INFO, %struct.SHA_INFO* %0, i64 0, i32 0, i64 0
DOALL:     	  %66 = load i64, i64* %65, align 8, !tbaa !42
DOALL:     	  %67 = getelementptr inbounds %struct.SHA_INFO, %struct.SHA_INFO* %0, i64 0, i32 0, i64 1
DOALL:     	  %68 = load i64, i64* %67, align 8, !tbaa !42
DOALL:     	  %69 = getelementptr inbounds %struct.SHA_INFO, %struct.SHA_INFO* %0, i64 0, i32 0, i64 2
DOALL:     	  %70 = load i64, i64* %69, align 8, !tbaa !42
DOALL:     	  %71 = getelementptr inbounds %struct.SHA_INFO, %struct.SHA_INFO* %0, i64 0, i32 0, i64 3
DOALL:     	  %72 = load i64, i64* %71, align 8, !tbaa !42
DOALL:     	  %73 = getelementptr inbounds %struct.SHA_INFO, %struct.SHA_INFO* %0, i64 0, i32 0, i64 4
DOALL:     	  %74 = load i64, i64* %73, align 8, !tbaa !42
DOALL:     	  %indvars.iv30.i.i = phi i64 [ %indvars.iv.next31.i.i, %76 ], [ 0, %64 ]
DOALL:     	  %.017.i.i = phi i64 [ %.013.i.i, %76 ], [ %72, %64 ]
DOALL:     	  %.013.i.i = phi i64 [ %92, %76 ], [ %70, %64 ]
DOALL:     	  %.09.i.i = phi i64 [ %.05.i.i, %76 ], [ %68, %64 ]
DOALL:     	  %.05.i.i = phi i64 [ %89, %76 ], [ %66, %64 ]
DOALL:     	  %.0.i1.i = phi i64 [ %.017.i.i, %76 ], [ %74, %64 ]
DOALL:     	  %exitcond32.i.i = icmp eq i64 %indvars.iv30.i.i, 20
DOALL:     	  br i1 %exitcond32.i.i, label %.preheader22.preheader.i.i, label %76, !prof !44
DOALL:     	  %.017.i.i.lcssa = phi i64 [ %.017.i.i, %75 ]
DOALL:     	  %.013.i.i.lcssa = phi i64 [ %.013.i.i, %75 ]
DOALL:     	  %.09.i.i.lcssa = phi i64 [ %.09.i.i, %75 ]
DOALL:     	  %.05.i.i.lcssa = phi i64 [ %.05.i.i, %75 ]
DOALL:     	  %.0.i1.i.lcssa = phi i64 [ %.0.i1.i, %75 ]
DOALL:     	  %77 = shl i64 %.05.i.i, 5
DOALL:     	  %78 = lshr i64 %.05.i.i, 27
DOALL:     	  %79 = or i64 %77, %78
DOALL:     	  %80 = and i64 %.09.i.i, %.013.i.i
DOALL:     	  %81 = xor i64 %.09.i.i, -1
DOALL:     	  %82 = and i64 %.017.i.i, %81
DOALL:     	  %83 = or i64 %80, %82
DOALL:     	  %84 = add i64 %79, %83
DOALL:     	  %85 = add i64 %84, %.0.i1.i
DOALL:     	  %86 = getelementptr inbounds [80 x i64], [80 x i64]* %3, i64 0, i64 %indvars.iv30.i.i
DOALL:     	  %87 = load i64, i64* %86, align 8, !tbaa !42
DOALL:     	  %88 = add i64 %85, %87
DOALL:     	  %89 = add i64 %88, 1518500249
DOALL:     	  %90 = shl i64 %.09.i.i, 30
DOALL:     	  %91 = lshr i64 %.09.i.i, 2
DOALL:     	  %92 = or i64 %90, %91
DOALL:     	  %indvars.iv.next31.i.i = add nuw nsw i64 %indvars.iv30.i.i, 1
DOALL:     	  %indvars.iv27.i.i = phi i64 [ %indvars.iv.next28.i.i, %93 ], [ 20, %.preheader22.preheader.i.i ]
DOALL:     	  %.118.i.i = phi i64 [ %.114.i.i, %93 ], [ %.017.i.i.lcssa, %.preheader22.preheader.i.i ]
DOALL:     	  %.114.i.i = phi i64 [ %107, %93 ], [ %.013.i.i.lcssa, %.preheader22.preheader.i.i ]
DOALL:     	  %.110.i.i = phi i64 [ %.16.i.i, %93 ], [ %.09.i.i.lcssa, %.preheader22.preheader.i.i ]
DOALL:     	  %.16.i.i = phi i64 [ %104, %93 ], [ %.05.i.i.lcssa, %.preheader22.preheader.i.i ]
DOALL:     	  %.1.i.i = phi i64 [ %.118.i.i, %93 ], [ %.0.i1.i.lcssa, %.preheader22.preheader.i.i ]
DOALL:     	  %exitcond29.i.i = icmp eq i64 %indvars.iv27.i.i, 40
DOALL:     	  br i1 %exitcond29.i.i, label %.preheader21.preheader.i.i, label %93, !prof !44
DOALL:     	  %.118.i.i.lcssa = phi i64 [ %.118.i.i, %.preheader22.i.i ]
DOALL:     	  %.114.i.i.lcssa = phi i64 [ %.114.i.i, %.preheader22.i.i ]
DOALL:     	  %.110.i.i.lcssa = phi i64 [ %.110.i.i, %.preheader22.i.i ]
DOALL:     	  %.16.i.i.lcssa = phi i64 [ %.16.i.i, %.preheader22.i.i ]
DOALL:     	  %.1.i.i.lcssa = phi i64 [ %.1.i.i, %.preheader22.i.i ]
DOALL:     	  %94 = shl i64 %.16.i.i, 5
DOALL:     	  %95 = lshr i64 %.16.i.i, 27
DOALL:     	  %96 = or i64 %94, %95
DOALL:     	  %97 = xor i64 %.110.i.i, %.114.i.i
DOALL:     	  %98 = xor i64 %97, %.118.i.i
DOALL:     	  %99 = add i64 %96, %98
DOALL:     	  %100 = add i64 %99, %.1.i.i
DOALL:     	  %101 = getelementptr inbounds [80 x i64], [80 x i64]* %3, i64 0, i64 %indvars.iv27.i.i
DOALL:     	  %102 = load i64, i64* %101, align 8, !tbaa !42
DOALL:     	  %103 = add i64 %100, %102
DOALL:     	  %104 = add i64 %103, 1859775393
DOALL:     	  %105 = shl i64 %.110.i.i, 30
DOALL:     	  %106 = lshr i64 %.110.i.i, 2
DOALL:     	  %107 = or i64 %105, %106
DOALL:     	  %indvars.iv.next28.i.i = add nuw nsw i64 %indvars.iv27.i.i, 1
DOALL:     	  %indvars.iv24.i.i = phi i64 [ %indvars.iv.next25.i.i, %108 ], [ 40, %.preheader21.preheader.i.i ]
DOALL:     	  %.219.i.i = phi i64 [ %.215.i.i, %108 ], [ %.118.i.i.lcssa, %.preheader21.preheader.i.i ]
DOALL:     	  %.215.i.i = phi i64 [ %124, %108 ], [ %.114.i.i.lcssa, %.preheader21.preheader.i.i ]
DOALL:     	  %.211.i.i = phi i64 [ %.27.i.i, %108 ], [ %.110.i.i.lcssa, %.preheader21.preheader.i.i ]
DOALL:     	  %.27.i.i = phi i64 [ %121, %108 ], [ %.16.i.i.lcssa, %.preheader21.preheader.i.i ]
DOALL:     	  %.2.i.i = phi i64 [ %.219.i.i, %108 ], [ %.1.i.i.lcssa, %.preheader21.preheader.i.i ]
DOALL:     	  %exitcond26.i.i = icmp eq i64 %indvars.iv24.i.i, 60
DOALL:     	  br i1 %exitcond26.i.i, label %.preheader.preheader.i.i, label %108, !prof !44
DOALL:     	  %.219.i.i.lcssa = phi i64 [ %.219.i.i, %.preheader21.i.i ]
DOALL:     	  %.215.i.i.lcssa = phi i64 [ %.215.i.i, %.preheader21.i.i ]
DOALL:     	  %.211.i.i.lcssa = phi i64 [ %.211.i.i, %.preheader21.i.i ]
DOALL:     	  %.27.i.i.lcssa = phi i64 [ %.27.i.i, %.preheader21.i.i ]
DOALL:     	  %.2.i.i.lcssa = phi i64 [ %.2.i.i, %.preheader21.i.i ]
DOALL:     	  %109 = shl i64 %.27.i.i, 5
DOALL:     	  %110 = lshr i64 %.27.i.i, 27
DOALL:     	  %111 = or i64 %109, %110
DOALL:     	  %112 = or i64 %.215.i.i, %.219.i.i
DOALL:     	  %113 = and i64 %.211.i.i, %112
DOALL:     	  %114 = and i64 %.215.i.i, %.219.i.i
DOALL:     	  %115 = or i64 %113, %114
DOALL:     	  %116 = add i64 %111, %115
DOALL:     	  %117 = add i64 %116, %.2.i.i
DOALL:     	  %118 = getelementptr inbounds [80 x i64], [80 x i64]* %3, i64 0, i64 %indvars.iv24.i.i
DOALL:     	  %119 = load i64, i64* %118, align 8, !tbaa !42
DOALL:     	  %120 = add i64 %117, %119
DOALL:     	  %121 = add i64 %120, 2400959708
DOALL:     	  %122 = shl i64 %.211.i.i, 30
DOALL:     	  %123 = lshr i64 %.211.i.i, 2
DOALL:     	  %124 = or i64 %122, %123
DOALL:     	  %indvars.iv.next25.i.i = add nuw nsw i64 %indvars.iv24.i.i, 1
DOALL:     	  %indvars.iv.i.i = phi i64 [ %indvars.iv.next.i.i, %125 ], [ 60, %.preheader.preheader.i.i ]
DOALL:     	  %.320.i.i = phi i64 [ %.316.i.i, %125 ], [ %.219.i.i.lcssa, %.preheader.preheader.i.i ]
DOALL:     	  %.316.i.i = phi i64 [ %139, %125 ], [ %.215.i.i.lcssa, %.preheader.preheader.i.i ]
DOALL:     	  %.312.i.i = phi i64 [ %.38.i.i, %125 ], [ %.211.i.i.lcssa, %.preheader.preheader.i.i ]
DOALL:     	  %.38.i.i = phi i64 [ %136, %125 ], [ %.27.i.i.lcssa, %.preheader.preheader.i.i ]
DOALL:     	  %.3.i.i = phi i64 [ %.320.i.i, %125 ], [ %.2.i.i.lcssa, %.preheader.preheader.i.i ]
DOALL:     	  %exitcond.i2.i = icmp eq i64 %indvars.iv.i.i, 80
DOALL:     	  br i1 %exitcond.i2.i, label %sha_transform.exit.i, label %125, !prof !44
DOALL:     	  %126 = shl i64 %.38.i.i, 5
DOALL:     	  %127 = lshr i64 %.38.i.i, 27
DOALL:     	  %128 = or i64 %126, %127
DOALL:     	  %129 = xor i64 %.312.i.i, %.316.i.i
DOALL:     	  %130 = xor i64 %129, %.320.i.i
DOALL:     	  %131 = add i64 %128, %130
DOALL:     	  %132 = add i64 %131, %.3.i.i
DOALL:     	  %133 = getelementptr inbounds [80 x i64], [80 x i64]* %3, i64 0, i64 %indvars.iv.i.i
DOALL:     	  %134 = load i64, i64* %133, align 8, !tbaa !42
DOALL:     	  %135 = add i64 %132, %134
DOALL:     	  %136 = add i64 %135, 3395469782
DOALL:     	  %137 = shl i64 %.312.i.i, 30
DOALL:     	  %138 = lshr i64 %.312.i.i, 2
DOALL:     	  %139 = or i64 %137, %138
DOALL:     	  %indvars.iv.next.i.i = add nuw nsw i64 %indvars.iv.i.i, 1
DOALL:     	  %.320.i.i.lcssa = phi i64 [ %.320.i.i, %.preheader.i.i ]
DOALL:     	  %.316.i.i.lcssa = phi i64 [ %.316.i.i, %.preheader.i.i ]
DOALL:     	  %.312.i.i.lcssa = phi i64 [ %.312.i.i, %.preheader.i.i ]
DOALL:     	  %.38.i.i.lcssa = phi i64 [ %.38.i.i, %.preheader.i.i ]
DOALL:     	  %.3.i.i.lcssa = phi i64 [ %.3.i.i, %.preheader.i.i ]
DOALL:     	  %140 = add i64 %66, %.38.i.i.lcssa
DOALL:     	  store i64 %140, i64* %65, align 8, !tbaa !42
DOALL:     	  %141 = add i64 %68, %.312.i.i.lcssa
DOALL:     	  store i64 %141, i64* %67, align 8, !tbaa !42
DOALL:     	  %142 = add i64 %70, %.316.i.i.lcssa
DOALL:     	  store i64 %142, i64* %69, align 8, !tbaa !42
DOALL:     	  %143 = add i64 %72, %.320.i.i.lcssa
DOALL:     	  store i64 %143, i64* %71, align 8, !tbaa !42
DOALL:     	  %144 = add i64 %74, %.3.i.i.lcssa
DOALL:     	  store i64 %144, i64* %73, align 8, !tbaa !42
DOALL:     	  %145 = getelementptr inbounds i8, i8* %.01.i, i64 64
DOALL:     	  %146 = add nsw i32 %.0.i, -64
DOALL:     	  %.01.i.lcssa = phi i8* [ %.01.i, %26 ]
DOALL:     	  %.0.i.lcssa = phi i32 [ %.0.i, %26 ]
DOALL:     	  %147 = sext i32 %.0.i.lcssa to i64
DOALL:     	  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45
DOALL:     External nodes: 24
DOALL:     	  br label %._crit_edge.i
DOALL:     	  br label %._crit_edge.i
DOALL:     	  br label %26
DOALL:     	  br label %30
DOALL:     	  br label %30
DOALL:     	  %41 = bitcast [80 x i64]* %3 to i8*
DOALL:     	  call void @llvm.lifetime.start.p0i8(i64 640, i8* nonnull %41) #7
DOALL:     	  br label %42
DOALL:     	  br label %.preheader23.i.i
DOALL:     	  %46 = getelementptr inbounds [80 x i64], [80 x i64]* %3, i64 0, i64 %indvars.iv36.i.i
DOALL:     	  store i64 %45, i64* %46, align 8, !tbaa !42
DOALL:     	  br label %42
DOALL:     	  br label %.preheader23.i.i
DOALL:     	  br label %75
DOALL:     	  br label %.preheader22.i.i
DOALL:     	  br label %75
DOALL:     	  br label %.preheader21.i.i
DOALL:     	  br label %.preheader22.i.i
DOALL:     	  br label %.preheader.i.i
DOALL:     	  br label %.preheader21.i.i
DOALL:     	  br label %.preheader.i.i
DOALL:     	  call void @llvm.lifetime.end.p0i8(i64 640, i8* nonnull %41) #7
DOALL:     	  br label %26
DOALL:     	  br label %6
DOALL:     Edges: 899
DOALL:     Loop-carried data dependences
DOALL:         %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 --->   store i8 %32, i8* %37, align 1, !tbaa !40 via memory
DOALL:         %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 --->   store i8 %32, i8* %37, align 1, !tbaa !40 via memory
DOALL:         %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 --->   store i8 %36, i8* %33, align 1, !tbaa !40 via memory
DOALL:         %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 --->   store i8 %34, i8* %35, align 1, !tbaa !40 via memory
DOALL:         %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 --->   store i8 %34, i8* %35, align 1, !tbaa !40 via memory
DOALL:         %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 --->   %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 via memory
DOALL:         %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 --->   %38 = load i8, i8* %37, align 1, !tbaa !40 via memory
DOALL:         %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 --->   %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 via memory
DOALL:         %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 --->   %34 = load i8, i8* %33, align 1, !tbaa !40 via memory
DOALL:         %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 --->   %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 via memory
DOALL:         %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 --->   store i8 %36, i8* %33, align 1, !tbaa !40 via memory
DOALL:         %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 --->   %36 = load i8, i8* %35, align 1, !tbaa !40 via memory
DOALL:         %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 --->   %32 = load i8, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i64 %15, i64* %11, align 8, !tbaa !31 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i64 %15, i64* %11, align 8, !tbaa !31 --->   store i8 %32, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i64 %15, i64* %11, align 8, !tbaa !31 --->   store i8 %34, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i64 %15, i64* %11, align 8, !tbaa !31 --->   store i8 %36, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i64 %15, i64* %11, align 8, !tbaa !31 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i64 %15, i64* %11, align 8, !tbaa !31 --->   %38 = load i8, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i64 %15, i64* %11, align 8, !tbaa !31 --->   %36 = load i8, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i64 %15, i64* %11, align 8, !tbaa !31 --->   store i64 %15, i64* %11, align 8, !tbaa !31 via memory
DOALL:         store i64 %15, i64* %11, align 8, !tbaa !31 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i64 %15, i64* %11, align 8, !tbaa !31 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i64 %15, i64* %11, align 8, !tbaa !31 --->   %12 = load i64, i64* %11, align 8, !tbaa !31 via memory
DOALL:         store i64 %15, i64* %11, align 8, !tbaa !31 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i64 %15, i64* %11, align 8, !tbaa !31 --->   %32 = load i8, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i64 %15, i64* %11, align 8, !tbaa !31 --->   %34 = load i8, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i64 %23, i64* %17, align 8, !tbaa !36 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i64 %23, i64* %17, align 8, !tbaa !36 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i64 %23, i64* %17, align 8, !tbaa !36 --->   store i8 %34, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i64 %23, i64* %17, align 8, !tbaa !36 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i64 %23, i64* %17, align 8, !tbaa !36 --->   %36 = load i8, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i64 %23, i64* %17, align 8, !tbaa !36 --->   store i8 %32, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i64 %23, i64* %17, align 8, !tbaa !36 --->   %34 = load i8, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i64 %23, i64* %17, align 8, !tbaa !36 --->   store i64 %20, i64* %17, align 8, !tbaa !36 via memory
DOALL:         store i64 %23, i64* %17, align 8, !tbaa !36 --->   %18 = load i64, i64* %17, align 8, !tbaa !36 via memory
DOALL:         store i64 %23, i64* %17, align 8, !tbaa !36 --->   %32 = load i8, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i64 %23, i64* %17, align 8, !tbaa !36 --->   store i64 %23, i64* %17, align 8, !tbaa !36 via memory
DOALL:         store i64 %23, i64* %17, align 8, !tbaa !36 --->   store i8 %36, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i64 %23, i64* %17, align 8, !tbaa !36 --->   %38 = load i8, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i64 %23, i64* %17, align 8, !tbaa !36 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i64 %23, i64* %17, align 8, !tbaa !36 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i64 %144, i64* %73, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   %45 = load i64, i64* %44, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i64 %23, i64* %17, align 8, !tbaa !36 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i64 %144, i64* %73, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   %38 = load i8, i8* %37, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   %18 = load i64, i64* %17, align 8, !tbaa !36 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i64 %140, i64* %65, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   %32 = load i8, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   %12 = load i64, i64* %11, align 8, !tbaa !31 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   %34 = load i8, i8* %33, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i64 %141, i64* %67, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   %68 = load i64, i64* %67, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i64 %143, i64* %71, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i8 %36, i8* %33, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   %74 = load i64, i64* %73, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   %36 = load i8, i8* %35, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i64 %20, i64* %17, align 8, !tbaa !36 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i64 %20, i64* %17, align 8, !tbaa !36 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i64 %143, i64* %71, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   %72 = load i64, i64* %71, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i64 %23, i64* %17, align 8, !tbaa !36 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i64 %15, i64* %11, align 8, !tbaa !31 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i8 %32, i8* %37, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i8 %36, i8* %33, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i8 %34, i8* %35, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   %70 = load i64, i64* %69, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i64 %15, i64* %11, align 8, !tbaa !31 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i8 %34, i8* %35, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i8 %32, i8* %37, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i64 %141, i64* %67, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i64 %142, i64* %69, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 --->   store i64 %142, i64* %69, align 8, !tbaa !42 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   %45 = load i64, i64* %44, align 8, !tbaa !42 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   store i64 %142, i64* %69, align 8, !tbaa !42 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   store i64 %141, i64* %67, align 8, !tbaa !42 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   store i64 %140, i64* %65, align 8, !tbaa !42 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   %74 = load i64, i64* %73, align 8, !tbaa !42 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   %68 = load i64, i64* %67, align 8, !tbaa !42 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   %66 = load i64, i64* %65, align 8, !tbaa !42 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   store i64 %15, i64* %11, align 8, !tbaa !31 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   store i64 %20, i64* %17, align 8, !tbaa !36 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   store i64 %23, i64* %17, align 8, !tbaa !36 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   %18 = load i64, i64* %17, align 8, !tbaa !36 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   %12 = load i64, i64* %11, align 8, !tbaa !31 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   %32 = load i8, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   %70 = load i64, i64* %69, align 8, !tbaa !42 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   %38 = load i8, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   %34 = load i8, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   %72 = load i64, i64* %71, align 8, !tbaa !42 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   %36 = load i8, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   store i64 %143, i64* %71, align 8, !tbaa !42 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   store i64 %144, i64* %73, align 8, !tbaa !42 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   store i8 %36, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   store i8 %34, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 --->   store i8 %32, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   store i64 %142, i64* %69, align 8, !tbaa !42 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   store i64 %143, i64* %71, align 8, !tbaa !42 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   store i64 %141, i64* %67, align 8, !tbaa !42 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   %72 = load i64, i64* %71, align 8, !tbaa !42 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   %70 = load i64, i64* %69, align 8, !tbaa !42 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   %68 = load i64, i64* %67, align 8, !tbaa !42 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   store i64 %144, i64* %73, align 8, !tbaa !42 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   store i64 %140, i64* %65, align 8, !tbaa !42 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   %12 = load i64, i64* %11, align 8, !tbaa !31 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   %74 = load i64, i64* %73, align 8, !tbaa !42 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   store i64 %15, i64* %11, align 8, !tbaa !31 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   %32 = load i8, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   %45 = load i64, i64* %44, align 8, !tbaa !42 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   store i64 %20, i64* %17, align 8, !tbaa !36 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   store i64 %23, i64* %17, align 8, !tbaa !36 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   store i8 %36, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   %34 = load i8, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   %66 = load i64, i64* %65, align 8, !tbaa !42 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   %18 = load i64, i64* %17, align 8, !tbaa !36 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i8 %36, i8* %33, align 1, !tbaa !40 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   store i64 %141, i64* %67, align 8, !tbaa !42 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   store i64 %142, i64* %69, align 8, !tbaa !42 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   store i64 %140, i64* %65, align 8, !tbaa !42 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   store i64 %143, i64* %71, align 8, !tbaa !42 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   %74 = load i64, i64* %73, align 8, !tbaa !42 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   store i64 %144, i64* %73, align 8, !tbaa !42 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   %72 = load i64, i64* %71, align 8, !tbaa !42 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   %32 = load i8, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   store i64 %23, i64* %17, align 8, !tbaa !36 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   store i64 %20, i64* %17, align 8, !tbaa !36 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   %18 = load i64, i64* %17, align 8, !tbaa !36 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   store i64 %15, i64* %11, align 8, !tbaa !31 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   %12 = load i64, i64* %11, align 8, !tbaa !31 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   %45 = load i64, i64* %44, align 8, !tbaa !42 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   store i8 %34, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   %36 = load i8, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   %70 = load i64, i64* %69, align 8, !tbaa !42 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   %66 = load i64, i64* %65, align 8, !tbaa !42 via memory
DOALL:         store i8 %34, i8* %35, align 1, !tbaa !40 --->   %68 = load i64, i64* %67, align 8, !tbaa !42 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   store i64 %144, i64* %73, align 8, !tbaa !42 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   store i64 %143, i64* %71, align 8, !tbaa !42 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   store i64 %142, i64* %69, align 8, !tbaa !42 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   store i64 %141, i64* %67, align 8, !tbaa !42 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   store i64 %140, i64* %65, align 8, !tbaa !42 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   %70 = load i64, i64* %69, align 8, !tbaa !42 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   %18 = load i64, i64* %17, align 8, !tbaa !36 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   store i64 %20, i64* %17, align 8, !tbaa !36 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   store i64 %15, i64* %11, align 8, !tbaa !31 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   %12 = load i64, i64* %11, align 8, !tbaa !31 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   %72 = load i64, i64* %71, align 8, !tbaa !42 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   store i64 %23, i64* %17, align 8, !tbaa !36 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   %74 = load i64, i64* %73, align 8, !tbaa !42 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   %32 = load i8, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   %38 = load i8, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   store i8 %32, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   %45 = load i64, i64* %44, align 8, !tbaa !42 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   %66 = load i64, i64* %65, align 8, !tbaa !42 via memory
DOALL:         store i8 %32, i8* %37, align 1, !tbaa !40 --->   %68 = load i64, i64* %67, align 8, !tbaa !42 via memory
DOALL:         %45 = load i64, i64* %44, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         %45 = load i64, i64* %44, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         %45 = load i64, i64* %44, align 8, !tbaa !42 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         %45 = load i64, i64* %44, align 8, !tbaa !42 --->   store i8 %36, i8* %33, align 1, !tbaa !40 via memory
DOALL:         %45 = load i64, i64* %44, align 8, !tbaa !42 --->   store i8 %34, i8* %35, align 1, !tbaa !40 via memory
DOALL:         %45 = load i64, i64* %44, align 8, !tbaa !42 --->   store i8 %32, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i64 %140, i64* %65, align 8, !tbaa !42 --->   %66 = load i64, i64* %65, align 8, !tbaa !42 via memory
DOALL:         store i64 %140, i64* %65, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i64 %140, i64* %65, align 8, !tbaa !42 --->   store i8 %32, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i64 %140, i64* %65, align 8, !tbaa !42 --->   store i64 %140, i64* %65, align 8, !tbaa !42 via memory
DOALL:         store i64 %140, i64* %65, align 8, !tbaa !42 --->   store i8 %34, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i64 %140, i64* %65, align 8, !tbaa !42 --->   store i8 %36, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i64 %140, i64* %65, align 8, !tbaa !42 --->   %32 = load i8, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i64 %140, i64* %65, align 8, !tbaa !42 --->   %34 = load i8, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i64 %140, i64* %65, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i64 %140, i64* %65, align 8, !tbaa !42 --->   %36 = load i8, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i64 %140, i64* %65, align 8, !tbaa !42 --->   %38 = load i8, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i64 %140, i64* %65, align 8, !tbaa !42 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i64 %141, i64* %67, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i64 %141, i64* %67, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i64 %141, i64* %67, align 8, !tbaa !42 --->   store i64 %141, i64* %67, align 8, !tbaa !42 via memory
DOALL:         store i64 %141, i64* %67, align 8, !tbaa !42 --->   store i8 %32, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i64 %141, i64* %67, align 8, !tbaa !42 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i64 %141, i64* %67, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i64 %141, i64* %67, align 8, !tbaa !42 --->   %68 = load i64, i64* %67, align 8, !tbaa !42 via memory
DOALL:         store i64 %141, i64* %67, align 8, !tbaa !42 --->   %32 = load i8, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i64 %141, i64* %67, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i64 %141, i64* %67, align 8, !tbaa !42 --->   %34 = load i8, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i64 %141, i64* %67, align 8, !tbaa !42 --->   store i8 %36, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i64 %141, i64* %67, align 8, !tbaa !42 --->   %36 = load i8, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i64 %141, i64* %67, align 8, !tbaa !42 --->   store i8 %34, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i64 %141, i64* %67, align 8, !tbaa !42 --->   %38 = load i8, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i64 %142, i64* %69, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i64 %142, i64* %69, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i64 %142, i64* %69, align 8, !tbaa !42 --->   store i64 %142, i64* %69, align 8, !tbaa !42 via memory
DOALL:         store i64 %142, i64* %69, align 8, !tbaa !42 --->   store i8 %32, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i64 %142, i64* %69, align 8, !tbaa !42 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i64 %142, i64* %69, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i64 %142, i64* %69, align 8, !tbaa !42 --->   %70 = load i64, i64* %69, align 8, !tbaa !42 via memory
DOALL:         store i64 %142, i64* %69, align 8, !tbaa !42 --->   %32 = load i8, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i64 %142, i64* %69, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i64 %142, i64* %69, align 8, !tbaa !42 --->   %34 = load i8, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i64 %142, i64* %69, align 8, !tbaa !42 --->   store i8 %36, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i64 %142, i64* %69, align 8, !tbaa !42 --->   %36 = load i8, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i64 %142, i64* %69, align 8, !tbaa !42 --->   store i8 %34, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i64 %142, i64* %69, align 8, !tbaa !42 --->   %38 = load i8, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i64 %143, i64* %71, align 8, !tbaa !42 --->   store i8 %32, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i64 %143, i64* %71, align 8, !tbaa !42 --->   store i8 %34, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i64 %143, i64* %71, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i64 %143, i64* %71, align 8, !tbaa !42 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i64 %143, i64* %71, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i64 %143, i64* %71, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i64 %143, i64* %71, align 8, !tbaa !42 --->   %32 = load i8, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i64 %143, i64* %71, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i64 %143, i64* %71, align 8, !tbaa !42 --->   %34 = load i8, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i64 %143, i64* %71, align 8, !tbaa !42 --->   %72 = load i64, i64* %71, align 8, !tbaa !42 via memory
DOALL:         store i64 %143, i64* %71, align 8, !tbaa !42 --->   store i8 %36, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i64 %143, i64* %71, align 8, !tbaa !42 --->   %36 = load i8, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i64 %143, i64* %71, align 8, !tbaa !42 --->   store i64 %143, i64* %71, align 8, !tbaa !42 via memory
DOALL:         store i64 %143, i64* %71, align 8, !tbaa !42 --->   %38 = load i8, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i64 %144, i64* %73, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i64 %144, i64* %73, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         store i64 %144, i64* %73, align 8, !tbaa !42 --->   store i64 %144, i64* %73, align 8, !tbaa !42 via memory
DOALL:         store i64 %144, i64* %73, align 8, !tbaa !42 --->   %74 = load i64, i64* %73, align 8, !tbaa !42 via memory
DOALL:         store i64 %144, i64* %73, align 8, !tbaa !42 --->   store i8 %32, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i64 %144, i64* %73, align 8, !tbaa !42 --->   store i8 %34, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i64 %144, i64* %73, align 8, !tbaa !42 --->   store i8 %36, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i64 %144, i64* %73, align 8, !tbaa !42 --->   %34 = load i8, i8* %33, align 1, !tbaa !40 via memory
DOALL:         store i64 %144, i64* %73, align 8, !tbaa !42 --->   %38 = load i8, i8* %37, align 1, !tbaa !40 via memory
DOALL:         store i64 %144, i64* %73, align 8, !tbaa !42 --->   %36 = load i8, i8* %35, align 1, !tbaa !40 via memory
DOALL:         store i64 %144, i64* %73, align 8, !tbaa !42 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         store i64 %144, i64* %73, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i64 %144, i64* %73, align 8, !tbaa !42 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         store i64 %144, i64* %73, align 8, !tbaa !42 --->   %32 = load i8, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i64 %144, i64* %73, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   %32 = load i8, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i, i64 64, i1 false) #7 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i64 %23, i64* %17, align 8, !tbaa !36 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   %74 = load i64, i64* %73, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i64 %20, i64* %17, align 8, !tbaa !36 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   %18 = load i64, i64* %17, align 8, !tbaa !36 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   %12 = load i64, i64* %11, align 8, !tbaa !31 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i64 %20, i64* %17, align 8, !tbaa !36 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   %70 = load i64, i64* %69, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   %45 = load i64, i64* %44, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i64 %15, i64* %11, align 8, !tbaa !31 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   %68 = load i64, i64* %67, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i8 %34, i8* %35, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   %72 = load i64, i64* %71, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i64 %15, i64* %11, align 8, !tbaa !31 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i64 %23, i64* %17, align 8, !tbaa !36 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i64 %142, i64* %69, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   %34 = load i8, i8* %33, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   %36 = load i8, i8* %35, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   %38 = load i8, i8* %37, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i8 %38, i8* %.0.i.i, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i8 %36, i8* %33, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i8 %36, i8* %33, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i8 %34, i8* %35, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i8 %32, i8* %37, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i8 %32, i8* %37, align 1, !tbaa !40 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i64 %140, i64* %65, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i64 %141, i64* %67, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i64 %141, i64* %67, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i64 %142, i64* %69, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i64 %143, i64* %71, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i64 %143, i64* %71, align 8, !tbaa !42 via memory
DOALL:         call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 1 %.01.i.lcssa, i64 %147, i1 false) #7, !prof !45 --->   store i64 %144, i64* %73, align 8, !tbaa !42 via memory
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: Checking if the loop is DOALL
DOALL:   The next live-out variables are not reducable
DOALL:     Live-out ID = 6
DOALL:     Live-out ID = 7
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.SHA_INFO, align 8
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
DOALL: WARNING: function NOELLE_DOALLDispatcher couldn't be found. DOALL is disabled
Inliner:   No remaining calls need to be inlined due to loop-carried data dependences
Inliner:   The code has not been modified
Inliner: Exit
Noelle:  Function "sha_update"
Noelle:     Loop "  %21 = icmp sgt i32 %.0, 63" (3.336099e+01%)
Noelle:     Loop "  %exitcond.i = icmp eq i32 %.01.i, 8" (1.300339e+00%)
Noelle:     Loop "  %exitcond38.i = icmp eq i64 %indvars.iv36.i, 16" (1.291552e+00%)
Noelle:     Loop "  %exitcond35.i = icmp eq i64 %indvars.iv33.i, 80" (1.239715e+01%)
Noelle:     Loop "  %exitcond32.i = icmp eq i64 %indvars.iv30.i, 20" (4.639046e+00%)
Noelle:     Loop "  %exitcond29.i = icmp eq i64 %indvars.iv27.i, 40" (4.287603e+00%)
Noelle:     Loop "  %exitcond26.i = icmp eq i64 %indvars.iv24.i, 60" (4.639046e+00%)
Noelle:     Loop "  %exitcond.i2 = icmp eq i64 %indvars.iv.i, 80" (4.287603e+00%)
Noelle:  Function "main"
Noelle:     Loop "  %8 = add nsw i32 %.0, -1" (3.334475e+01%)
Noelle:  Function "sha_stream"
Noelle:     Loop "  %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7" (3.334475e+01%)
Noelle:     Loop "  %27 = icmp sgt i32 %.0.i, 63" (3.334289e+01%)
Noelle:     Loop "  %exitcond.i.i = icmp eq i32 %.01.i.i, 8" (1.299633e+00%)
Noelle:     Loop "  %exitcond38.i.i = icmp eq i64 %indvars.iv36.i.i, 16" (1.290852e+00%)
Noelle:     Loop "  %exitcond35.i.i = icmp eq i64 %indvars.iv33.i.i, 80" (1.239042e+01%)
Noelle:     Loop "  %exitcond32.i.i = icmp eq i64 %indvars.iv30.i.i, 20" (4.636530e+00%)
Noelle:     Loop "  %exitcond29.i.i = icmp eq i64 %indvars.iv27.i.i, 40" (4.285277e+00%)
Noelle:     Loop "  %exitcond26.i.i = icmp eq i64 %indvars.iv24.i.i, 60" (4.636530e+00%)
Noelle:     Loop "  %exitcond.i2.i = icmp eq i64 %indvars.iv.i.i, 80" (4.285277e+00%)
Noelle:  Function "sha_transform"
Noelle:     Loop "  %exitcond38 = icmp eq i64 %indvars.iv36, 16" (1.291552e+00%)
Noelle:     Loop "  %exitcond35 = icmp eq i64 %indvars.iv33, 80" (1.237298e+01%)
Noelle:     Loop "  %exitcond32 = icmp eq i64 %indvars.iv30, 20" (4.639046e+00%)
Noelle:     Loop "  %exitcond29 = icmp eq i64 %indvars.iv27, 40" (4.287603e+00%)
Noelle:     Loop "  %exitcond26 = icmp eq i64 %indvars.iv24, 60" (4.639046e+00%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 80" (4.287603e+00%)
Noelle:  Function "byte_reverse"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 8" (1.300339e+00%)
Noelle:  Function "sha_final"
Noelle:  Function "sha_init"
Noelle:  Function "sha_print"
Noelle:  Function "sha_update"
Noelle:     Loop "  %21 = icmp sgt i32 %.0, 63" (3.336099e+01%)
Noelle:     Loop "  %exitcond.i = icmp eq i32 %.01.i, 8" (1.300339e+00%)
Noelle:     Loop "  %exitcond38.i = icmp eq i64 %indvars.iv36.i, 16" (1.291552e+00%)
Noelle:     Loop "  %exitcond35.i = icmp eq i64 %indvars.iv33.i, 80" (1.239715e+01%)
Noelle:     Loop "  %exitcond32.i = icmp eq i64 %indvars.iv30.i, 20" (4.639046e+00%)
Noelle:     Loop "  %exitcond29.i = icmp eq i64 %indvars.iv27.i, 40" (4.287603e+00%)
Noelle:     Loop "  %exitcond26.i = icmp eq i64 %indvars.iv24.i, 60" (4.639046e+00%)
Noelle:     Loop "  %exitcond.i2 = icmp eq i64 %indvars.iv.i, 80" (4.287603e+00%)
Noelle:  Function "main"
Noelle:     Loop "  %8 = add nsw i32 %.0, -1" (3.334475e+01%)
Noelle:  Function "sha_stream"
Noelle:     Loop "  %7 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7" (3.334475e+01%)
Noelle:     Loop "  %27 = icmp sgt i32 %.0.i, 63" (3.334289e+01%)
Noelle:     Loop "  %exitcond.i.i = icmp eq i32 %.01.i.i, 8" (1.299633e+00%)
Noelle:     Loop "  %exitcond38.i.i = icmp eq i64 %indvars.iv36.i.i, 16" (1.290852e+00%)
Noelle:     Loop "  %exitcond35.i.i = icmp eq i64 %indvars.iv33.i.i, 80" (1.239042e+01%)
Noelle:     Loop "  %exitcond32.i.i = icmp eq i64 %indvars.iv30.i.i, 20" (4.636530e+00%)
Noelle:     Loop "  %exitcond29.i.i = icmp eq i64 %indvars.iv27.i.i, 40" (4.285277e+00%)
Noelle:     Loop "  %exitcond26.i.i = icmp eq i64 %indvars.iv24.i.i, 60" (4.636530e+00%)
Noelle:     Loop "  %exitcond.i2.i = icmp eq i64 %indvars.iv.i.i, 80" (4.285277e+00%)
Noelle:  Function "sha_transform"
Noelle:     Loop "  %exitcond38 = icmp eq i64 %indvars.iv36, 16" (1.291552e+00%)
Noelle:     Loop "  %exitcond35 = icmp eq i64 %indvars.iv33, 80" (1.237298e+01%)
Noelle:     Loop "  %exitcond32 = icmp eq i64 %indvars.iv30, 20" (4.639046e+00%)
Noelle:     Loop "  %exitcond29 = icmp eq i64 %indvars.iv27, 40" (4.287603e+00%)
Noelle:     Loop "  %exitcond26 = icmp eq i64 %indvars.iv24, 60" (4.639046e+00%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 80" (4.287603e+00%)
Noelle:  Function "byte_reverse"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 8" (1.300339e+00%)
Noelle:  Function "sha_final"
Noelle:  Function "sha_init"
Noelle:  Function "sha_print"
NOELLE: FixedPoint: Exit
NOELLE: Inliner: Exit
noelle-simplification baseline_pre.bc -o baseline_pre.bc
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -tbaa -early-cse-memssa -licm -simplifycfg -simplifycfg-sink-common=false -instcombine -tailcallelim -loop-simplify -lcssa -licm -loop-unswitch -globalopt -instcombine -ipsccp -dce -gvn -dse -adce -loop-simplify -lcssa -indvars -loop-deletion -instcombine -indvars -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa --functionattrs --rpo-functionattrs baseline_pre.bc -o baseline_pre.bc
noelle-deadcode baseline_pre.bc baseline_pre.bc
NOELLE: DeadFunctions: Start
noelle-fixedpoint baseline_pre.bc baseline_pre.bc "noelle-load" -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DeadFunction.so -noelle-dfe
NOELLE: FixedPoint: Start
NOELLE: FixedPoint:   Loader: noelle-load
NOELLE: FixedPoint:   Options: -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DeadFunction.so -noelle-dfe
NOELLE: FixedPoint:   Input: baseline_pre.bc
NOELLE: FixedPoint:   Output: baseline_pre.bc
NOELLE: FixedPoint:   Temporary input: /tmp/tmp.YlDnh3SXsO (.ll version is /tmp/tmp.1B5uDxW8MZ)
NOELLE: FixedPoint:   Temporary output: /tmp/tmp.NQtlEuf4aJ (.ll version is /tmp/tmp.9cWTV8ftCo)
NOELLE: FixedPoint:   Normalize the code
noelle-norm /tmp/tmp.YlDnh3SXsO -o /tmp/tmp.NQtlEuf4aJ
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.YlDnh3SXsO -o /tmp/tmp.NQtlEuf4aJ
NOELLE: FixedPoint:   Run until a fixed point is reached
NOELLE: FixedPoint:     Invocation 0
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DeadFunction.so -noelle-dfe /tmp/tmp.YlDnh3SXsO -o /tmp/tmp.NQtlEuf4aJ
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DeadFunction.so -noelle-dfe /tmp/tmp.YlDnh3SXsO -o /tmp/tmp.NQtlEuf4aJ
DeadFunctionEliminator: Start
DeadFunctionEliminator:   Inline functions that are invoked only by one call instruction and that do not escape into memory
DeadFunctionEliminator:   Get the islands
DeadFunctionEliminator:   Identify the islands reachable from the entry points
DeadFunctionEliminator:     Island
DeadFunctionEliminator:       main
DeadFunctionEliminator:       llvm.lifetime.start.p0i8
DeadFunctionEliminator:       fopen
DeadFunctionEliminator:       printf
DeadFunctionEliminator:       fclose
DeadFunctionEliminator:       sha_stream
DeadFunctionEliminator:       llvm.lifetime.end.p0i8
DeadFunctionEliminator:       byte_reverse
DeadFunctionEliminator:       sha_init
DeadFunctionEliminator:       sha_update
DeadFunctionEliminator:       llvm.memcpy.p0i8.p0i8.i64
DeadFunctionEliminator:       sha_transform
DeadFunctionEliminator:       sha_final
DeadFunctionEliminator:       llvm.memset.p0i8.i64
DeadFunctionEliminator:       fread
DeadFunctionEliminator:       sha_print
DeadFunctionEliminator:   Identify the functions that can be deleted
DeadFunctionEliminator: Exit
Noelle:  Function "sha_update"
Noelle:     Loop "  %27 = icmp sgt i32 %.0, 63" (3.334041e+01%)
Noelle:     Loop "  %exitcond.i = icmp eq i32 %.01.i, 8" (1.301937e+00%)
Noelle:     Loop "  %exitcond38.i = icmp eq i64 %indvars.iv36.i, 16" (1.293140e+00%)
Noelle:     Loop "  %exitcond35.i = icmp eq i64 %indvars.iv33.i, 80" (1.241238e+01%)
Noelle:     Loop "  %exitcond32.i = icmp eq i64 %indvars.iv30.i, 20" (4.644748e+00%)
Noelle:     Loop "  %exitcond29.i = icmp eq i64 %indvars.iv27.i, 40" (4.292873e+00%)
Noelle:     Loop "  %exitcond26.i = icmp eq i64 %indvars.iv24.i, 60" (4.644748e+00%)
Noelle:     Loop "  %exitcond.i2 = icmp eq i64 %indvars.iv.i, 80" (4.292873e+00%)
Noelle:  Function "main"
Noelle:     Loop "  %13 = add nsw i32 %.0, -1" (3.332398e+01%)
Noelle:  Function "sha_stream"
Noelle:     Loop "  %17 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7" (3.332398e+01%)
Noelle:     Loop "  %33 = icmp sgt i32 %.0.i, 63" (3.332233e+01%)
Noelle:     Loop "  %exitcond.i.i = icmp eq i32 %.01.i.i, 8" (1.301231e+00%)
Noelle:     Loop "  %exitcond38.i.i = icmp eq i64 %indvars.iv36.i.i, 16" (1.292439e+00%)
Noelle:     Loop "  %exitcond35.i.i = icmp eq i64 %indvars.iv33.i.i, 80" (1.240565e+01%)
Noelle:     Loop "  %exitcond32.i.i = icmp eq i64 %indvars.iv30.i.i, 20" (4.642229e+00%)
Noelle:     Loop "  %exitcond29.i.i = icmp eq i64 %indvars.iv27.i.i, 40" (4.290545e+00%)
Noelle:     Loop "  %exitcond26.i.i = icmp eq i64 %indvars.iv24.i.i, 60" (4.642229e+00%)
Noelle:     Loop "  %exitcond.i2.i = icmp eq i64 %indvars.iv.i.i, 80" (4.290545e+00%)
Noelle:  Function "sha_transform"
Noelle:     Loop "  %exitcond38 = icmp eq i64 %indvars.iv36, 16" (1.293140e+00%)
Noelle:     Loop "  %exitcond35 = icmp eq i64 %indvars.iv33, 80" (1.238819e+01%)
Noelle:     Loop "  %exitcond32 = icmp eq i64 %indvars.iv30, 20" (4.644748e+00%)
Noelle:     Loop "  %exitcond29 = icmp eq i64 %indvars.iv27, 40" (4.292873e+00%)
Noelle:     Loop "  %exitcond26 = icmp eq i64 %indvars.iv24, 60" (4.644748e+00%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 80" (4.292873e+00%)
Noelle:  Function "byte_reverse"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 8" (1.301937e+00%)
Noelle:  Function "sha_final"
Noelle:  Function "sha_init"
Noelle:  Function "sha_print"
Noelle:  Function "sha_update"
Noelle:     Loop "  %27 = icmp sgt i32 %.0, 63" (3.334041e+01%)
Noelle:     Loop "  %exitcond.i = icmp eq i32 %.01.i, 8" (1.301937e+00%)
Noelle:     Loop "  %exitcond38.i = icmp eq i64 %indvars.iv36.i, 16" (1.293140e+00%)
Noelle:     Loop "  %exitcond35.i = icmp eq i64 %indvars.iv33.i, 80" (1.241238e+01%)
Noelle:     Loop "  %exitcond32.i = icmp eq i64 %indvars.iv30.i, 20" (4.644748e+00%)
Noelle:     Loop "  %exitcond29.i = icmp eq i64 %indvars.iv27.i, 40" (4.292873e+00%)
Noelle:     Loop "  %exitcond26.i = icmp eq i64 %indvars.iv24.i, 60" (4.644748e+00%)
Noelle:     Loop "  %exitcond.i2 = icmp eq i64 %indvars.iv.i, 80" (4.292873e+00%)
Noelle:  Function "main"
Noelle:     Loop "  %13 = add nsw i32 %.0, -1" (3.332398e+01%)
Noelle:  Function "sha_stream"
Noelle:     Loop "  %17 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7" (3.332398e+01%)
Noelle:     Loop "  %33 = icmp sgt i32 %.0.i, 63" (3.332233e+01%)
Noelle:     Loop "  %exitcond.i.i = icmp eq i32 %.01.i.i, 8" (1.301231e+00%)
Noelle:     Loop "  %exitcond38.i.i = icmp eq i64 %indvars.iv36.i.i, 16" (1.292439e+00%)
Noelle:     Loop "  %exitcond35.i.i = icmp eq i64 %indvars.iv33.i.i, 80" (1.240565e+01%)
Noelle:     Loop "  %exitcond32.i.i = icmp eq i64 %indvars.iv30.i.i, 20" (4.642229e+00%)
Noelle:     Loop "  %exitcond29.i.i = icmp eq i64 %indvars.iv27.i.i, 40" (4.290545e+00%)
Noelle:     Loop "  %exitcond26.i.i = icmp eq i64 %indvars.iv24.i.i, 60" (4.642229e+00%)
Noelle:     Loop "  %exitcond.i2.i = icmp eq i64 %indvars.iv.i.i, 80" (4.290545e+00%)
Noelle:  Function "sha_transform"
Noelle:     Loop "  %exitcond38 = icmp eq i64 %indvars.iv36, 16" (1.293140e+00%)
Noelle:     Loop "  %exitcond35 = icmp eq i64 %indvars.iv33, 80" (1.238819e+01%)
Noelle:     Loop "  %exitcond32 = icmp eq i64 %indvars.iv30, 20" (4.644748e+00%)
Noelle:     Loop "  %exitcond29 = icmp eq i64 %indvars.iv27, 40" (4.292873e+00%)
Noelle:     Loop "  %exitcond26 = icmp eq i64 %indvars.iv24, 60" (4.644748e+00%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 80" (4.292873e+00%)
Noelle:  Function "byte_reverse"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 8" (1.301937e+00%)
Noelle:  Function "sha_final"
Noelle:  Function "sha_init"
Noelle:  Function "sha_print"
NOELLE: FixedPoint: Exit
NOELLE: DeadFunctions: Exit
noelle-simplification baseline_pre.bc -o baseline_pre.bc
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -tbaa -early-cse-memssa -licm -simplifycfg -simplifycfg-sink-common=false -instcombine -tailcallelim -loop-simplify -lcssa -licm -loop-unswitch -globalopt -instcombine -ipsccp -dce -gvn -dse -adce -loop-simplify -lcssa -indvars -loop-deletion -instcombine -indvars -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa --functionattrs --rpo-functionattrs baseline_pre.bc -o baseline_pre.bc
noelle-enable baseline_pre.bc baseline_pre.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier
NOELLE: Enablers: Start
noelle-fixedpoint baseline_pre.bc baseline_pre.bc "noelle-parallel-load" -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier
NOELLE: FixedPoint: Start
NOELLE: FixedPoint:   Loader: noelle-parallel-load
NOELLE: FixedPoint:   Options: -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier
NOELLE: FixedPoint:   Input: baseline_pre.bc
NOELLE: FixedPoint:   Output: baseline_pre.bc
NOELLE: FixedPoint:   Temporary input: /tmp/tmp.Ltu39N8tqH (.ll version is /tmp/tmp.G45wFQ0tLv)
NOELLE: FixedPoint:   Temporary output: /tmp/tmp.yua8JnNRX4 (.ll version is /tmp/tmp.j54LieKTFV)
NOELLE: FixedPoint:   Normalize the code
noelle-norm /tmp/tmp.Ltu39N8tqH -o /tmp/tmp.yua8JnNRX4
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.Ltu39N8tqH -o /tmp/tmp.yua8JnNRX4
NOELLE: FixedPoint:   Run until a fixed point is reached
NOELLE: FixedPoint:     Invocation 0
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.Ltu39N8tqH -o /tmp/tmp.yua8JnNRX4
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.Ltu39N8tqH -o /tmp/tmp.yua8JnNRX4
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.Ltu39N8tqH -o /tmp/tmp.yua8JnNRX4
EnablersManager: Start
Noelle: Filter out cold code
Noelle:  Function "main"
Noelle:     Loop "  %13 = add nsw i32 %.0, -1" (3.332398e+01%)
Noelle:  Function "sha_stream"
Noelle:     Loop "  %17 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7" (3.332398e+01%)
Noelle:     Loop "  %33 = icmp sgt i32 %.0.i, 63" (3.332233e+01%)
Noelle:     Loop "  %exitcond.i.i = icmp eq i32 %.01.i.i, 8" (1.301231e+00%)
Noelle:     Loop "  %exitcond38.i.i = icmp eq i64 %indvars.iv36.i.i, 16" (1.292439e+00%)
Noelle:     Loop "  %exitcond35.i.i = icmp eq i64 %indvars.iv33.i.i, 80" (1.240565e+01%)
Noelle:     Loop "  %exitcond32.i.i = icmp eq i64 %indvars.iv30.i.i, 20" (4.642229e+00%)
Noelle:     Loop "  %exitcond29.i.i = icmp eq i64 %indvars.iv27.i.i, 40" (4.290545e+00%)
Noelle:     Loop "  %exitcond26.i.i = icmp eq i64 %indvars.iv24.i.i, 60" (4.642229e+00%)
Noelle:     Loop "  %exitcond.i2.i = icmp eq i64 %indvars.iv.i.i, 80" (4.290545e+00%)
Noelle:  Function "sha_transform"
Noelle:     Loop "  %exitcond38 = icmp eq i64 %indvars.iv36, 16" (1.293140e+00%)
Noelle:     Loop "  %exitcond35 = icmp eq i64 %indvars.iv33, 80" (1.238819e+01%)
Noelle:     Loop "  %exitcond32 = icmp eq i64 %indvars.iv30, 20" (4.644748e+00%)
Noelle:     Loop "  %exitcond29 = icmp eq i64 %indvars.iv27, 40" (4.292873e+00%)
Noelle:     Loop "  %exitcond26 = icmp eq i64 %indvars.iv24, 60" (4.644748e+00%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 80" (4.292873e+00%)
Noelle:  Function "byte_reverse"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 8" (1.301937e+00%)
Noelle:  Function "sha_final"
Noelle:  Disable "sha_final" as cold function
Noelle:  Function "sha_init"
Noelle:  Disable "sha_init" as cold function
Noelle:  Function "sha_print"
Noelle:  Disable "sha_print" as cold function
EnablersManager:   Try to improve all 17 loops, one at a time
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %13 = add nsw i32 %.0, -1
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.SHA_INFO, align 8
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %13 = add nsw i32 %.0, -1"
LICM:     Invariant = "  %23 = getelementptr [30 x i8], [30 x i8]* @.str.1, i64 0, i64 0
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %31 = getelementptr [31 x i8], [31 x i8]* @.str.5, i64 0, i64 0
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Invariant = "  %18 = getelementptr [3 x i8], [3 x i8]* @.str, i64 0, i64 0
LICM:       Checking dependences
LICM:       The instruction can be hoisted
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has been modified
LICM: Exit
EnablersManager:       Loop invariants have been extracted
EnablersManager:   Loop:
EnablersManager:     Function = "sha_stream"
EnablersManager:     Entry instruction =   %exitcond.i2.i = icmp eq i64 %indvars.iv.i.i, 80
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond.i2.i = icmp eq i64 %indvars.iv.i.i, 80"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond.i2.i, label %sha_transform.exit.i, label %124, !prof !44
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "sha_stream"
EnablersManager:     Entry instruction =   %exitcond26.i.i = icmp eq i64 %indvars.iv24.i.i, 60
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond26.i.i = icmp eq i64 %indvars.iv24.i.i, 60"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond26.i.i, label %.preheader.i.i.preheader, label %107, !prof !44
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "sha_stream"
EnablersManager:     Entry instruction =   %exitcond.i.i = icmp eq i32 %.01.i.i, 8
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond.i.i = icmp eq i32 %.01.i.i, 8"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond.i.i, label %byte_reverse.exit.i, label %36, !prof !39
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "sha_stream"
EnablersManager:     Entry instruction =   %exitcond29.i.i = icmp eq i64 %indvars.iv27.i.i, 40
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond29.i.i = icmp eq i64 %indvars.iv27.i.i, 40"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond29.i.i, label %.preheader21.i.i.preheader, label %92, !prof !44
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "sha_stream"
EnablersManager:     Entry instruction =   %exitcond32.i.i = icmp eq i64 %indvars.iv30.i.i, 20
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond32.i.i = icmp eq i64 %indvars.iv30.i.i, 20"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond32.i.i, label %.preheader22.i.i.preheader, label %75, !prof !44
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "sha_stream"
EnablersManager:     Entry instruction =   %exitcond38.i.i = icmp eq i64 %indvars.iv36.i.i, 16
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond38.i.i = icmp eq i64 %indvars.iv36.i.i, 16"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond38.i.i, label %.preheader23.i.i.preheader, label %47, !prof !41
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "sha_stream"
EnablersManager:     Entry instruction =   %exitcond35.i.i = icmp eq i64 %indvars.iv33.i.i, 80
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond35.i.i = icmp eq i64 %indvars.iv33.i.i, 80"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond35.i.i, label %68, label %51, !prof !43
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "sha_stream"
EnablersManager:     Entry instruction =   %33 = icmp sgt i32 %.0.i, 63
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca [80 x i64], align 16 can be cloned
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %33 = icmp sgt i32 %.0.i, 63"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %33, label %34, label %sha_update.exit, !prof !38
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "sha_stream"
EnablersManager:     Entry instruction =   %17 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca [8192 x i8], align 16 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca [80 x i64], align 16 can be cloned
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %17 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %19, label %20, label %147, !prof !30
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "sha_transform"
EnablersManager:     Entry instruction =   %exitcond35 = icmp eq i64 %indvars.iv33, 80
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond35 = icmp eq i64 %indvars.iv33, 80"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond35, label %26, label %9, !prof !36
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "sha_transform"
EnablersManager:     Entry instruction =   %exitcond26 = icmp eq i64 %indvars.iv24, 60
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond26 = icmp eq i64 %indvars.iv24, 60"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond26, label %.preheader.preheader, label %70, !prof !37
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "sha_transform"
EnablersManager:     Entry instruction =   %exitcond32 = icmp eq i64 %indvars.iv30, 20
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond32 = icmp eq i64 %indvars.iv30, 20"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond32, label %.preheader22.preheader, label %38, !prof !37
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "sha_transform"
EnablersManager:     Entry instruction =   %exitcond = icmp eq i64 %indvars.iv, 80
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond = icmp eq i64 %indvars.iv, 80"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond, label %102, label %87, !prof !37
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "sha_transform"
EnablersManager:     Entry instruction =   %exitcond29 = icmp eq i64 %indvars.iv27, 40
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond29 = icmp eq i64 %indvars.iv27, 40"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond29, label %.preheader21.preheader, label %55, !prof !37
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "byte_reverse"
EnablersManager:     Entry instruction =   %exitcond = icmp eq i32 %.01, 8
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond = icmp eq i32 %.01, 8"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond, label %15, label %5, !prof !31
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "sha_transform"
EnablersManager:     Entry instruction =   %exitcond38 = icmp eq i64 %indvars.iv36, 16
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond38 = icmp eq i64 %indvars.iv36, 16"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond38, label %.preheader23.preheader, label %5, !prof !31
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager: Exit
Noelle:  Function "sha_update"
Noelle:     Loop "  %27 = icmp sgt i32 %.0, 63" (3.334041e+01%)
Noelle:     Loop "  %exitcond.i = icmp eq i32 %.01.i, 8" (1.301937e+00%)
Noelle:     Loop "  %exitcond38.i = icmp eq i64 %indvars.iv36.i, 16" (1.293140e+00%)
Noelle:     Loop "  %exitcond35.i = icmp eq i64 %indvars.iv33.i, 80" (1.241238e+01%)
Noelle:     Loop "  %exitcond32.i = icmp eq i64 %indvars.iv30.i, 20" (4.644748e+00%)
Noelle:     Loop "  %exitcond29.i = icmp eq i64 %indvars.iv27.i, 40" (4.292873e+00%)
Noelle:     Loop "  %exitcond26.i = icmp eq i64 %indvars.iv24.i, 60" (4.644748e+00%)
Noelle:     Loop "  %exitcond.i2 = icmp eq i64 %indvars.iv.i, 80" (4.292873e+00%)
Noelle:  Function "main"
Noelle:     Loop "  %13 = add nsw i32 %.0, -1" (3.332398e+01%)
Noelle:  Function "sha_stream"
Noelle:     Loop "  %17 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7" (3.332398e+01%)
Noelle:     Loop "  %33 = icmp sgt i32 %.0.i, 63" (3.332233e+01%)
Noelle:     Loop "  %exitcond.i.i = icmp eq i32 %.01.i.i, 8" (1.301231e+00%)
Noelle:     Loop "  %exitcond38.i.i = icmp eq i64 %indvars.iv36.i.i, 16" (1.292439e+00%)
Noelle:     Loop "  %exitcond35.i.i = icmp eq i64 %indvars.iv33.i.i, 80" (1.240565e+01%)
Noelle:     Loop "  %exitcond32.i.i = icmp eq i64 %indvars.iv30.i.i, 20" (4.642229e+00%)
Noelle:     Loop "  %exitcond29.i.i = icmp eq i64 %indvars.iv27.i.i, 40" (4.290545e+00%)
Noelle:     Loop "  %exitcond26.i.i = icmp eq i64 %indvars.iv24.i.i, 60" (4.642229e+00%)
Noelle:     Loop "  %exitcond.i2.i = icmp eq i64 %indvars.iv.i.i, 80" (4.290545e+00%)
Noelle:  Function "sha_transform"
Noelle:     Loop "  %exitcond38 = icmp eq i64 %indvars.iv36, 16" (1.293140e+00%)
Noelle:     Loop "  %exitcond35 = icmp eq i64 %indvars.iv33, 80" (1.238819e+01%)
Noelle:     Loop "  %exitcond32 = icmp eq i64 %indvars.iv30, 20" (4.644748e+00%)
Noelle:     Loop "  %exitcond29 = icmp eq i64 %indvars.iv27, 40" (4.292873e+00%)
Noelle:     Loop "  %exitcond26 = icmp eq i64 %indvars.iv24, 60" (4.644748e+00%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 80" (4.292873e+00%)
Noelle:  Function "byte_reverse"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 8" (1.301937e+00%)
Noelle:  Function "sha_final"
Noelle:  Function "sha_init"
Noelle:  Function "sha_print"
Noelle:  Function "sha_update"
Noelle:     Loop "  %27 = icmp sgt i32 %.0, 63" (3.334041e+01%)
Noelle:     Loop "  %exitcond.i = icmp eq i32 %.01.i, 8" (1.301937e+00%)
Noelle:     Loop "  %exitcond38.i = icmp eq i64 %indvars.iv36.i, 16" (1.293140e+00%)
Noelle:     Loop "  %exitcond35.i = icmp eq i64 %indvars.iv33.i, 80" (1.241238e+01%)
Noelle:     Loop "  %exitcond32.i = icmp eq i64 %indvars.iv30.i, 20" (4.644748e+00%)
Noelle:     Loop "  %exitcond29.i = icmp eq i64 %indvars.iv27.i, 40" (4.292873e+00%)
Noelle:     Loop "  %exitcond26.i = icmp eq i64 %indvars.iv24.i, 60" (4.644748e+00%)
Noelle:     Loop "  %exitcond.i2 = icmp eq i64 %indvars.iv.i, 80" (4.292873e+00%)
Noelle:  Function "main"
Noelle:     Loop "  %16 = add nsw i32 %.0, -1" (3.332398e+01%)
Noelle:  Function "sha_stream"
Noelle:     Loop "  %17 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7" (3.332398e+01%)
Noelle:     Loop "  %33 = icmp sgt i32 %.0.i, 63" (3.332233e+01%)
Noelle:     Loop "  %exitcond.i.i = icmp eq i32 %.01.i.i, 8" (1.301231e+00%)
Noelle:     Loop "  %exitcond38.i.i = icmp eq i64 %indvars.iv36.i.i, 16" (1.292439e+00%)
Noelle:     Loop "  %exitcond35.i.i = icmp eq i64 %indvars.iv33.i.i, 80" (1.240565e+01%)
Noelle:     Loop "  %exitcond32.i.i = icmp eq i64 %indvars.iv30.i.i, 20" (4.642229e+00%)
Noelle:     Loop "  %exitcond29.i.i = icmp eq i64 %indvars.iv27.i.i, 40" (4.290545e+00%)
Noelle:     Loop "  %exitcond26.i.i = icmp eq i64 %indvars.iv24.i.i, 60" (4.642229e+00%)
Noelle:     Loop "  %exitcond.i2.i = icmp eq i64 %indvars.iv.i.i, 80" (4.290545e+00%)
Noelle:  Function "sha_transform"
Noelle:     Loop "  %exitcond38 = icmp eq i64 %indvars.iv36, 16" (1.293140e+00%)
Noelle:     Loop "  %exitcond35 = icmp eq i64 %indvars.iv33, 80" (1.238819e+01%)
Noelle:     Loop "  %exitcond32 = icmp eq i64 %indvars.iv30, 20" (4.644748e+00%)
Noelle:     Loop "  %exitcond29 = icmp eq i64 %indvars.iv27, 40" (4.292873e+00%)
Noelle:     Loop "  %exitcond26 = icmp eq i64 %indvars.iv24, 60" (4.644748e+00%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 80" (4.292873e+00%)
Noelle:  Function "byte_reverse"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 8" (1.301937e+00%)
Noelle:  Function "sha_final"
Noelle:  Function "sha_init"
Noelle:  Function "sha_print"
NOELLE: FixedPoint:       There are 0 different instructions and -3 different loop instructions
NOELLE: FixedPoint:       Normalize the code
noelle-norm /tmp/tmp.yua8JnNRX4 -o /tmp/tmp.yua8JnNRX4
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars --functionattrs --rpo-functionattrs /tmp/tmp.yua8JnNRX4 -o /tmp/tmp.yua8JnNRX4
NOELLE: FixedPoint:     Invocation 1
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.Ltu39N8tqH -o /tmp/tmp.yua8JnNRX4
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.Ltu39N8tqH -o /tmp/tmp.yua8JnNRX4
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Enablers.so -enablers -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier /tmp/tmp.Ltu39N8tqH -o /tmp/tmp.yua8JnNRX4
EnablersManager: Start
Noelle: Filter out cold code
Noelle:  Function "main"
Noelle:     Loop "  %16 = add nsw i32 %.0, -1" (3.332398e+01%)
Noelle:  Function "sha_stream"
Noelle:     Loop "  %17 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7" (3.332398e+01%)
Noelle:     Loop "  %33 = icmp sgt i32 %.0.i, 63" (3.332233e+01%)
Noelle:     Loop "  %exitcond.i.i = icmp eq i32 %.01.i.i, 8" (1.301231e+00%)
Noelle:     Loop "  %exitcond38.i.i = icmp eq i64 %indvars.iv36.i.i, 16" (1.292439e+00%)
Noelle:     Loop "  %exitcond35.i.i = icmp eq i64 %indvars.iv33.i.i, 80" (1.240565e+01%)
Noelle:     Loop "  %exitcond32.i.i = icmp eq i64 %indvars.iv30.i.i, 20" (4.642229e+00%)
Noelle:     Loop "  %exitcond29.i.i = icmp eq i64 %indvars.iv27.i.i, 40" (4.290545e+00%)
Noelle:     Loop "  %exitcond26.i.i = icmp eq i64 %indvars.iv24.i.i, 60" (4.642229e+00%)
Noelle:     Loop "  %exitcond.i2.i = icmp eq i64 %indvars.iv.i.i, 80" (4.290545e+00%)
Noelle:  Function "sha_transform"
Noelle:     Loop "  %exitcond38 = icmp eq i64 %indvars.iv36, 16" (1.293140e+00%)
Noelle:     Loop "  %exitcond35 = icmp eq i64 %indvars.iv33, 80" (1.238819e+01%)
Noelle:     Loop "  %exitcond32 = icmp eq i64 %indvars.iv30, 20" (4.644748e+00%)
Noelle:     Loop "  %exitcond29 = icmp eq i64 %indvars.iv27, 40" (4.292873e+00%)
Noelle:     Loop "  %exitcond26 = icmp eq i64 %indvars.iv24, 60" (4.644748e+00%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 80" (4.292873e+00%)
Noelle:  Function "byte_reverse"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 8" (1.301937e+00%)
Noelle:  Function "sha_final"
Noelle:  Disable "sha_final" as cold function
Noelle:  Function "sha_init"
Noelle:  Disable "sha_init" as cold function
Noelle:  Function "sha_print"
Noelle:  Disable "sha_print" as cold function
EnablersManager:   Try to improve all 17 loops, one at a time
EnablersManager:   Loop:
EnablersManager:     Function = "main"
EnablersManager:     Entry instruction =   %16 = add nsw i32 %.0, -1
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca %struct.SHA_INFO, align 8
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %16 = add nsw i32 %.0, -1"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %17, label %.loopexit.loopexit, label %18, !prof !35
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "sha_stream"
EnablersManager:     Entry instruction =   %exitcond32.i.i = icmp eq i64 %indvars.iv30.i.i, 20
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond32.i.i = icmp eq i64 %indvars.iv30.i.i, 20"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond32.i.i, label %.preheader22.i.i.preheader, label %75, !prof !44
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "sha_stream"
EnablersManager:     Entry instruction =   %exitcond26.i.i = icmp eq i64 %indvars.iv24.i.i, 60
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond26.i.i = icmp eq i64 %indvars.iv24.i.i, 60"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond26.i.i, label %.preheader.i.i.preheader, label %107, !prof !44
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "sha_stream"
EnablersManager:     Entry instruction =   %exitcond.i2.i = icmp eq i64 %indvars.iv.i.i, 80
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond.i2.i = icmp eq i64 %indvars.iv.i.i, 80"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond.i2.i, label %sha_transform.exit.i, label %124, !prof !44
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "sha_stream"
EnablersManager:     Entry instruction =   %exitcond38.i.i = icmp eq i64 %indvars.iv36.i.i, 16
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond38.i.i = icmp eq i64 %indvars.iv36.i.i, 16"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond38.i.i, label %.preheader23.i.i.preheader, label %47, !prof !41
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "sha_stream"
EnablersManager:     Entry instruction =   %exitcond.i.i = icmp eq i32 %.01.i.i, 8
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond.i.i = icmp eq i32 %.01.i.i, 8"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond.i.i, label %byte_reverse.exit.i, label %36, !prof !39
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "sha_stream"
EnablersManager:     Entry instruction =   %exitcond29.i.i = icmp eq i64 %indvars.iv27.i.i, 40
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond29.i.i = icmp eq i64 %indvars.iv27.i.i, 40"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond29.i.i, label %.preheader21.i.i.preheader, label %92, !prof !44
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "sha_stream"
EnablersManager:     Entry instruction =   %exitcond35.i.i = icmp eq i64 %indvars.iv33.i.i, 80
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond35.i.i = icmp eq i64 %indvars.iv33.i.i, 80"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond35.i.i, label %68, label %51, !prof !43
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "sha_stream"
EnablersManager:     Entry instruction =   %33 = icmp sgt i32 %.0.i, 63
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca [80 x i64], align 16 can be cloned
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %33 = icmp sgt i32 %.0.i, 63"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %33, label %34, label %sha_update.exit, !prof !38
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "sha_stream"
EnablersManager:     Entry instruction =   %17 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca [8192 x i8], align 16 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca [80 x i64], align 16 can be cloned
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %17 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %19, label %20, label %147, !prof !30
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "sha_transform"
EnablersManager:     Entry instruction =   %exitcond35 = icmp eq i64 %indvars.iv33, 80
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond35 = icmp eq i64 %indvars.iv33, 80"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond35, label %26, label %9, !prof !36
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "sha_transform"
EnablersManager:     Entry instruction =   %exitcond26 = icmp eq i64 %indvars.iv24, 60
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond26 = icmp eq i64 %indvars.iv24, 60"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond26, label %.preheader.preheader, label %70, !prof !37
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "sha_transform"
EnablersManager:     Entry instruction =   %exitcond32 = icmp eq i64 %indvars.iv30, 20
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond32 = icmp eq i64 %indvars.iv30, 20"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond32, label %.preheader22.preheader, label %38, !prof !37
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "sha_transform"
EnablersManager:     Entry instruction =   %exitcond = icmp eq i64 %indvars.iv, 80
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond = icmp eq i64 %indvars.iv, 80"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond, label %102, label %87, !prof !37
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "sha_transform"
EnablersManager:     Entry instruction =   %exitcond29 = icmp eq i64 %indvars.iv27, 40
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond29 = icmp eq i64 %indvars.iv27, 40"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond29, label %.preheader21.preheader, label %55, !prof !37
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "byte_reverse"
EnablersManager:     Entry instruction =   %exitcond = icmp eq i32 %.01, 8
MemoryCloningAnalysis: Start
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond = icmp eq i32 %.01, 8"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond, label %15, label %5, !prof !31
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager:   Loop:
EnablersManager:     Function = "sha_transform"
EnablersManager:     Entry instruction =   %exitcond38 = icmp eq i64 %indvars.iv36, 16
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %2 = alloca [80 x i64], align 16
ClonableMemoryObject:   We cannot identify memory accesses to it
ClonableMemoryObject: Exit
MemoryCloningAnalysis: Exit
EnablersManager:     Try to apply loop distribution
EnablersManager:     Try to devirtualize indirect calls
EnablersManager:     Try to extract invariants out of loops
LICM: Start
LICM:   Loop "  %exitcond38 = icmp eq i64 %indvars.iv36, 16"
LICM:     Check invariants that can be hoisted conditionally
LICM:       Check the invariants
LICM:   The loop has not been modified
LICM: Exit
Mem2Reg: Start
Mem2Reg:   Checking loop:   br i1 %exitcond38, label %.preheader23.preheader, label %5, !prof !31
Mem2Reg:   The loop has 0SCCs that each one access the same memory location
Mem2Reg:   No changes have been made
Mem2Reg: Exit
EnablersManager:     Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:     Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager: Exit
Noelle:  Function "sha_update"
Noelle:     Loop "  %27 = icmp sgt i32 %.0, 63" (3.334041e+01%)
Noelle:     Loop "  %exitcond.i = icmp eq i32 %.01.i, 8" (1.301937e+00%)
Noelle:     Loop "  %exitcond38.i = icmp eq i64 %indvars.iv36.i, 16" (1.293140e+00%)
Noelle:     Loop "  %exitcond35.i = icmp eq i64 %indvars.iv33.i, 80" (1.241238e+01%)
Noelle:     Loop "  %exitcond32.i = icmp eq i64 %indvars.iv30.i, 20" (4.644748e+00%)
Noelle:     Loop "  %exitcond29.i = icmp eq i64 %indvars.iv27.i, 40" (4.292873e+00%)
Noelle:     Loop "  %exitcond26.i = icmp eq i64 %indvars.iv24.i, 60" (4.644748e+00%)
Noelle:     Loop "  %exitcond.i2 = icmp eq i64 %indvars.iv.i, 80" (4.292873e+00%)
Noelle:  Function "main"
Noelle:     Loop "  %16 = add nsw i32 %.0, -1" (3.332398e+01%)
Noelle:  Function "sha_stream"
Noelle:     Loop "  %17 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7" (3.332398e+01%)
Noelle:     Loop "  %33 = icmp sgt i32 %.0.i, 63" (3.332233e+01%)
Noelle:     Loop "  %exitcond.i.i = icmp eq i32 %.01.i.i, 8" (1.301231e+00%)
Noelle:     Loop "  %exitcond38.i.i = icmp eq i64 %indvars.iv36.i.i, 16" (1.292439e+00%)
Noelle:     Loop "  %exitcond35.i.i = icmp eq i64 %indvars.iv33.i.i, 80" (1.240565e+01%)
Noelle:     Loop "  %exitcond32.i.i = icmp eq i64 %indvars.iv30.i.i, 20" (4.642229e+00%)
Noelle:     Loop "  %exitcond29.i.i = icmp eq i64 %indvars.iv27.i.i, 40" (4.290545e+00%)
Noelle:     Loop "  %exitcond26.i.i = icmp eq i64 %indvars.iv24.i.i, 60" (4.642229e+00%)
Noelle:     Loop "  %exitcond.i2.i = icmp eq i64 %indvars.iv.i.i, 80" (4.290545e+00%)
Noelle:  Function "sha_transform"
Noelle:     Loop "  %exitcond38 = icmp eq i64 %indvars.iv36, 16" (1.293140e+00%)
Noelle:     Loop "  %exitcond35 = icmp eq i64 %indvars.iv33, 80" (1.238819e+01%)
Noelle:     Loop "  %exitcond32 = icmp eq i64 %indvars.iv30, 20" (4.644748e+00%)
Noelle:     Loop "  %exitcond29 = icmp eq i64 %indvars.iv27, 40" (4.292873e+00%)
Noelle:     Loop "  %exitcond26 = icmp eq i64 %indvars.iv24, 60" (4.644748e+00%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 80" (4.292873e+00%)
Noelle:  Function "byte_reverse"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 8" (1.301937e+00%)
Noelle:  Function "sha_final"
Noelle:  Function "sha_init"
Noelle:  Function "sha_print"
Noelle:  Function "sha_update"
Noelle:     Loop "  %27 = icmp sgt i32 %.0, 63" (3.334041e+01%)
Noelle:     Loop "  %exitcond.i = icmp eq i32 %.01.i, 8" (1.301937e+00%)
Noelle:     Loop "  %exitcond38.i = icmp eq i64 %indvars.iv36.i, 16" (1.293140e+00%)
Noelle:     Loop "  %exitcond35.i = icmp eq i64 %indvars.iv33.i, 80" (1.241238e+01%)
Noelle:     Loop "  %exitcond32.i = icmp eq i64 %indvars.iv30.i, 20" (4.644748e+00%)
Noelle:     Loop "  %exitcond29.i = icmp eq i64 %indvars.iv27.i, 40" (4.292873e+00%)
Noelle:     Loop "  %exitcond26.i = icmp eq i64 %indvars.iv24.i, 60" (4.644748e+00%)
Noelle:     Loop "  %exitcond.i2 = icmp eq i64 %indvars.iv.i, 80" (4.292873e+00%)
Noelle:  Function "main"
Noelle:     Loop "  %16 = add nsw i32 %.0, -1" (3.332398e+01%)
Noelle:  Function "sha_stream"
Noelle:     Loop "  %17 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7" (3.332398e+01%)
Noelle:     Loop "  %33 = icmp sgt i32 %.0.i, 63" (3.332233e+01%)
Noelle:     Loop "  %exitcond.i.i = icmp eq i32 %.01.i.i, 8" (1.301231e+00%)
Noelle:     Loop "  %exitcond38.i.i = icmp eq i64 %indvars.iv36.i.i, 16" (1.292439e+00%)
Noelle:     Loop "  %exitcond35.i.i = icmp eq i64 %indvars.iv33.i.i, 80" (1.240565e+01%)
Noelle:     Loop "  %exitcond32.i.i = icmp eq i64 %indvars.iv30.i.i, 20" (4.642229e+00%)
Noelle:     Loop "  %exitcond29.i.i = icmp eq i64 %indvars.iv27.i.i, 40" (4.290545e+00%)
Noelle:     Loop "  %exitcond26.i.i = icmp eq i64 %indvars.iv24.i.i, 60" (4.642229e+00%)
Noelle:     Loop "  %exitcond.i2.i = icmp eq i64 %indvars.iv.i.i, 80" (4.290545e+00%)
Noelle:  Function "sha_transform"
Noelle:     Loop "  %exitcond38 = icmp eq i64 %indvars.iv36, 16" (1.293140e+00%)
Noelle:     Loop "  %exitcond35 = icmp eq i64 %indvars.iv33, 80" (1.238819e+01%)
Noelle:     Loop "  %exitcond32 = icmp eq i64 %indvars.iv30, 20" (4.644748e+00%)
Noelle:     Loop "  %exitcond29 = icmp eq i64 %indvars.iv27, 40" (4.292873e+00%)
Noelle:     Loop "  %exitcond26 = icmp eq i64 %indvars.iv24, 60" (4.644748e+00%)
Noelle:     Loop "  %exitcond = icmp eq i64 %indvars.iv, 80" (4.292873e+00%)
Noelle:  Function "byte_reverse"
Noelle:     Loop "  %exitcond = icmp eq i32 %.01, 8" (1.301937e+00%)
Noelle:  Function "sha_final"
Noelle:  Function "sha_init"
Noelle:  Function "sha_print"
NOELLE: FixedPoint: Exit
NOELLE: Enablers: Exit
noelle-simplification baseline_pre.bc -o baseline_pre.bc
opt -basicaa -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -mem2reg -tbaa -early-cse-memssa -licm -simplifycfg -simplifycfg-sink-common=false -instcombine -tailcallelim -loop-simplify -lcssa -licm -loop-unswitch -globalopt -instcombine -ipsccp -dce -gvn -dse -adce -loop-simplify -lcssa -indvars -loop-deletion -instcombine -indvars -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa --functionattrs --rpo-functionattrs baseline_pre.bc -o baseline_pre.bc
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CleanMetadata.so -CleanMetadata -clean-loop-metadata=true -clean-prof-metadata=true -clean-pdg-metadata=true baseline_pre.bc -o baseline_pre.bc
noelle/core/Clean Loop Metadata
noelle/core/Clean PDG Metadata
noelle/core/Clean profiler metadata
opt --strip-named-metadata baseline_pre.bc -o baseline_pre.bc
/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/sha /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/sha
Running: ./baseline_pre_prof input_verylarge.asc > output_large.txt in /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/MiBench/security/sha
--------------------------------------------------------------------------------------
/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/sha
DONE
opt -pgo-test-profile-file=/tmp/tmp.4Zok1x4vU1 -block-freq -pgo-instr-use baseline_pre.bc -o baseline_with_metadata.bc
noelle-load -PDGAnalysis -noelle-pdg-verbose=3 -noelle-pdg-embed baseline_with_metadata.bc -o baseline_with_metadata.bc
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -PDGAnalysis -noelle-pdg-verbose=3 -noelle-pdg-embed baseline_with_metadata.bc -o baseline_with_metadata.bc
PDGAnalysis: Construct PDG from Analysis
Embed PDG as metadata
noelle-parallelizer baseline_with_metadata.bc -o baseline_parallelized.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
noelle-meta-loop-embed baseline_with_metadata.bc -o afterLoopMetadata.bc
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopMetadata.so -LoopMetadata baseline_with_metadata.bc -o afterLoopMetadata.bc
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopMetadata.so -LoopMetadata baseline_with_metadata.bc -o afterLoopMetadata.bc
noelle-parallelization-planner afterLoopMetadata.bc -o baseline_with_parallel_plan.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Planner.so -planner afterLoopMetadata.bc -o baseline_with_parallel_plan.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Planner.so -planner afterLoopMetadata.bc -o baseline_with_parallel_plan.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Planner.so -planner afterLoopMetadata.bc -o baseline_with_parallel_plan.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
Planner: Start
Planner:  Fetching the program loops
Noelle: Filter out cold code
Noelle:  Function "main"
Noelle:     Loop "  %13 = add nsw i32 %.0, -1, !noelle.pdg.inst.id !201" (1.000000e+02%)
Noelle:  Function "sha_stream"
Noelle:     Loop "  %17 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7, !noelle.pdg.inst.id !42" (1.000000e+02%)
Noelle:     Loop "  %33 = icmp sgt i32 %.0.i, 63, !noelle.pdg.inst.id !982" (9.999505e+01%)
Noelle:     Loop "  %exitcond.i.i = icmp eq i32 %.01.i.i, 8, !noelle.pdg.inst.id !989" (3.904788e+00%)
Noelle:     Loop "  %exitcond38.i.i = icmp eq i64 %indvars.iv36.i.i, 16, !noelle.pdg.inst.id !1003" (3.878404e+00%)
Noelle:     Loop "  %exitcond35.i.i = icmp eq i64 %indvars.iv33.i.i, 80, !noelle.pdg.inst.id !1014" (3.722740e+01%)
Noelle:     Loop "  %exitcond32.i.i = icmp eq i64 %indvars.iv30.i.i, 20, !noelle.pdg.inst.id !1039" (1.393059e+01%)
Noelle:     Loop "  %exitcond29.i.i = icmp eq i64 %indvars.iv27.i.i, 40, !noelle.pdg.inst.id !1072" (1.287525e+01%)
Noelle:     Loop "  %exitcond26.i.i = icmp eq i64 %indvars.iv24.i.i, 60, !noelle.pdg.inst.id !1102" (1.393059e+01%)
Noelle:     Loop "  %exitcond.i2.i = icmp eq i64 %indvars.iv.i.i, 80, !noelle.pdg.inst.id !1134" (1.287525e+01%)
Noelle:  Function "sha_final"
Noelle:  Disable "sha_final" as cold function
Noelle:  Function "sha_transform"
Noelle:  Disable "sha_transform" as cold function
Noelle:  Function "byte_reverse"
Noelle:  Disable "byte_reverse" as cold function
Noelle:  Function "sha_init"
Noelle:  Disable "sha_init" as cold function
Noelle:  Function "sha_update"
Noelle:  Disable "sha_update" as cold function
Noelle:  Function "sha_print"
Noelle:  Disable "sha_print" as cold function
Planner:    There are 10 loops in the program we are going to consider
Planner:  Filter out loops not worth considering
Planner:    Loop 21 has 5.280000e+02 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 23 has 5.280000e+02 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 22 has 4.880000e+02 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 24 has 4.880000e+02 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 18 has 1.480000e+02 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 20 has 1.411000e+03 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 19 has 1.470000e+02 number of instructions per loop invocation
Planner:      It is too low. The threshold is 2000
Planner:    Loop 0 has 1.000000e+00 number of iterations on average per loop invocation
Planner:      It is too low. The threshold is 12
Planner:  There are 1 loop nesting trees in the program
Planner:    ID: 16 (1)
Planner:      Function: "sha_stream"
Planner:      Loop: "  %17 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7, !noelle.pdg.inst.id !42"
Planner:      Loop nesting level: 1
Planner:      Hotness = 1.000000e+02 %
Planner:      Average instructions per invocation = 1.922228e+12 %
Planner:      Average iterations per invocation = 3.962147e+06 %
Planner:    
Planner:      ID: 17 (2)
Planner:        Function: "sha_stream"
Planner:        Loop: "  %33 = icmp sgt i32 %.0.i, 63, !noelle.pdg.inst.id !982"
Planner:        Loop nesting level: 2
Planner:        Hotness = 9.999505e+01 %
Planner:        Average instructions per invocation = 4.851240e+05 %
Planner:        Average iterations per invocation = 1.290000e+02 %
Planner:      
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16, !noelle.pdg.inst.id !941
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca [8192 x i8], align 16, !noelle.pdg.inst.id !941 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16, !noelle.pdg.inst.id !940
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca [80 x i64], align 16, !noelle.pdg.inst.id !940 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16, !noelle.pdg.inst.id !941
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca [8192 x i8], align 16, !noelle.pdg.inst.id !941 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16, !noelle.pdg.inst.id !940
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca [80 x i64], align 16, !noelle.pdg.inst.id !940 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16, !noelle.pdg.inst.id !941
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16, !noelle.pdg.inst.id !940
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca [80 x i64], align 16, !noelle.pdg.inst.id !940 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16, !noelle.pdg.inst.id !941
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16, !noelle.pdg.inst.id !940
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca [80 x i64], align 16, !noelle.pdg.inst.id !940 can be cloned
MemoryCloningAnalysis: Exit
Planner: LoopSelector: Start
Planner: LoopSelector:   Order of loops and their maximum savings
Planner: LoopSelector:    Loop 17
Planner: LoopSelector:      Function: "sha_stream"
Planner: LoopSelector:      Loop nesting level: 2
Planner: LoopSelector:      "  %33 = icmp sgt i32 %.0.i, 63, !noelle.pdg.inst.id !982"
Planner: LoopSelector:      Coverage: 9.999505e+01%
Planner: LoopSelector:      Whole-program savings = 5.841434e+01%
Planner: LoopSelector:      Loop savings = 5.841723e+01%
Planner: LoopSelector:    Loop 16
Planner: LoopSelector:      Function: "sha_stream"
Planner: LoopSelector:      Loop nesting level: 1
Planner: LoopSelector:      "  %17 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #7, !noelle.pdg.inst.id !42"
Planner: LoopSelector:      Coverage: 1.000000e+02%
Planner: LoopSelector:      Whole-program savings = 5.541196e+00%
Planner: LoopSelector:      Loop savings = 5.541196e+00%
Planner: LoopSelector: End
Planner:   Maximum time saved = 5.841434e+01% (1122856533104)
Planner:   Maximum time saved with DOALL only = 0.000000e+00% (0)
Planner: Exit
noelle-rm-function -function-name=SIMONE_CAMPANONI_IS_GOING_TO_REMOVE_THIS_FUNCTION code_with_prototypes.bc -o code_to_parallelize.bc
NOELLE: DeadFunctions: Start
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/RemoveFunction.so -noelle-rm-function -function-name=SIMONE_CAMPANONI_IS_GOING_TO_REMOVE_THIS_FUNCTION code_with_prototypes.bc -o code_to_parallelize.bc
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/RemoveFunction.so -noelle-rm-function -function-name=SIMONE_CAMPANONI_IS_GOING_TO_REMOVE_THIS_FUNCTION code_with_prototypes.bc -o code_to_parallelize.bc
RemoveFunction: Start
RemoveFunction:   Check if function "SIMONE_CAMPANONI_IS_GOING_TO_REMOVE_THIS_FUNCTION" exists
RemoveFunction:     The function exists
RemoveFunction:   Remove the function
RemoveFunction: Exit
NOELLE: DeadFunctions: Exit
noelle-parallelizer-loop code_to_parallelize.bc -o parallelized_unoptimized.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Parallelizer.so -parallelizer code_to_parallelize.bc -o parallelized_unoptimized.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Parallelizer.so -parallelizer code_to_parallelize.bc -o parallelized_unoptimized.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDG.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MemoryCloningAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/TypesManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ConstantsManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Dominators.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopEnvironment.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Forest.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Invariants.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/InductionVariables.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopCarriedDependencies.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopSCCDAGAttributes.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopContent.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopNestingGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/MetadataManager.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/LoopTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CFGTransformer.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Noelle.so -disable-basicaa -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa --objc-arc-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -noellescaf -noellesvf -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/Parallelizer.so -parallelizer code_to_parallelize.bc -o parallelized_unoptimized.bc -noelle-verbose=3 -noelle-pdg-verbose=1 -noelle-min-hot=1 -noelle-max-cores=8 -noelle-inliner-avoid-hoist-to-main -noelle-disable-whilifier -noelle-disable-helix -noelle-disable-dswp -noelle-disable-doall
Parallelizer: Start
Parallelizer:  Analyzing the module code_to_parallelize.bc
Parallelizer:  Fetching the program loops
Noelle: Filter out cold code
Noelle:  Function "main"
Noelle:     Loop "  %13 = add nsw i32 %.0, -1, !noelle.pdg.inst.id !203" (1.000000e+02%)
Noelle:  Function "sha_stream"
Noelle:     Loop "  %17 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #8, !noelle.pdg.inst.id !44" (1.000000e+02%)
Noelle:     Loop "  %33 = icmp sgt i32 %.0.i, 63, !noelle.pdg.inst.id !985" (9.999505e+01%)
Noelle:     Loop "  %exitcond.i.i = icmp eq i32 %.01.i.i, 8, !noelle.pdg.inst.id !993" (3.904788e+00%)
Noelle:     Loop "  %exitcond38.i.i = icmp eq i64 %indvars.iv36.i.i, 16, !noelle.pdg.inst.id !1007" (3.878404e+00%)
Noelle:     Loop "  %exitcond35.i.i = icmp eq i64 %indvars.iv33.i.i, 80, !noelle.pdg.inst.id !1018" (3.722740e+01%)
Noelle:     Loop "  %exitcond32.i.i = icmp eq i64 %indvars.iv30.i.i, 20, !noelle.pdg.inst.id !1043" (1.393059e+01%)
Noelle:     Loop "  %exitcond29.i.i = icmp eq i64 %indvars.iv27.i.i, 40, !noelle.pdg.inst.id !1076" (1.287525e+01%)
Noelle:     Loop "  %exitcond26.i.i = icmp eq i64 %indvars.iv24.i.i, 60, !noelle.pdg.inst.id !1106" (1.393059e+01%)
Noelle:     Loop "  %exitcond.i2.i = icmp eq i64 %indvars.iv.i.i, 80, !noelle.pdg.inst.id !1138" (1.287525e+01%)
Noelle:  Function "sha_final"
Noelle:  Disable "sha_final" as cold function
Noelle:  Function "sha_transform"
Noelle:  Disable "sha_transform" as cold function
Noelle:  Function "byte_reverse"
Noelle:  Disable "byte_reverse" as cold function
Noelle:  Function "sha_init"
Noelle:  Disable "sha_init" as cold function
Noelle:  Function "sha_update"
Noelle:  Disable "sha_update" as cold function
Noelle:  Function "sha_print"
Noelle:  Disable "sha_print" as cold function
Parallelizer:    There are 10 loops in the program we are going to consider
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16, !noelle.pdg.inst.id !943
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca [8192 x i8], align 16, !noelle.pdg.inst.id !943 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16, !noelle.pdg.inst.id !942
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca [80 x i64], align 16, !noelle.pdg.inst.id !942 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16, !noelle.pdg.inst.id !943
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %4 = alloca [8192 x i8], align 16, !noelle.pdg.inst.id !943 can be cloned
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16, !noelle.pdg.inst.id !942
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca [80 x i64], align 16, !noelle.pdg.inst.id !942 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16, !noelle.pdg.inst.id !943
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16, !noelle.pdg.inst.id !942
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca [80 x i64], align 16, !noelle.pdg.inst.id !942 can be cloned
MemoryCloningAnalysis: Exit
MemoryCloningAnalysis: Start
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %4 = alloca [8192 x i8], align 16, !noelle.pdg.inst.id !943
ClonableMemoryObject:   There is no need to clone it
ClonableMemoryObject: Exit
ClonableMemoryObject: Start
ClonableMemoryObject:   Object =   %3 = alloca [80 x i64], align 16, !noelle.pdg.inst.id !942
ClonableMemoryObject:   It is clonable
ClonableMemoryObject: Exit
MemoryCloningAnalysis:   The stack object   %3 = alloca [80 x i64], align 16, !noelle.pdg.inst.id !942 can be cloned
MemoryCloningAnalysis: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "sha_stream"
Parallelizer: parallelizerLoop:   Loop 17 = "  %33 = icmp sgt i32 %.0.i, 63, !noelle.pdg.inst.id !985"
Parallelizer: parallelizerLoop:   Nesting level = 2
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 = %struct.SHA_INFO* %0
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 =   %5 = getelementptr inbounds [8192 x i8], [8192 x i8]* %4, i64 0, i64 0, !noelle.pdg.inst.id !944
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %9 = bitcast i64* %8 to i8*, !noelle.pdg.inst.id !949
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %10 = bitcast [80 x i64]* %3 to i8*, !noelle.pdg.inst.id !950
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %11 = getelementptr inbounds %struct.SHA_INFO, %struct.SHA_INFO* %0, i64 0, i32 0, i64 0, !noelle.pdg.inst.id !951
Parallelizer: parallelizerLoop:   Environment:   Live-in 5 =   %12 = getelementptr inbounds %struct.SHA_INFO, %struct.SHA_INFO* %0, i64 0, i32 0, i64 1, !noelle.pdg.inst.id !952
Parallelizer: parallelizerLoop:   Environment:   Live-in 6 =   %13 = getelementptr inbounds %struct.SHA_INFO, %struct.SHA_INFO* %0, i64 0, i32 0, i64 2, !noelle.pdg.inst.id !953
Parallelizer: parallelizerLoop:   Environment:   Live-in 7 =   %14 = getelementptr inbounds %struct.SHA_INFO, %struct.SHA_INFO* %0, i64 0, i32 0, i64 3, !noelle.pdg.inst.id !954
Parallelizer: parallelizerLoop:   Environment:   Live-in 8 =   %15 = getelementptr inbounds %struct.SHA_INFO, %struct.SHA_INFO* %0, i64 0, i32 0, i64 4, !noelle.pdg.inst.id !955
Parallelizer: parallelizerLoop:   Environment:   Live-in 9 =   %18 = trunc i64 %17 to i32, !noelle.pdg.inst.id !957
Parallelizer: parallelizerLoop:   Environment:   Live-out 10 =   %.01.i = phi i8* [ %5, %._crit_edge.i ], [ %144, %sha_transform.exit.i ], !noelle.pdg.inst.id !983
Parallelizer: parallelizerLoop:   Environment:   Live-out 11 =   %.0.i = phi i32 [ %18, %._crit_edge.i ], [ %145, %sha_transform.exit.i ], !noelle.pdg.inst.id !984
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: parallelizerLoop: Start
Parallelizer: parallelizerLoop:   Function = "sha_stream"
Parallelizer: parallelizerLoop:   Loop 16 = "  %17 = call i64 @fread(i8* nonnull %5, i64 1, i64 8192, %struct._IO_FILE* %1) #8, !noelle.pdg.inst.id !44"
Parallelizer: parallelizerLoop:   Nesting level = 1
Parallelizer: parallelizerLoop:   Number of threads to extract = 8
Parallelizer: parallelizerLoop:   Environment: live-in and live-out values
Parallelizer: parallelizerLoop:   Environment:   Live-in 0 = %struct.SHA_INFO* %0
Parallelizer: parallelizerLoop:   Environment:   Live-in 1 = %struct._IO_FILE* %1
Parallelizer: parallelizerLoop:   Environment:   Live-in 2 =   %5 = getelementptr inbounds [8192 x i8], [8192 x i8]* %4, i64 0, i64 0, !noelle.pdg.inst.id !944
Parallelizer: parallelizerLoop:   Environment:   Live-in 3 =   %6 = getelementptr inbounds %struct.SHA_INFO, %struct.SHA_INFO* %0, i64 0, i32 1, !noelle.pdg.inst.id !946
Parallelizer: parallelizerLoop:   Environment:   Live-in 4 =   %7 = getelementptr inbounds %struct.SHA_INFO, %struct.SHA_INFO* %0, i64 0, i32 2, !noelle.pdg.inst.id !947
Parallelizer: parallelizerLoop:   Environment:   Live-in 5 =   %9 = bitcast i64* %8 to i8*, !noelle.pdg.inst.id !949
Parallelizer: parallelizerLoop:   Environment:   Live-in 6 =   %10 = bitcast [80 x i64]* %3 to i8*, !noelle.pdg.inst.id !950
Parallelizer: parallelizerLoop:   Environment:   Live-in 7 =   %11 = getelementptr inbounds %struct.SHA_INFO, %struct.SHA_INFO* %0, i64 0, i32 0, i64 0, !noelle.pdg.inst.id !951
Parallelizer: parallelizerLoop:   Environment:   Live-in 8 =   %12 = getelementptr inbounds %struct.SHA_INFO, %struct.SHA_INFO* %0, i64 0, i32 0, i64 1, !noelle.pdg.inst.id !952
Parallelizer: parallelizerLoop:   Environment:   Live-in 9 =   %13 = getelementptr inbounds %struct.SHA_INFO, %struct.SHA_INFO* %0, i64 0, i32 0, i64 2, !noelle.pdg.inst.id !953
Parallelizer: parallelizerLoop:   Environment:   Live-in 10 =   %14 = getelementptr inbounds %struct.SHA_INFO, %struct.SHA_INFO* %0, i64 0, i32 0, i64 3, !noelle.pdg.inst.id !954
Parallelizer: parallelizerLoop:   Environment:   Live-in 11 =   %15 = getelementptr inbounds %struct.SHA_INFO, %struct.SHA_INFO* %0, i64 0, i32 0, i64 4, !noelle.pdg.inst.id !955
Parallelizer: parallelizerLoop:   The loop has not been parallelized
Parallelizer: parallelizerLoop: Exit
Parallelizer: Exit
noelle-meta-clean parallelized_unoptimized.bc parallelized_unoptimized.bc
opt -load /nfs-scratch/simonec/parallelism/parallelization/Gyms/0/NOELLE/install/lib/CleanMetadata.so -CleanMetadata -clean-loop-metadata=true -clean-prof-metadata=true -clean-pdg-metadata=true parallelized_unoptimized.bc -o parallelized_unoptimized.bc
noelle/core/Clean Loop Metadata
noelle/core/Clean PDG Metadata
noelle/core/Clean profiler metadata
opt --strip-named-metadata parallelized_unoptimized.bc -o parallelized_unoptimized.bc
clang -O3 -c -emit-llvm parallelized_unoptimized.bc -o baseline_parallelized.bc
clang -O3 -c -emit-llvm baseline_parallelized.bc -o baseline_parallelized.bc
cp baseline_parallelized.bc sha.bc
make[1]: Leaving directory '/nfs-scratch/simonec/parallelism/parallelization/Gyms/0/all_benchmark_suites/build/MiBench/benchmarks/sha'
